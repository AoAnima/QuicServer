// package DataBase

// import (
// 	. "aoanima.ru/Logger"
// )

// func (подключение *База) Подключиться(путь string) error {
// 	база, err := badger.Open(badger.DefaultOptions(путь))
// 	if err != nil {
// 		Ошибка("  %+v \n", err)
// 	}
// 	подключение.DB = база
// 	return err
// }

/*
Вставить
таблица - это аналог таблицы (клиент, магазин, товар, заказ, адрес... )
ключ это имя поля в объекте, значение которого будет использоваться в качестве ключа документа в формате:

	коллекция:значениеКлючевогоПоля = объект
	клиент.uid1 = объект

	индексы это поля п которым будут созданы индексы:
	 имяПоля.имяВложенногоПоля будет преобразован в
	 коллекция.имяПоля.имяВложенногоПоля:значениеПоля = ключОбъекта(имяКлючевогоПоля:значениеКлючевогоПоля)


	 тогда мы сможем искать например

	 клиент.email = ...
	 или
	если создали индекс по городу: клиент.адрес.город:Ставрополь =  ключОбъекта(имяКлючевогоПоля:значениеКлючевогоПоля)
	то сможем найти  клиент.адрес.город = Ставрополь



	Нужно переделать индексацию, и сигнатуру функции, чотбы можно было передавать список обехктов и ключей
*/

// func ВставитьСтроку(таблица string, ключ string, объект string, индекс []string) ОшибкаБазы {

// 	return ОшибкаБазы{}
// }

/*
	ВставитьДокумент

объект  записи пдолжен быть всегда map[string]interface{}

индекс масссив строк, разделыннх точкой, представляющих собой материализованный путь к значению и полю индекса например Клиент.email:mail@mail.ru
*/
// func (подключение *База) ВставитьДокумент(таблица string, ключ string, объект map[string]interface{}, уникальныйИндекс []string, индексы []string) ОшибкаБазы {

// 	// КоддЗаписи := КодЗаписи(таблица + ":" + ключ)

// 	объект["КодЗаписи"] = КодДокумента.КодЗапасиси()
// 	var УникальныеИндексы map[string]string
// 	if уникальныйИндекс != nil {
// 		УникальныеИндексы = make(map[string]string)
// 		УникальныеИндексы, _ = СоздатьКлючиИндекса(объект, &уникальныйИндекс)
// 	}

// 	ошибка := подключение.Транзакция(изменить, func(трз *Транзакция) ОшибкаБазы {
// 		старт := time.Now()
// 		//провряет существование уникального ключа и исключения дубля первиного ключа для документа
// 		ok, ОшибкаДубльКлюча := трз.УникальныйКлюч(таблица, ключ, УникальныеИндексы)
// 		времяРаботы := time.Since(старт)
// 		Инфо("Время поиска ключа и индекса  %+v \n", времяРаботы)

// 		if !ok {
// 			Ошибка(" ОшибкаДубльКлюча %+v \n", ОшибкаДубльКлюча)
// 			return ОшибкаДубльКлюча
// 		}

// 		Объект, err := Json(объект)
// 		if err != nil {
// 			Ошибка("  %+v \n", err)
// 		}

// 		КлючОбъекта := таблица + ":" + ключ

// 		if err := трз.Set([]byte(КлючОбъекта), Объект); err != nil {
// 			return ОшибкаБазы{
// 				Текст: err.Error(),
// 				Код:   ОшибкаЗаписи,
// 			}
// 		}

// 		//  Получается при каждой вставке  будем проверять таблицу индексов, есть, нету и обновлять... накладно, нужно вынести проверку в отдельную функцию
// 		неУникальныеИндексы, _ := СоздатьКлючиИндекса(объект, индексы)
// 		ошибкаЗаписиИндекса := трз.ВставитьИндекс(таблица, КлючОбъекта, УникальныеИндексы, неУникальныеИндексы, объект["КодЗаписи"].(string))
// 		Инфо(" ошибкаЗаписиИндекса %+v \n", ошибкаЗаписиИндекса)
// 		return ошибкаЗаписиИндекса
// 	})
// 	if ошибка.Код != 0 {
// 		Ошибка("  %+v \n", ошибка)
// 	}
// 	return ошибка
// }

/*
Удалить
Нужно удалять не только ключ, но и индексы связанные с этой записью.

получаем список индексов таблца.индексы
удаляем все индексы связаные с указаным ключём
таблица.индекс:значение

итерируемся по каждому индексу , находим значение в удаляемом докумнте по пути в индексе, адялем запись...
*/
// func (подключение *База) Удалить(таблица string, ключ string) ОшибкаБазы {
// 	if подключение.IsClosed() {
// 		return ОшибкаБазы{
// 			Текст: "соединение с базой закрыто",
// 			Код:   ОшибкаСоединениеЗакрыто,
// 		}
// 	}
// 	подключение.Транзакция(изменить, func(трз *Транзакция) ОшибкаБазы {

// 		// 1. получаем список индексов таблца.индексы
// 		// 2. проверяем есть ли запись с ключём таблица:ключ
// 		// 	если нет то итерируемся по индексамтрз
// 		// 	проверяем записи в индексах: таблица.индекс:ключ
// 		// 		если запись найден проверяем есть ли запись с ключём таблица:[таблица.индекс:ключ]
// 		// 		всё что нашли удаляем
// 		индексы, err := трз.Get([]byte(таблица + ".индексы"))
// 		if err != nil && err != badger.ErrKeyNotFound {
// 			Ошибка("  %+v \n", err)
// 		}

// 		if err == badger.ErrKeyNotFound {
// 			// Индексы не существуют, значит нет индексов связанных с этой таблицей
// 			// Просто удаляем ключ
// 			err = трз.Delete([]byte(таблица + ":" + ключ))
// 			if err != nil {
// 				Ошибка("  %+v \n", err)
// 			}
// 			return ОшибкаБазы{}
// 		} else {
// 			// удаляем запись из таблицы
// 			err = трз.Delete([]byte(таблица + ":" + ключ))
// 			if err != nil {
// 				Ошибка("  %+v \n", err)
// 			}
// 			/*
// 				преобразуем индексы в map, итерируемся по индексам и удаляем все записи связанные с этим ключём....

// 			*/
// 			индексыТаблицы, err := индексы.ValueCopy(nil)
// 			if err != nil {
// 				Ошибка("  %+v \n", err)
// 			}
// 			таблицаИндексов := make(КартаИндексов)
// 			err = ИзJson(индексыТаблицы, &таблицаИндексов)
// 			if err != nil {
// 				Ошибка("  %+v \n", err)
// 			}
// 			return ОшибкаБазы{}
// 		}

// 	})
// 	return ОшибкаБазы{}
// }

// func (подключение *База) Обновить(таблиц string, ключ string, изменяемыйПуть string, новоеЗначение any) ОшибкаБазы {
// 	if подключение.IsClosed() {
// 		return ОшибкаБазы{
// 			Текст: "соединение с базой закрыто",
// 			Код:   ОшибкаСоединениеЗакрыто,
// 		}
// 	}
// 	подключение.Транзакция(изменить, func(трз *Транзакция) ОшибкаБазы {

// 		// 1. проверяем существует ли обект с ключём таблица:ключ
// 		// 2. получаем список индексов таблца.индексы
// 		// 	если обект не существует  то итерируемся по индекса
// 		// 	проверяем записи в индексах: таблица.индекс:ключ
// 		// находим обеъкт по любому индексу, проверяем существует ли изменяемыйПуть:
// 		// 	если есть то меняем значение
// 		// 	если нет то добавляем новый путь в обхект
// 		return ОшибкаБазы{}
// 	})
// 	return ОшибкаБазы{}
// }

// func (подключение *База) ТранзакцияЗаписи(Функ func(трз *Транзакция) ОшибкаБазы) ОшибкаБазы {

// 	if подключение.IsClosed() {
// 		return ОшибкаБазы{
// 			Текст: "соединение с базой закрыто",
// 			Код:   ОшибкаСоединениеЗакрыто,
// 		}
// 	}

// 	трз := подключение.NewTransaction(истина)
// 	defer трз.Discard()

// 	if ошибкаВставки := Функ(&Транзакция{трз}); ошибкаВставки.Код != 0 {
// 		трз.Discard()
// 		return ошибкаВставки
// 	}
// 	err := трз.Commit()
// 	if err != nil {
// 		Ошибка("  %+v \n", err)
// 		return ОшибкаБазы{
// 			Текст: "не удалось зафиксировать транзакцию, причина: " + err.Error(),
// 			Код:   ОшибкаФиксацииТранзакции,
// 		}
// 	}

// 	return ОшибкаБазы{}
// }

/*
Найти
-таблица - это аналог таблицы (клиент, магазин, товар, заказ, адрес... )
-значение -
- индекс это индексируемое поле, или поле внутри объекта, если не было проиндексированно то нужно будет итерироваться по всей таблице, в искомом объекте, если не задан (="") значит не требуется посик по индексу

если задан то ищем по индекса, и затем ищем по значению индекса.
-
*/

// func (подключение *База) Найти(таблица string, значение string, индекс string) (interface{}, error) {

// 	трз := Транзакция{подключение.NewTransaction(false)}
// 	defer трз.Discard()

// 	var ключПоиска string
// 	if индекс != "" {
// 		ключПоиска = таблица + "." + индекс + ":" + значение
// 	} else {
// 		ключПоиска = таблица + ":" + значение
// 	}
// 	найденоеЗначение, err := трз.Get([]byte(ключПоиска))
// 	if err != nil {
// 		Ошибка(" не нашли ничего по ключу %+v err  %+v \n", ключПоиска, err.Error())
// 	}

// 	копияЗначения, err := найденоеЗначение.ValueCopy(nil)
// 	if err != nil {
// 		Ошибка("  %+v \n", err)
// 	}

// 	var найденноеЗначение interface{}
// 	err = ИзJson(копияЗначения, &найденноеЗначение)
// 	if err != nil {
// 		Ошибка("  %+v \n", err)
// 	}
// 	// нашли значение, если индекс не пустой, значит нашли ключ в индексе, получим объект по значению индекса.
// 	//

// 	if индекс != "" {
// 		найденоеЗначение, err = трз.Get([]byte(ключПоиска))
// 		if err == badger.ErrKeyNotFound {
// 			Инфо(" Ключ не найден Error %+v ключПоиска %+v . Пробуем искать по индексу \n", err.Error(), ключПоиска)
// 			// Индекса не существует
// 			/*
// 				Проверим какие индексы есть в таблице, если в указаный индекс есть , и значение не найдено то всё ок, записи прост онет. Иначе если индекса нет, то нужно итерироваться по всей таблице и искать внутри документа
// 			*/
// 			индексыТаблицы, err := трз.Get([]byte(таблица + "." + "индексы"))
// 			if err == badger.ErrKeyNotFound {
// 				Ошибка(" индексы не существуют для   %+v %+v ?  будем перебирать все документы\n", таблица+"."+"индексы", err.Error())
// 			}
// 			копияДанных, err := индексыТаблицы.ValueCopy(nil)
// 			if err != nil {
// 				Ошибка("  %+v \n", err)
// 			}
// 			префиксИндекса := НайтиВJson(копияДанных, таблица+"."+индекс)
// 			if префиксИндекса != nil {
// 				// префиксИндекса если индекс есть в списке индексов таблицы, то т.к. ранее мы не нашли значение по индексу. значит такого документа нету, возращаем ответ что документа нету, потому что инчае документ был бы проиндексирован
// 				return nil, nil
// 			} else {
// 				// индекса нету в списке индексов таблицы, значит нужно итерироваться по всем документам и искать внутри документа
// 				найденныеДанные, err := трз.НайтиЗначение(таблица, значение, индекс)
// 				if err != nil {
// 					Ошибка("  %+v \n", err)
// 				}
// 				return найденныеДанные, err
// 			}

// 		} else if err != nil {
// 			Ошибка("  %+v \n", err.Error())
// 			return nil, err
// 		}

// 		байтЗначение, err := найденоеЗначение.ValueCopy(nil)
// 		if err != nil {
// 			Ошибка("  %+v \n", err)
// 			return nil, err
// 		}

// 		err = ИзJson(байтЗначение, &найденноеЗначение)
// 	}
// 	return найденноеЗначение, err
// }

/*
НайтиЗначение - ищет значение по указаному пути внутри документа, дессериализация не происходит, по идее jsoniter умеет искать внутри бинарного представления
таблица - префикс по которому будем итерировать документы
путь - путь до значения внутри объекта
*/
// func (трз *Транзакция) НайтиЗначение(таблица string, значение string, путь string) (map[string][]byte, error) {
// 	итератор := трз.NewIterator(badger.DefaultIteratorOptions)

// 	defer итератор.Close()

// 	префикс := []byte(таблица)

// 	найденныеДанные := make(map[string][]byte)

// 	for итератор.Seek(префикс); итератор.ValidForPrefix(префикс); итератор.Next() {
// 		объект := итератор.Item()
// 		ключ := объект.Key()
// 		err := объект.Value(func(знач []byte) error {
// 			значениеВОбъекте := НайтиВJson(знач, путь)
// 			if значениеВОбъекте == nil {
// 				// продолжаем итерации по документам
// 			} else {
// 				// значение найдено, кладём ключ документа и документ в карту
// 				Инфо("key=%s, value=%s\n", ключ, знач)
// 				найденныеДанные[string(ключ)] = знач

// 			}
// 			return nil
// 		})
// 		if err != nil {

// 			return nil, err
// 		}
// 	}
// 	return найденныеДанные, nil
// }
