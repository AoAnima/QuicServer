package DataBase

import (
	"strings"

	. "aoanima.ru/Logger"
	"github.com/dgraph-io/badger/v4"
)

/*
ВставитьИндекс
-таблица -передаем имя табилицы
-КлючОбъекта - Адрес  добавленного документа,
-УникальныеИндексы - перечень уникальных индексов
-индексы - перечень индексов
-КодЗаписи - Уникальный код документа сгенерированный перед вставкой

	Добавляет не уникальный индекс вида
			таблица.путь:значениеПоПути|УникальныйКлюЗаписи
			клиент.адрес.город:Ставрополь|УниальныйКод

			тогда пожно искать по префиксу, и получать адреса всех документов в которых индексируемое поле одинаковое prefix(таблица+"."+ключИндекса+":"+значениеИндекса)
*/
func (трз *Транзакция) ВставитьИндекс(таблица string, КлючОбъекта string, УникальныеИндексы map[string]string, индексы map[string]string, КодЗаписи string) ОшибкаБазы {

	if len(УникальныеИндексы) > 0 {
		for ключИндекса, значениеИндекса := range УникальныеИндексы {

			if err := трз.Set([]byte(таблица+"."+ключИндекса+":"+значениеИндекса), []byte(КлючОбъекта)); err != nil {
				return ОшибкаБазы{
					Текст: err.Error(),
					Код:   ОшибкаЗаписи,
				}
			}
			// Добавим в справочник индексов, ключ индексируемого поля, чтобы можно было понять есть ли по искомому запросу индекс, дабы не перебирать все записи
			if документИндексов, err := трз.Get([]byte(таблица + ".индексы")); err != nil && err != badger.ErrKeyNotFound {
				Инфо(" документИндексов %+v \n", документИндексов)
				var картаИндексов КартаИндексов

				таблицаИндексов, err := документИндексов.ValueCopy(nil)
				Инфо(" таблицаИндексов %+v \n", таблицаИндексов)
				if err != nil {
					Ошибка("  %+v \n", err)
				}
				err = ИзJson(таблицаИндексов, &картаИндексов)
				if err != nil {
					Ошибка("  %+v \n", err)
				}
				Инфо("картаИндексов  %+v \n", картаИндексов)
				if _, ok := картаИндексов[таблица+"."+ключИндекса]; ok {
					Инфо("индекс уже существует, ничего не добавляем  %+v \n", картаИндексов)
					continue
				}
				// ключ индекса ещё не был добавлен, добавляем
				картаИндексов[таблица+"."+ключИндекса] = false

				таблицаИндексов, err = Json(картаИндексов)
				if err != nil {
					Ошибка("  %+v \n", err)
				}
				if err := трз.Set([]byte(таблица+".индексы"), таблицаИндексов); err != nil {
					return ОшибкаБазы{
						Текст: err.Error(),
						Код:   ОшибкаЗаписи,
					}
				}
			} else {

				/*
					походу для новой таблицы ещё нет спраовчника индексов,
				*/
				картаИндексов := make(КартаИндексов)
				картаИндексов[таблица+"."+ключИндекса] = false
				Инфо(" картаИндексов %+v \n", картаИндексов)
				таблицаИНдексов, err := Json(картаИндексов)

				if err != nil {
					Ошибка("  %+v \n", err)
				}
				if err := трз.Set([]byte(таблица+".индексы"), таблицаИНдексов); err != nil {
					return ОшибкаБазы{
						Текст: err.Error(),
						Код:   ОшибкаЗаписи,
					}
				}
			}
		}
	}

	if len(индексы) > 0 {
		/*
			Добавляю не уникальный индекс вида
			таблица.путь:значениеПоПути|УникальныйКлюЗаписи
			клиент.адрес.город:Ставрополь|УниальныйКод

			тогда пожно искать по префиксу, и получать адреса всех документов в которых индексируемое поле одинаковое prefix(таблица+"."+ключИндекса+":"+значениеИндекса)


			надо сделать замеры что будет более производительным, создать отдельный документ в котором будут храниться все индексы, или отдельная запись для каждого  индекса...
			Если будет 1000 000 не erybkmys[ запписей дто получать такой документ будет накладно


		*/
		for ключИндекса, значениеИндекса := range УникальныеИндексы {
			if err := трз.Set([]byte(таблица+"."+ключИндекса+":"+значениеИндекса+"|"+КлючОбъекта), []byte(КлючОбъекта)); err != nil {
				return ОшибкаБазы{
					Текст: err.Error() + таблица + "." + ключИндекса + ":" + значениеИндекса + "|" + КлючОбъекта,
					Код:   ОшибкаЗаписи,
				}
			}
		}

	}
	return ОшибкаБазы{
		Код: Ок,
	}
}

/*
ДобавитьЗначениеВМультиИндекс
МультИНдекс - индекс не уникальных значений, если часто ищу значение какого то поля, то можно создать индекс в котором будут храниться ссылки на документы содержащие нужное значение поля

например адрес.город:Ставрополь= ["клиент.ид1", "клиент.ид2", "клиент.ид3"]
и не нужно будет перебирать все документы nxj,s найти у кого в поле город есть Ставрополь

Но чтобы обновить такой индекс нужно достать его, распаковать, добавит значение и запаковать, можно не исопльзовать json? а просто через перенос строки ли запятую добавлять записи используюя merge
но тогда при удалении всё ранво прийдёться всё десериализовать

Тогда лучший вариант будет следущим:
каждый перед записью для каждого документа можно генерировать уникальный uuid или хэш, который здобавлять в документ

а мультииндекс строить по правилу

таблица.<путь к полю>:значение|uuid = таблица.<документ>
пример
клиент.адрес.город:Ставроополь|uuid = клиент.login
клиент.адрес.город:Ставроополь|uuid2 = клиент.login2
клиент.адрес.город:Ставроополь|uuid3 = клиент.login3
*/
func ДобавитьЗначениеВМультиИндекс() {

}

type КартаИндексов map[string]bool
type СвойствоИндекса interface {
	ТипИндекса(уникальный string) bool
}

func (т КартаИндексов) ТипИндекса(уникальный string) bool {

	return ложь
}

// соедин\ет индекс и значение для указанного индекс, проходит по пути указаному в индексе получает значение, и соединяет в одно строку
func СоздатьКлючиИндекса(объект interface{}, индекс *[]string) (map[string]string, error) {

	копияОбъекта := объект
	ЗначенияИндекса := make(map[string]string)

	for _, ключИндекса := range *индекс {

		ПутьКЗначению := strings.Split(ключИндекса, ".")

		for _, ключ := range ПутьКЗначению {
			// Документация: провверим что следующее значение имеет один из типов мап, и приведём к нужному типу, чтобы рантайм мог отличить string от  interface
			/* если  не map[string]interface{} и  не map[string]string то   */
			switch копияОбъекта.(type) {
			case map[string]interface{}:
				if значение, ok := копияОбъекта.(map[string]interface{})[ключ]; ok {
					копияОбъекта = значение
				} else {
					// return nil, errors.New(fmt.Sprintf("нет такого ключа %+v индекс %+v", ключ, индекс))
					Ошибка("нет такого ключа %+v индекс %+v", ключ, индекс)
					копияОбъекта = nil
				}
			case map[string]string:
				if значение, ok := копияОбъекта.(map[string]string)[ключ]; ok {
					копияОбъекта = значение
				} else {
					// return nil, errors.New(fmt.Sprintf("нет такого ключа %+v индекс %+v", ключ, индекс))
					Ошибка("нет такого ключа %+v индекс %+v", ключ, индекс)
					копияОбъекта = nil
				}
			default:
				Инфо(" посследнее значение копияОбъекта  %+v \n", копияОбъекта)
			}

			/* 	if значение, ok := копияОбъекта.(map[string]interface{})[ключ]; ok {
				копияОбъекта = значение
			} else {
				// return nil, errors.New(fmt.Sprintf("нет такого ключа %+v индекс %+v", ключ, индекс))
				Ошибка("нет такого ключа %+v индекс %+v", ключ, индекс)
				копияОбъекта = nil
			} */
		}
		// копияОбъекта - содердит искомое значение
		if копияОбъекта != nil {
			switch копияОбъекта.(type) {
			case []byte:
				ЗначенияИндекса[ключИндекса] = string(копияОбъекта.([]byte))
			case string:
				ЗначенияИндекса[ключИндекса] = копияОбъекта.(string)
			default:
				строка, err := Json(копияОбъекта)
				if err != nil {
					Ошибка("  %+v \n", err)
				}
				ЗначенияИндекса[ключИндекса] = string(строка)

			}
		}
	}
	return ЗначенияИндекса, nil
}

/*
УникальныйКлюч - проверяет существует ли в базе ключ и индексы

принимает теже аргументы что и функция Вставить,
-таблица,
-первичный ключ для записи данных,
-индексы созданные функцией СоздатьКлючиИндекса
- транзакция
если ключ и индексы не найдены то возращает true и пустой объект ОшибкаДублированиеКлюча
Иначе false и ОшибкаДублированиеКлюча с найденным индексом и значением записанным в этот индекс
*/
func (тр *Транзакция) УникальныйКлюч(таблица string, ключ string, индексы map[string]string) (bool, ОшибкаБазы) {
	КлючОбъекта := таблица + ":" + ключ
	найденноеЗначение, err := тр.Get([]byte(КлючОбъекта))

	if err == badger.ErrKeyNotFound {
		// Ключа нет, проверим существование уникальнго индекса, ну фиг знает откуда он взялся, может какойто другой документ имел такой же уникальный индекс...
		if len(индексы) > 0 {
			for ключИндекса, значениеИндекса := range индексы {
				if индексированноеЗначение, err := тр.Get([]byte(таблица + "." + ключИндекса + ":" + значениеИндекса)); err != nil {
					if err == badger.ErrKeyNotFound {
						// индекса нет всё ок, проверяем дальше
					} else {
						// индекс  существует не нужно записывать
						данные, err := индексированноеЗначение.ValueCopy(nil)
						if err != nil {
							Ошибка("  %+v \n", err)
						}
						return false, ОшибкаБазы{
							Индекс:   таблица + "." + ключИндекса + ":" + значениеИндекса,
							Значение: данные,
							Текст:    "индекс существует",
							Код:      ОшибкаДубликатИндекса,
						}
					}
				}
			}
		}
		return true, ОшибкаБазы{}
	} else if err != nil {
		if err != nil {
			Ошибка("  %+v \n", err.Error())
		}
		return false, ОшибкаБазы{
			Текст: err.Error(),
		}
	} else {
		данные, err := найденноеЗначение.ValueCopy(nil)
		if err != nil {
			Ошибка("  %+v \n", err)
		}
		// Ключ существует, запись не производится
		return false, ОшибкаБазы{
			Ключ:     КлючОбъекта,
			Значение: данные,
			Текст:    "ключ существует",
			Код:      ОшибкаДубликатКлюча,
		}
	}
}
