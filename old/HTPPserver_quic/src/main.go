package main

import (
	"context"
	"net/http"
	"sync"

	_ "net/http/pprof"

	. "aoanima.ru/ConnQuic"
	connector "aoanima.ru/connector"
	quic "github.com/quic-go/quic-go"

	. "aoanima.ru/logger"
	"github.com/google/uuid"
)

// структура для сохранения в карту клиенты
type Запрос struct {
	Req         http.Request
	КаналОтвета chan ОтветКлиенту
	ИдКлиента   uuid.UUID
	УИДЗапроса  connector.Уид
}

type ОтветКлиенту struct {
	УИДЗапроса string
	ИдКлиента  uuid.UUID
	Ответ      string
}

// func Уид() uuid.UUID {
// 	// id := uuid.New()
// 	return uuid.New()
// }

func main() {
	/* каналЗапросовОтКлиентов - передаём этот канал в в функци  ЗапуститьСерверТЛС , когда прийдёт сообщение из браузера, функция обработчик запишет данные в этот канал
	 */
	каналЗапросовОтКлиентов := make(chan Запрос, 10)
	/*
	   Запускаем сервер передаём в него канал, в который запишем обработанный запрос из браузера
	*/
	go ЗапуститьСерверТЛС(каналЗапросовОтКлиентов)
	go ПокдлючитьсяКSynQuic("localhost:4242")
	// Инфо(" %s", "запустили сервер")
	// /* Инициализирум сервисы коннектора передадим в них канал, из которого Коннектор будет читать сообщение, и отправлять его в synqTCP  */
	// go ИнициализацияСервисов(каналЗапросовОтКлиентов)

	ЗапуститьСервер()

}

var МьютексСессийSynQuic sync.Mutex
var СессииSynQuic = КартаСессий{}

func ПокдлючитьсяКSynQuic(Адрес string) {
	конфигТлс, err := КлиентскийТлсКонфиг("root.crt")
	if err != nil {
		Ошибка("  %+v \n", err)
	}
	// Адрес = "localhost:4242"
	сессия, err := quic.DialAddr(context.Background(), Адрес, конфигТлс, &quic.Config{})

	if err != nil {
		Ошибка("  %+v \n", err)
	}

	for {
		поток, err := сессия.AcceptStream(context.Background())
		if err != nil {
			Ошибка("  %+v \n", err)
		}
		ДобавиьтНовуюСессиюВКарту(&сессия, &поток)

		// go ЧитатьСообщенияОтSynQuic(поток, обработчикСообщений)

	}
}
func ЗапуститьСерверТЛС(каналЗапросов chan<- Запрос) {

	err := http.ListenAndServeTLS(":443",
		"cert/server.crt",
		"cert/server.key",
		http.HandlerFunc(
			func(w http.ResponseWriter, r *http.Request) {
				go ОтправитьСообщениеВSynQuic(w, r)
			}))

	if err != nil {
		Ошибка(" %s ", err)
	}
}

func ДобавиьтНовуюСессиюВКарту(сессия *quic.Connection, поток *quic.Stream) {
	новаяСессия := Сессия{
		Сессия: *сессия,
		Потоки: []*quic.Stream{поток},
	}
	// новаяСессия.Потоки = append(новаяСессия.Потоки, &поток)
	очередьПотоков := НоваяОчередьПотоков()
	очередьПотоков.Добавить(поток)
	МьютексСессийSynQuic.Lock()
	СессииSynQuic.СессииСервисов = append(СессииSynQuic.СессииСервисов, новаяСессия)
	СессииSynQuic.ОчередьПотоков = очередьПотоков
	МьютексСессийSynQuic.Unlock()
}

// Засада , нужно реализовать на стороне ЫнтЙгшс возможность принимать входящие запросы на открытие новых потоков от клиентов.. по крайней мере от сервреа HTTP
// Либо HTTP сервер должен выступать в роли
func НовыйПоток() *quic.Stream {
	// если в очереди нет потоков то создаём новый для любой сессии , добавляем в очередь и возвращаем поток
	for _, сессияSynQuic := range СессииSynQuic.СессииСервисов {
		новыйПоток, err := сессияSynQuic.Сессия.OpenStream()
		if err != nil {
			Ошибка("  %+v \n", err)
		}
		МьютексСессийSynQuic.Lock()
		СессииSynQuic.ОчередьПотоков.Добавить(&новыйПоток)
		return &новыйПоток
	}
	Инфо(" нужно обработать ошибку когда нет сессий в карте  %+v \n", "Нет сессий ")
	return nil
}

func ЧитатьСообщенияОтSynQuic() {

}

func ОтправитьСообщениеВSynQuic(w http.ResponseWriter, r *http.Request) {
	поток := СессииSynQuic.ОчередьПотоков.Взять()
	if поток == nil {
		поток = НовыйПоток()
		if поток == nil {
			Инфо("Не удалось создать новый поток %+v \n", СессииSynQuic)
			return
		}
	}

	поток.Write()

}

// func ИнициализацияСервисов(поток quic.Stream, каналЗапросовОтКлиентов chan Запрос) {
// 	Сервис := connector.Отпечаток{
// 		Сервис: "КлиентСервер",
// 		Маршруты: map[string]*connector.СтруктураМаршрута{
// 			"ОтветКлиенту": {
// 				Запрос: map[string]interface{}{
// 					"ТипЗпроса":     "int",    // в заивисмости от типа запроса например ajax или обычный request будет возвращён ответ...
// 					"СтрокаЗапроса": "string", // url Path Query
// 					"Форма":         "map[string][]string",
// 					"Файл":          "string",
// 				},
// 				Ответ: map[string]interface{}{
// 					"HTML": "string",
// 					"JSON": "string",
// 				},
// 			},
// 		},
// 	}

// каналПолученияСообщений, каналОтправкиСообщений := connector.ИнициализацияСервиса("localhost",
// 	connector.ПортДляОтправкиСообщений,
// 	connector.ПортДляПолученияСообщений,
// 	Сервис)

// // for ЗапросОтКлиента := range каналЗапросовОтКлиентов {

// go ОтправитьЗапросВОбработку(каналОтправкиСообщений, каналЗапросовОтКлиентов)
// go ОтправитьОтветКлиенту(каналПолученияСообщений)
// ОбработатьСообщение(ЗапросОтКлиента, каналОтправкиСообщений)
// каналОтправкиСообщений <- Кодировать(ЗапросОтКлиента)
// }

// }

// обработчик сообщений от synqTCP
// func ОбработатьСообщение(ВходящееСообщение Запрос, каналОтправкиСообщений chan<- []byte) {

// 	Инфо(" ОбработатьСообщение %+v \n", ВходящееСообщение)

// 	Сообщение, err := Кодировать(ВходящееСообщение)
// 	if err != nil {
// 		Ошибка("  %+v \n", err)
// 	}
// 	// TODO: Реализум логику обработки запроса от клиента, и генерацию ответа

// 	каналОтправкиСообщений <- Сообщение
// }

func ПолучитьУидКЛиента(req *http.Request) uuid.UUID {
	var ИД uuid.UUID

	if cookieUuid, err := req.Cookie("uuid"); err != nil {
		Ошибка(" %+v \n", err)
		ИД = Уид()
	} else {
		ИД, err = uuid.Parse(cookieUuid.Value)
		if err != nil {
			Ошибка("  %+v \n", err)
		}
	}
	return ИД
}

func НовоеСообщение(req *http.Request) {

	данныеЗапроса := connector.Запрос{
		ТипОтвета:      0,
		ТипЗапроса:     0,
		СтрокаЗапроса:  req.URL,
		МаршрутЗапроса: req.URL.Path,
		Форма:          nil,
		Файл:           "",
		УИДЗапроса:     "",
	}

	Сообщение := connector.Сообщение{
		Сервис:       "КлиентСервер",
		Запрос:       данныеЗапроса,
		ТокенКлиента: []byte(""),
		ИдКлиента:    ПолучитьУидКЛиента(&req),
	}

	типДанных := req.Header.Get("Content-Type")
	if req.Method == http.MethodPost {
		if типДанных == "multipart/form-data" {
			Инфо("нужно реализовать декодирование, я так понимаю тут передаются файлы через форму %+v \n", "multipart/form-data")
		}
		req.ParseForm()
		данныеЗапроса.Форма = req.Form
	}
	// if req.Method == "AJAX" || req.Method == "AJAXPost" {
	// 	if типДанных == "application/json" {
	// 		Запрос.ТипЗапроса = connector.AJAX
	// 	}
	// }
	switch req.Method {
	case "AJAX":
		данныеЗапроса.ТипЗапроса = connector.AJAX
		данныеЗапроса.ТипОтвета = connector.AjaxHTML

		break
	case "AJAXPost":
		данныеЗапроса.ТипЗапроса = connector.AJAXPost
		данныеЗапроса.ТипОтвета = connector.AjaxHTML
		break
	case http.MethodGet:
		данныеЗапроса.ТипЗапроса = connector.GET
		данныеЗапроса.ТипОтвета = connector.HTML
		break
	case http.MethodPost:
		данныеЗапроса.ТипЗапроса = connector.POST
		данныеЗапроса.ТипОтвета = connector.HTML
		break
	}

	//каналЗапросов читается в функции ОтправитьЗапросВОбработку, которая отправляет данные в synqTCP поэтому если нужно обраьботкть запро сперед отправкой, то его можно либо обрабатывать тут, перед отправкой в каналЗапросов, лобо внутри фкнции ОтправитьЗапросВОбработку перед записью данный в соединение с synqTCp
	// ИдКлиента := ПолучитьУидКЛиента(&req)
	// УИДЗапроса := fmt.Sprintf("%+s.%+s.%+s", time.Now().Unix(), ИдКлиента, metro.Hash64([]byte(req.URL.Path), 0))
	данныеЗапроса.УИДЗапроса = connector.УИДЗапроса(&Сообщение.ИдКлиента, []byte(req.URL.Path))
	Сообщение.УИДСообщения = данныеЗапроса.УИДЗапроса
	мьютекс.Lock()
	// дополним структуру запроса для карты клиенты
	ЗапросОтКлиента.ИдКлиента = Сообщение.ИдКлиента
	ЗапросОтКлиента.УИДЗапроса = Сообщение.УИДСообщения

	// ЗапросОтКлиента созраням в карте клиенты, сокращённый вариант сообщения который отправляется через коннектор в synqTCP
	if _, ok := клиенты[Сообщение.ИдКлиента]; !ok {
		клиенты[Сообщение.ИдКлиента] = map[connector.Уид]Запрос{}
	} else {
		клиенты[Сообщение.ИдКлиента][данныеЗапроса.УИДЗапроса] = ЗапросОтКлиента
	}
	клиенты[Сообщение.ИдКлиента][данныеЗапроса.УИДЗапроса] = ЗапросОтКлиента
	// клиенты[ЗапросОтКлиента.ИдКлиента][ЗапросОтКлиента.УИДЗапроса] = ЗапросОтКлиента
	мьютекс.Unlock()
	Инфо("ОтправитьЗапросВОбработку  клиенты %+v \n", клиенты)

	// Отправляем данные a synqTCP
	каналОтправкиСообщений <- Кодировать(Сообщение)

}

// go ОтправитьСообщениеВSynQuic(каналЗапросовОтКлиентов)
func обработчикЗапроса(w http.ResponseWriter, req *http.Request, каналЗапросов chan<- Запрос) {

	Инфо(" %s \n", *req)

	каналОтвета := make(chan ОтветКлиенту, 10)

	// отправляем сообщение в функцию  ОтправитьЗапросВОбработку
	каналЗапросов <- Запрос{
		Req:         *req,
		КаналОтвета: каналОтвета,
	}

	// /*  Тут мы читаем из канала  каналОтвета кторый храниться в карте клиенты , данные пишутся в канал  в функции ОтправитьОтветКлиенту */
	for данныеДляОтвета := range каналОтвета {
		if данныеДляОтвета.Ответ != "" {
			Инфо(" данныеДляОтвета.Ответ %+v \n", данныеДляОтвета.Ответ)

			if f, ok := w.(http.Flusher); ok {
				i, err := w.Write([]byte(данныеДляОтвета.Ответ))
				Инфо("  %+v \n", i)
				if err != nil {
					Ошибка(" %s ", err)
				}
				f.Flush()
				break
			}
		}
	}

}

// func ОбработчикОтветов(w http.ResponseWriter, каналОтветов <-chan Ответ) {

// 	Ответ := <-каналОтветов
// 	if Ответ.Сообщение != nil {
// 		w.Write([]byte(Ответ.Сообщение.(string)))
// 	}

// }

func ЗапуститьHTTPСервер() {
	err := http.ListenAndServe(":80", http.HandlerFunc(
		func(w http.ResponseWriter, req *http.Request) {
			// 	Инфо(" %s  %s \n", w, req)
			http.Redirect(w, req, "https://localhost:443"+req.RequestURI, http.StatusMovedPermanently)
		},
	))
	// err := http.ListenAndServe(":6060", nil)
	if err != nil {
		Ошибка(" %s ", err)
	}
	go func() {
		http.ListenAndServe("localhost:6060", nil)
	}()
}
