package main

import (
	"context"
	"time"

	. "aoanima.ru/ConnQuic"
	. "aoanima.ru/DGApi"
	. "aoanima.ru/Logger"
	"github.com/google/uuid"
)

type Адрес struct {
	Страна        string `json:"страна,omitempty"`
	Город         string `json:"город,omitempty"`
	Район         string `json:"район,omitempty"`
	ТипУлицы      string `json:"тип_улицы,omitempty"`
	НазваниеУлицы string `json:"название_улицы,omitempty"`
	НомерДома     string `json:"номер_дома,omitempty"`
	Корпус        string `json:"корпус,omitempty"`
	НомерКвартиры string `json:"номер_квартиры,omitempty"`
}
type Секрет struct {
	ИдКлиента string    `json:"ид_клиента"`
	Секрет    string    `json:"секрет"`
	Обновлен  time.Time `json:"обновлен"`
}
type ДанныеКлиента struct {
	Имя       string    `json:"имя,omitempty"`
	Фамилия   string    `json:"фамилия,omitempty"`
	Отчество  string    `json:"отчество,omitempty"`
	ИдКлиента uuid.UUID `json:"ид_клиента"`
	Роль      []string  `json:"роль,omitempty"`
	Права     []string  `json:"права_доступа,omitempty"`
	Статус    string    `json:"статус,omitempty"`
	Аватар    string    `json:"аватар,omitempty"`
	Email     string    `json:"email,omitempty"`
	Логин     string    `json:"логин,omitempty"`
	Пароль    string    `json:"пароль,omitempty"`
	JWT       string    `json:"jwt,omitempty"`
	Телефон   string    `json:"телефон,omitempty"`
	Адрес     Адрес     `json:"адрес,omitempty"`
	Создан    time.Time `json:"создан,omitempty"`
	Обновлен  time.Time `json:"обновлен,omitempty"`
	ОСебе     string    `json:"о_себе,omitempty"`
	СоцСети   []string  `json:"социальные_ссылки,omitempty"`
	Профиль   map[string]interface{}
}

func main() {
	граф := ДГраф()
	defer граф.ЗакрытьДГраф()

	статус := граф.Схема(ДанныеЗапроса{
		Запрос: СхемаБазы,
	})
	Инфо("  %+v \n", статус)
	// маршрут := "рабочийСтол1"
	// добавить := `[
	// 	{
	// 		"маршрут": "` + маршрут + `",
	// 		"uid": "_:` + маршрут + `",
	// 		"доступ":[{
	// 			"роль" : "администратор1",
	// 			"права": ["чтение", "изменение","удаление"],
	// 			"dgraph.type": "Доступ"
	// 		},
	// 		{
	// 			"роль" : "пользователь",
	// 			"права": ["чтение"],
	// 			"dgraph.type": "Доступ"
	// 		}],
	// 		"описание": "описание маргрута",
	// 		"dgraph.type": "Маршрут1"
	// 	}
	// ]`
	НовыйКлиент := ДанныеКлиента{
		ИдКлиента: uuid.New(),
		Логин:     "anima",
		Пароль:    string("password"),
		Email:     "nefrit@ya.ru",
		Роль:      []string{"клиент"},
		Права:     []string{"чтение", "просмотр", "изменение своего"},
	}
	новыйКлиентаСтрока, ошибка := Json(НовыйКлиент)
	if ошибка != nil {
		Ошибка(" сериализаии нового клиента  %+v  новыйКлиент %+v \n", ошибка, НовыйКлиент)
	}
	Инфо(" новыйКлиентаСтрока%+v \n", новыйКлиентаСтрока)

	// le меньше или равно
	// lt меньше, чем
	// ge больше или равно
	// gt больше, чем
	// регистраци := `upsert{
	// 	query {
	// 	  v as var(func: eq(<логин>, "anima"))
	// 	}
	// 	mutation @if(lt(len(v), 1)) {
	// 	  "set": {
	// 		"логин":"login"
	// 	  }
	// 	}
	//   }`
	// Инфо("регистраци %+v \n", регистраци)
	м := Мутация{
		Условие: "@if(lt(len(v), 1))",
		Мутация: новыйКлиентаСтрока,
	}
	данные := ДанныеЗапроса{
		Запрос: `query User ($логин: string) {
					user(func: eq(<логин>, $логин)){
					<логин>
					v as <uid>
					}
				}`,
		Мутация: []Мутация{м},
		Данные:  nil,
	}

	ctx := context.Background()
	транзакция := граф.Граф.NewTxn()
	defer транзакция.Discard(ctx)

	ответи, статусИзменения := граф.ИзмененитьПоУсловию(данные)

	Инфо(" ответи %+s  статусИзменения %+v  данные %+v \n", ответи, статусИзменения, данные)

	// query:{
	//     checkRoute(func: has(<маршрут>)) {
	//  		   expand(_all_)
	//  		}
	// }

	/*
		РАбочий запрос на выбор с вложенной структурой
	*/
	// ответ, статусхемы := граф.Получить(ДанныеЗапроса{
	// 	Запрос: `{
	// 		checkRoute(func: has(<доступ>)) {
	// 			<маршрут>,
	// 			<доступ> {
	// 				<роль>,
	// 				<права>
	// 				}
	// 			<описание>
	// 			}
	// 	 	 }`,
	// 	Данные: nil,
	// }
	// Так же рабочий пример фильтрации запроса по вложенной структуре доступ
	// query:{
	// 	checkRoute(func: eq(<маршрут>, "рабочийСтол")) {
	// 	<маршрут>,
	// 	<доступ> @filter(eq(<роль>, "пользователь"))  {
	// 		  <роль>,
	// 		  <права>
	// 	},
	// 			  <описание>
	// 				 }
	// 	}

	ответ, статусхемы := граф.Получить(ДанныеЗапроса{
		Запрос: `{
			checkRoute(func: has(<доступ>)) {
				<маршрут>,
				<доступ>  @filter(eq(<роль>, "пользователь")){
					<роль>,
					<права>
					}
				<описание>
				}
		 	 }`,
		Данные: nil,
	})
	Инфо("  %+s %+v \n", ответ, статусхемы)

	// for i := 0; i < 1000; i++ {
	// 	go func() {
	// 		Даннные := ДанныеЗапроса{
	// 			Запрос: "set ",
	// 			Данные: make(map[string]string),
	// 		}
	// 		результат, статус := граф.Изменить(Даннные)
	// 		if статус.Код != Ок {
	// 			Инфо(" %+v \n", статус.Текст)
	// 		}
	// 		Инфо(" результат %+v \n", результат)
	// 	}()
	// }

}

// ИНФО: Получается dgraph  не умеет поддерживать уникальные узлы, нужно самому контролировате перед записью, тоесть каждая запись требующая уникальоного контроля, должна быть предварительно проверена что такого узла нет, и только потом добавлена или обновлена. тоесть оснвоной механизм UPSERT
// проверяем существует ли узел с полем которое для нас должно быть уникальным, если его нет то добавляем узел, иначе обновляем.
var СхемаБазы = `<маршрут>: string  @index(exact) @upsert .
				<обработчик>: string .
				<описание>: string .
				<номер_в_очереди> : int .
				<асинхронный>: bool  .
				<доступ>: [uid] .	
				<пользователь>: uid . 
				<роль>: string . 
				<права>: [string] .
				<дата_создания>: dateTime  .	
				<очередь_обоработчиков>: [uid] .
				<создатель>: uid .
							type <Доступ> {
								<логин>
								<роль>
								<права>
							}
							type <Обработчик> {
								<обработчик>
								<асинхронный>
								<номер_в_очереди>
							}
							type <Маршрут> {
								<маршрут>
								<описание>
								<Доступ>
							}							
							type <ОчередьОбработчиков> {
									<маршрут>									
									<очередь_обоработчиков>
									<дата_создания>
									<создатель>
							}
							<ид_клиента>: string @index(exact) @upsert .
							<права_доступа>: [string] .
							<секрет> : string .
							<имя>: string  .
							<фамилия>: string  .
							<отчество>: string  .
							<логин>: string @index(exact) @upsert .
							<пароль>: password .
							email: string @index(exact) @upsert .
							<телефон>: string @index(exact)  @upsert .
							<создан>: datetime .
							<обновлен>: datetime  .
							<статус>: string  .
							<аватар>: string .
							<о_себе>: string .
							<социальные_ссылки>: [string] .							
							<адрес>: uid .
							<страна>: string  .
							<город>: string  .
							<район>: string  .
							<тип_улицы>: string  .
							<название_улицы>: string  .
							<номер_дома>: string  .
							<корпус>: string  .
							<номер_квартиры>: string  .
							jwt: string .
									type <Секрет> {	
											<ид_клиента> 
											<секрет> 
											<обновлен> 							
										}
										type <Адрес> {
												<страна>
												<город>
												<район>
												<тип_улицы>
												<название_улицы>
												<номер_дома>
												<корпус>
												<номер_квартиры>
										}
										type <Пользователь> {
												<ид_клиента>
												<имя>
												<фамилия>
												<отчество>
												<логин>
												<пароль>
												email
												<телефон>
												<адрес>
												<права_доступа>
												<создан>
												<обновлен>
												<статус>
												<аватар>
												<о_себе>
												<социальные_ссылки>							
												jwt
										}								
						`

// var демоНоваяЗапись = `{"set":[{"маршрут": "маршрут3",
// 							"доступ":[{
// 								"роль" : "администратор",
// 								"права": ["чтение", "изменение","удаление"],
// 						"описание":"описание достпа",
// 								"dgraph.type": "Доступ"
// 				},{
// 								"роль" : "клиент",
// 								"права": ["чтение"],
// 								"dgraph.type": "Доступ"
// 							}],
// 							"описание": "описание маргрута",
// 							"dgraph.type": "Маршрут"
// 				}]}`
