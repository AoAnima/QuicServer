package DataBase

import (
	. "aoanima.ru/ConnQuic"
	. "aoanima.ru/Logger"
	"github.com/dgraph-io/badger/v4"
)

/*
чтобы взывать внутри обекта таблицы:
табл.база.ТранзакцияЗаписи()
транзакция сама делаетКомит когда завершается работа функции
*/
func (подключение *База) ТранзакцияЗаписи(Функ func(трз *Транзакция) ОшибкаБазы) ОшибкаБазы {

	if подключение.IsClosed() {
		return ОшибкаБазы{
			Текст: "соединение с базой закрыто",
			Код:   ОшибкаСоединениеЗакрыто,
		}
	}

	трз := подключение.NewTransaction(изменить)
	defer трз.Discard()

	if Ошибка := Функ(&Транзакция{трз}); Ошибка.Код != 0 {
		трз.Discard()
		return Ошибка
	}

	err := трз.Commit()
	if err != nil {
		Ошибка("  %+v \n", err)
		return ОшибкаБазы{
			Текст: "не удалось зафиксировать транзакцию, причина: " + err.Error(),
			Код:   ОшибкаФиксацииТранзакции,
		}
	}

	return ОшибкаБазы{
		Код:   Ок,
		Текст: "успешно",
	}
}

/*
Транзакция можно исопльзовать вмесето ТранзакцияЗаписи и ТранзакцияЧтение, передавая первым аргументов флаг изменить/записать
Первый аргумент булевый флаг, если истина то режи чтения/записи если ложь то редим чтения
*/
func (подключение *База) Транзакция(изменение bool, Функ func(трз *Транзакция) ОшибкаБазы) ОшибкаБазы {

	if подключение.IsClosed() {
		return ОшибкаБазы{
			Текст: "соединение с базой закрыто",
			Код:   ОшибкаСоединениеЗакрыто,
		}
	}

	трз := подключение.NewTransaction(изменение)
	defer трз.Discard()

	if Ошибка := Функ(&Транзакция{трз}); Ошибка.Код != 0 {
		трз.Discard()
		return Ошибка
	}
	if изменение {
		err := трз.Commit()
		if err != nil {
			Ошибка("  %+v \n", err)
			return ОшибкаБазы{
				Текст: "не удалось зафиксировать транзакцию, причина: " + err.Error(),
				Код:   ОшибкаФиксацииТранзакции,
			}
		}
	}
	return ОшибкаБазы{
		Код:   Ок,
		Текст: "успешно",
	}
}

/*
Транзакция
Первый аргумент булевый флаг, если истина то режи чтения/записи если ложь то редим чтения
*/
func (подключение *База) ТранзакцияЧтение(Функ func(трз *Транзакция) ОшибкаБазы) ОшибкаБазы {

	if подключение.IsClosed() {
		return ОшибкаБазы{
			Текст: "соединение с базой закрыто",
			Код:   ОшибкаСоединениеЗакрыто,
		}
	}
	трз := подключение.NewTransaction(false)
	defer трз.Discard()

	if Ошибка := Функ(&Транзакция{трз}); Ошибка.Код != 0 {
		трз.Discard()
		return Ошибка
	}
	return ОшибкаБазы{
		Код:   Ок,
		Текст: "успешно",
	}
}

func (трз *Транзакция) Получить(ключПоиска ПервичныйКлюч, результат interface{}) (interface{}, ОшибкаБазы) {
	Инфо(" Получить %+v \n", ключПоиска)
	найденоеЗначение, err := трз.Get([]byte(ключПоиска))
	Инфо(" Получить err %+v  найденоеЗначение %+v  ключПоиска %+v  %+v \n", err, найденоеЗначение, ключПоиска, трз)

	if err == badger.ErrKeyNotFound {
		Ошибка(" не нашли ничего по ключу %+v err  %+v \n", ключПоиска, err)
		return nil, ОшибкаБазы{
			Текст: "не нашли ничего по ключу " + string(ключПоиска) + " \n " + err.Error(),
			Код:   ОшибкаКлючНеНайден,
		}
	} else if err != nil {
		Ошибка(" ошибка отличная от  badger.ErrKeyNotFound %+v err  %+v \n", ключПоиска, err)
		return nil, ОшибкаБазы{
			Текст: "не нашли ничего по ключу " + string(ключПоиска) + " \n " + err.Error(),
			Код:   ОшибкаКлючНеНайден,
		}
	}

	Инфо(" найденоеЗначение %+v \n", найденоеЗначение.String())
	Инфо(" результат == nil %+v найденоеЗначение != nil %+v \n", результат == nil, найденоеЗначение != nil)
	// если не передан оюъект в который нужно вернуть найденое значение, то просто возвращаем код Ок и сообщаем что ключ существует, значение не важно, иначе если передан обхект, то получаем значение и вовзращаем
	if результат == nil && найденоеЗначение != nil {
		return nil, ОшибкаБазы{
			Код:   Ок,
			Текст: "Документ с ключём " + string(ключПоиска) + " найден",
		}
	}
	копияЗначения, err := найденоеЗначение.ValueCopy(nil)
	Инфо(" копияЗначения  %+s \n", копияЗначения)
	if err != nil {
		Ошибка("  %+v \n", err)

	}
	// тип := reflect.TypeOf(результат).Elem()
	// // var результат interface{}
	// // Инфо("тип %+s  тип.Kind() %+v тип %+v \n", тип, тип.Kind(), тип.Kind() == reflect.String)
	// if тип.Kind() == reflect.String {
	// 	результат = string(копияЗначения)
	// } else {
	// 	err = ИзJson(копияЗначения, &результат)
	// 	if err != nil {
	// 		Ошибка("  %+v \n", err)
	// 		return nil, ОшибкаБазы{
	// 			Текст: "не удалось преобразовать документ  \n " + err.Error(),
	// 			Код:   ОшибкаПреобразованияДокумента,
	// 		}
	// 	}
	// }

	switch v := результат.(type) {
	case *string:
		*v = string(копияЗначения)
		Инфо(" результат %+v \n", результат)
	default:
		Инфо(" передаём в декодер ИзJson %+v \n", копияЗначения, результат)
		err = ИзJson(копияЗначения, результат)
		Инфо("v  %+v \n", v)
		if err != nil {
			Ошибка("  %+v \n", err)
			return nil, ОшибкаБазы{
				Текст: "не удалось преобразовать документ  \n " + err.Error(),
				Код:   ОшибкаПреобразованияДокумента,
			}
		}
	}

	Инфо(" Возвращаем найденое значение для ключа ключПоиска %+v : %+v \n", ключПоиска, результат)
	return результат, ОшибкаБазы{
		Код:   Ок,
		Текст: "Документ с ключём " + string(ключПоиска) + " найден",
	}
}

func (трз *Транзакция) Записать(ключ ПервичныйКлюч, значение []byte) ОшибкаБазы {
	err := трз.Set([]byte(ключ), значение)
	if err != nil {
		return ОшибкаБазы{
			Текст: err.Error(),
			Код:   ОшибкаЗаписи,
		}
	}
	return ОшибкаБазы{
		Код:   Ок,
		Текст: "успешная запись документа с ключём: " + string(ключ),
	}
}

/*
НайтиЗначение - ищет значение по указаному пути внутри документа, дессериализация не происходит, по идее jsoniter умеет искать внутри бинарного представления
таблица - префикс по которому будем итерировать документы
путь - путь до значения внутри объекта
*/
func (трз *Транзакция) НайтиЗначение(ключ string, значение string) (map[string]Данные, ОшибкаБазы) {
	опции := badger.DefaultIteratorOptions
	опции.PrefetchSize = 10
	итератор := трз.NewIterator(опции)

	defer итератор.Close()

	найденныеДанные := make(map[string]Данные)

	for итератор.Rewind(); итератор.Valid(); итератор.Next() {
		объект := итератор.Item()
		текущийКлюч := объект.Key()
		Инфо(" текущийКлюч %+s \n", текущийКлюч)
		err := объект.Value(func(значениТекущейИтерации []byte) error {
			значениеВОбъекте := НайтиВJson(значениТекущейИтерации, ключ)
			if значениеВОбъекте == nil {
				// продолжаем итерации по документам
			} else {
				// значение найдено, кладём ключ документа и документ в карту
				Инфо("ключ=%s, текущийКлюч=%s, значениеВОбъекте=%s\n", ключ, текущийКлюч, значениеВОбъекте)
				if значениеВОбъекте == значение {
					var данные Данные
					ошибка := ИзJson(значениТекущейИтерации, &данные)
					if ошибка != nil {
						Ошибка("  %+v \n", ошибка)
					}
					найденныеДанные[string(текущийКлюч)] = данные
				}

			}
			return nil
		})
		if err != nil {
			return nil, ОшибкаБазы{
				Код:   ОшибкаКлючНеНайден,
				Текст: err.Error(),
			}
		}
	}
	return найденныеДанные, ОшибкаБазы{
		Код: Ок,
	}
}
