package DataBase

import (
	"strings"

	badger "github.com/dgraph-io/badger/v4"

	. "aoanima.ru/ConnQuic"
	. "aoanima.ru/Logger"
)

// type ТаблицаИндексов interface {
// 	Подключиться(путь string) error
// 	// Создать(списокИндексов []string, списокУникальныхИндексов []string) error
// 	// Вставить(индекс map[string]ПервичныйКлюч) error // Доллжна принимать заменитьУникальныйИндекс если  стоит ложь то будет проверка на существованние уникального индекса, если он есть то возврат ошибки - дубликат первичного ключа, вставка не будет произведена
// 	// а если стоит истина, то будет просто запись, без проверки на существование, и данные будут записаны без ошибки.

// 	// Обновить()
// 	// Удалить()
// 	// Получить()
// 	Записать(chan Документ)
// }

type ПутьИндекса string
type ИмяТаблицы string

type ТаблицаИндексов struct {
	Дирректория string // Путь хранения файлов базы данных /database/КаталогТаблицы
	// КаталогТаблицы string                                  // КаталогТаблицы - подкаталог в Дирректории где хранятся базы, для разделения индексов от других таблиц
	ИмяТаблицы    string                   // имя индексируемой таблицы
	ПутьИндексов  []ПутьИндекса            // Сам индекс , адре.город ... паспорт.серия.
	КартаИндексов map[ПутьИндекса]struct{} // тут  будет хранится в памяти, пока работает сервис, инфомрация о том, какие индексы созданы чтобы быстро создать ключ для поиска индекса в базе.
	Уникальный    bool                     // если  true то  индекс уникальный
	база          База
	трз           Транзакция
	КаналыДанных  КаналыДанных
}

type КаналыДанных struct {
	Запись chan Документ
	Чтение chan Документ
}

/*
 КартаИндексов map[ИмяТаблицы]map[Индекс]ПервичныйКлюч

*/

type БазаИднексов struct {
	УниикальныеИндексы ТаблицаИндексов
	Индексы            ТаблицаИндексов
}

// Обёртка  вокруг Set , запписывает в базу
func (табл *ТаблицаИндексов) Записать(Данные map[ПервичныйКлюч]Документ) ОшибкаБазы {

	// Это должно быть сгенерированно до отправки в Запись
	// if документ.КодДокумента == "" {
	// 	документ.КодЗаписи()
	// }
	ошибка := табл.база.ТранзакцияЗаписи(func(трз *Транзакция) ОшибкаБазы {
		for Ключ, документ := range Данные {

			Объект, err := Json(документ)
			if err != nil {
				Ошибка("  %+v \n", err)
				return ОшибкаБазы{
					Текст: err.Error(),
					Код:   ОшибкаПреобразованияДокумента,
				}
			}
			if err := трз.Set([]byte(Ключ), Объект); err != nil {
				return ОшибкаБазы{
					Текст: err.Error(),
					Код:   ОшибкаЗаписи,
				}
			}
		}

		// var КлючОбъекта string
		// // если записываем в таблицу уикальных ключей, то не добавляем КодДОкумента, иначе, чтобы создать не уникальный ключ то добавим КодДОкумента к ключу
		// if табл.Уникальный {

		// 	КлючОбъекта = string(табл.ПутьИндекса) + ":" + string(Данные.ПервичныйКлюч)
		// }
		// КлючОбъекта = string(табл.ПутьИндекса) + ":" + string(документ.ПервичныйКлюч) + "|" + string(документ.КодДокумента)

		return ОшибкаБазы{
			Код:   Ок,
			Текст: "успешно",
		}
	})
	return ошибка
}

/*
Подлкючиться- подключается к базе данных по пути созданному из данных Индексиремой  таблицы  [Дирректория, Имя]
если передана не пустая строка в аргументе функции то подключаемс по указанному пути, иначе берём данные из данных таблицы
по  умолчанию

	Дирректория = "./database"

Имя = "index"
*/
func (т *ТаблицаИндексов) Подключиться(путь string) ОшибкаБазы {

	if путь == "" {
		if т.Дирректория == "" {
			т.Дирректория = "./database/index"
			if т.Уникальный {
				т.Дирректория = "./database/uniq_index"
			}
		}
		// if т.КаталогТаблицы == "" {
		// 	т.КаталогТаблицы = "index"
		// }
		// путь = т.Дирректория + "/" + т.КаталогТаблицы
		путь = т.Дирректория
	}
	база, err := badger.Open(badger.DefaultOptions(путь))
	if err != nil {
		Ошибка("  %+v \n", err)
		return ОшибкаБазы{
			Код:   ОшибкаПодключения,
			Текст: err.Error(),
		}
	}
	т.база = База{база}
	return ОшибкаБазы{
		Код:   Ок,
		Текст: "успешно подключились",
	}
}

func (и ТаблицаИндексов) Создать(списокИндексов []string, списокУникальныхИндексов []string) error {
	Инфо(" индексы  %+v \n", списокИндексов)
	return nil
}
func (т ТаблицаИндексов) Вставить(индекс map[string]ПервичныйКлюч) error {
	Инфо(" индексы  %+v \n", индекс)

	return nil
}

func (и ТаблицаИндексов) Обновить() {
	Инфо(" индексы  %+v \n", и)
}
func (и ТаблицаИндексов) Удалить() {
	Инфо(" индексы  %+v \n", и)

}

func (и ТаблицаИндексов) Получить() {
	Инфо(" индексы  %+v \n", и)

}

// соедин\ет индекс и значение для указанного индекс, проходит по пути указаному в индексе получает значение, и соединяет в одно строку

// type ТаблицаИндексов interface {
// 	Создать(списокИндексов []string, списокУникальныхИндексов []string)
// 	ПолучитьИиндексы()
// 	ПолучитьУниклаьныеИндексы()
// }

func СоздатьЗначенияИндексов(объект *interface{}, индекс *map[string]struct{}, униклаьныйИндекс bool) (map[string]struct{}, error) {

	копияОбъекта := *объект
	КодЗаписи := копияОбъекта.(map[string]interface{})["КодЗаписи"]
	ЗначенияИндекса := make(map[string]struct{})

	for ключИндекса, _ := range *индекс {

		ПутьКЗначению := strings.Split(ключИндекса, ".")

		for _, ключ := range ПутьКЗначению {
			// Документация: провверим что следующее значение имеет один из типов мап, и приведём к нужному типу, чтобы рантайм мог отличить string от  interface
			/* если  не map[string]interface{} и  не map[string]string то   */
			switch копияОбъекта.(type) {
			case map[string]interface{}:
				if значение, ok := копияОбъекта.(map[string]interface{})[ключ]; ok {
					копияОбъекта = значение
				} else {
					// return nil, errors.New(fmt.Sprintf("нет такого ключа %+v индекс %+v", ключ, индекс))
					Ошибка("нет такого ключа %+v индекс %+v", ключ, индекс)
					копияОбъекта = nil
				}
			case map[string]string:
				if значение, ok := копияОбъекта.(map[string]string)[ключ]; ok {
					копияОбъекта = значение
				} else {
					// return nil, errors.New(fmt.Sprintf("нет такого ключа %+v индекс %+v", ключ, индекс))
					Ошибка("нет такого ключа %+v индекс %+v", ключ, индекс)
					копияОбъекта = nil
				}
			default:
				Инфо(" посследнее значение копияОбъекта  %+v \n", копияОбъекта)
			}

			/* 	if значение, ok := копияОбъекта.(map[string]interface{})[ключ]; ok {
				копияОбъекта = значение
			} else {
				// return nil, errors.New(fmt.Sprintf("нет такого ключа %+v индекс %+v", ключ, индекс))
				Ошибка("нет такого ключа %+v индекс %+v", ключ, индекс)
				копияОбъекта = nil
			} */
		}
		// копияОбъекта - содердит искомое значение
		if копияОбъекта != nil {
			var значениеИндекса string
			switch копияОбъекта.(type) {
			case []byte:
				значениеИндекса = ключИндекса + ":" + string(копияОбъекта.([]byte))
				// ЗначенияИндекса[ключИндекса+":"+string(копияОбъекта.([]byte))] = struct{}{}
			case string:
				значениеИндекса = ключИндекса + ":" + копияОбъекта.(string)
				// ЗначенияИндекса[ключИндекса+":"+копияОбъекта.(string)] =  struct{}{}
			default:
				строка, err := Json(копияОбъекта)
				if err != nil {
					Ошибка("  %+v \n", err)
				}
				значениеИндекса = ключИндекса + ":" + string(строка)
				// ЗначенияИндекса[ключИндекса+":"+string(строка)] = struct{}{}

			}
			// если  стоит флаг униклаьныеИНдексы = ложь значит создаём индекс который будет не уникальным, добавляя в конец "|"+КодЗаписи
			if !униклаьныйИндекс {
				значениеИндекса = значениеИндекса + "|" + КодЗаписи.(string)
			}
			ЗначенияИндекса[значениеИндекса] = struct{}{}
		}
	}
	return ЗначенияИндекса, nil
}

type Индекс map[string]struct{}

func (т Таблица) СоздатьОписаниеИндексов(списокИндексов []string) (Индекс, ОшибкаБазы) {

	индексы := make(map[string]struct{}, len(списокИндексов))
	for _, индекс := range списокИндексов {
		индексы[индекс] = struct{}{}
	}
	индексыJson, err := Json(индексы)
	if err != nil {
		Ошибка("  %+v \n", err.Error())
	}

	т.Подключиться(ПутьКФайламБазы + т.Имя)
	ошибка := т.база.Транзакция(изменить, func(трз *Транзакция) ОшибкаБазы {

		return трз.Записать(т.ПутьИндекса+".индексы", индексыJson)
	})

	return индексы, ошибка
}

/*
Запправшивает данные из таблицы индексов, и дессериализует в структуру таблица.индексы
*/
func (т Таблица) ПолучитьИндексы() ОшибкаБазы {
	ключПоиска := т.Имя + ".индексы"

	ошибка := т.трз.Получить(ключПоиска, &т.индексы)
	if ошибка.Код != Ок {
		return ошибка
	}
	// т.индексы = индексы.(map[string]struct{})
	return ОшибкаБазы{Код: Ок}
}

func (т Таблица) ПолучитьУникальныеИндексы() ОшибкаБазы {
	ключПоиска := т.Имя + ".индексы.уникальные"
	ошибка := т.трз.Получить(ключПоиска, &т.униикальныеИндексы)
	if ошибка.Код != Ок {
		return ошибка
	}
	// т.униикальныеИндексы = индексы.(map[string]struct{})
	return ОшибкаБазы{Код: Ок}
}
