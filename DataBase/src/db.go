package DataBase

import (
	. "aoanima.ru/ConnQuic"
	. "aoanima.ru/Logger"
	badger "github.com/dgraph-io/badger/v4"
)

/*

	ошибкаПодключения := т.база.Подключиться(ПутьКФайламБазы + т.Имя + ".indexes")
	if ошибкаПодключения != nil {
		Ошибка(" ошибка подключения %+v \n", ошибкаПодключения)
		return ОшибкаБазы{
			Код:   ОшибкаПодключения,
			Текст: ошибкаПодключения.Error(),
		}
	}
	т.трз = Транзакция{т.база.NewTransaction(читать)}
	таблица.ПолучитьСигнатуруТаблицы()

	func (т Таблица  )Вставить(){

	}

		// ошибка := т.база.Транзакция(изменить, func(трз *Транзакция) ОшибкаБазы {
		// 	трз.Вставить(данные map[string][]byte, заменитьУникальныйКлюч bool)
		// })
		// или
		// ошибка := т.база.Транзакция(изменить, func(трз *Транзакция) ОшибкаБазы {

		// 	трз.Вставить(данные map[string][]byte, заменитьУникальныйКлюч bool)
		// })

*/

/*

ВСТАВИТЬ не открывет подклчючений к базе и транзакцию, это должно быть создано до вызова функции Всавить
Также до вызова функции должны быть получены индексы таблицы, и записаны в структуру в соответствующие поля
Если поля индексы пустые, то функция считает что индексов нет, и просто делает за  ись в базу данных
*/
// func (т *Таблица) Вставить (данные *map[string]interface{}, заменитьУникальныйКлюч bool) {

//   /*
//   1. прооверяем существует ли запись с ключём документа:
//     если ключ свободен то записывааем данные в базу но не закрываем транзакцию

//   2. Исппользуем
//   */

//		if т.индексы != nil {
//			индексы, ошибка := СоздатьЗначенияИндексов(данные, &т.индексы, ложь)
//			if ошибка != nil {
//				Ошибка("  %+v \n", ошибка)
//			}
//		}
//		if т.униикальныеИндексы != nil {
//			униикальныеИндексы, ошибка := СоздатьЗначенияИндексов(данные, &т.униикальныеИндексы, истина)
//			if ошибка != nil {
//				Ошибка("  %+v \n", ошибка)
//			}
//		}
//	}

func (таблица *Таблица) Подключиться(путь string) ОшибкаБазы {
	if путь == "" {
		путь = таблица.Дирректория + "." + таблица.Имя
	}
	база, err := badger.Open(badger.DefaultOptions(путь))
	if err != nil {
		Ошибка("  %+v \n", err)
		return ОшибкаБазы{
			Код:   ОшибкаПодключения,
			Текст: err.Error(),
		}
	}
	таблица.база = База{база}
	return ОшибкаБазы{
		Код:   0,
		Текст: "успешное подключение",
	}
}

/*
чтобы взывать внутри обекта таблицы:
табл.база.ТранзакцияЗаписи()
транзакция сама делаетКомит когда завершается работа функции
*/
func (подключение *База) ТранзакцияЗаписи(Функ func(трз *Транзакция) ОшибкаБазы) ОшибкаБазы {

	if подключение.IsClosed() {
		return ОшибкаБазы{
			Текст: "соединение с базой закрыто",
			Код:   ОшибкаСоединениеЗакрыто,
		}
	}

	трз := подключение.NewTransaction(изменить)
	defer трз.Discard()

	if Ошибка := Функ(&Транзакция{трз}); Ошибка.Код != 0 {
		трз.Discard()
		return Ошибка
	}

	err := трз.Commit()
	if err != nil {
		Ошибка("  %+v \n", err)
		return ОшибкаБазы{
			Текст: "не удалось зафиксировать транзакцию, причина: " + err.Error(),
			Код:   ОшибкаФиксацииТранзакции,
		}
	}

	return ОшибкаБазы{
		Код:   Ок,
		Текст: "успешно",
	}
}

/*


 */

/*
Созздаёт покдлючения к базе данныхи и базе индексов , запускает горутину которя возвращает канал, из которого она читает данные для записис в таблицу,
так же создаёт аналогичные каналы для индексов
*/
func (таблица *Таблица) АктивироватьТаблицу() ОшибкаБазы {

	ошибка := таблица.Подключиться("") // открываем соединение к базе данных
	if ошибка.Код != 0 {
		return ошибка
	}
	ошибка = таблица.СоздатьИндексы()
	if ошибка.Код != 0 {
		return ошибка
	}
	return ОшибкаБазы{
		Код:   Ок,
		Текст: "успешно",
	}
}

func (таблица *Таблица) СоздатьИндексы() ОшибкаБазы {
	var ошибка ОшибкаБазы

	ошибка = таблица.индексы.Подключиться("")

	if ошибка.Код != 0 {
		return ошибка
	}
	// Если  инексов нету то создает, если есть возвращает ошибку в поле Значение котрой будут картаиндексов в форрмате []byte
	индексы, ошибка := таблица.индексы.ПроверитьИндексы()
	// В
	if ошибка.Код == ИндексыСуществуют {
		Инфо(" чтоо с ними делать ? индексы %+v \n", индексы)
		return ошибка
	}
	ошибка = таблица.униикальныеИндексы.Подключиться("")
	if ошибка.Код != 0 {
		return ошибка
	}
	униикальныеИндексы, ошибка := таблица.униикальныеИндексы.ПроверитьИндексы()

	if ошибка.Код == ИндексыСуществуют {
		Инфо(" чтоо с ними делать ? индексы %+v \n", униикальныеИндексы)
		return ошибка
	}

	return ОшибкаБазы{
		Код:   Ок,
		Текст: "успешно",
	}
}

/*
ПроверитьИндексы провеяет существует ли в базе таблица метаданные, если не существует то создаёт запись с ключём имяТбалицы.метаданные и значением КартаИНдексов
если Существуют то возвращем ошибку ИндексыСуществуют и в Поле Значение записываем сущетсующие индексы, в []byte
*/
func (таблица *ТаблицаИндексов) ПроверитьИндексы() (interface{}, ОшибкаБазы) {
	Инфо(" неообходимо проверить существует ли база с индексами, если да то получить структуру и вернуть %+v \n")

	ошибка := таблица.база.ТранзакцияЗаписи(func(трз *Транзакция) ОшибкаБазы {

		индексыТаблицы, err := трз.Get([]byte(таблица.ИмяТаблицы + "." + "метаданные"))

		if err == badger.ErrKeyNotFound {

			Инфо(" Документ   %+v.метаданные не найден %+v, индексы не существуют создаём новую запись \n", таблица.ИмяТаблицы, err)

			ключ := []byte(таблица.ИмяТаблицы + "." + "метаданные")
			значение, err := Json(таблица.КартаИндексов)
			if err != nil {
				Ошибка("  %+v \n", err.Error())
			}
			err = трз.Set(ключ, значение)
			if err != nil {
				Ошибка("  %+v \n", err.Error())
				return ОшибкаБазы{
					Код:   ОшибкаЗаписи,
					Текст: err.Error(),
				}
			}

		} else {
			существующиеИндексы, err := индексыТаблицы.ValueCopy(nil)
			if err != nil {
				Ошибка("  %+v \n", err.Error())
			}
			return ОшибкаБазы{
				Код:      ИндексыСуществуют,
				Текст:    "Индексы уже созданы, база не пуста",
				Значение: существующиеИндексы,
			}
		}
		return ОшибкаБазы{
			Код:   Ок,
			Текст: "успешно",
		}
	})
	// if ошибка.Код != Ок {
	// 	return nil, ошибка
	// }
	// // если всё ок то проверяем уникальные индексы
	// ошибка = таблица.униикальныеИндексы.база.Транзакция(читать, func(трз *Транзакция) ОшибкаБазы {
	// 	индексыТаблицы, err := трз.Get([]byte(таблица.индексы.ИмяТаблицы + "." + "метаданные"))
	// 	if err == badger.ErrKeyNotFound {
	// 		Инфо(" Документ   %+v.метаданные не найден %+v, индексы не существуют создаём новую запись \n", таблица.индексы.ИмяТаблицы, err)
	// 	} else {
	// 		существующиеИндексы, err := индексыТаблицы.ValueCopy(nil)
	// 		if err != nil {
	// 			Ошибка("  %+v \n", err.Error())
	// 		}
	// 		return ОшибкаБазы{
	// 			Код:      ИндексыСуществуют,
	// 			Текст:    "Индексы уже созданы, база не пуста",
	// 			Значение: существующиеИндексы,
	// 		}
	// 	}
	// 	return ОшибкаБазы{
	// 		Код:   Ок,
	// 		Текст: "успешно",
	// 	}
	// })

	return ошибка.Значение, ошибка

}
