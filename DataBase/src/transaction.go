package DataBase

import (
	. "aoanima.ru/ConnQuic"
	. "aoanima.ru/Logger"
	"github.com/dgraph-io/badger/v4"
)

/*
чтобы взывать внутри обекта таблицы:
табл.база.ТранзакцияЗаписи()
транзакция сама делаетКомит когда завершается работа функции
*/
func (подключение *База) ТранзакцияЗаписи(Функ func(трз *Транзакция) ОшибкаБазы) ОшибкаБазы {

	if подключение.IsClosed() {
		return ОшибкаБазы{
			Текст: "соединение с базой закрыто",
			Код:   ОшибкаСоединениеЗакрыто,
		}
	}

	трз := подключение.NewTransaction(изменить)
	defer трз.Discard()

	if Ошибка := Функ(&Транзакция{трз}); Ошибка.Код != 0 {
		трз.Discard()
		return Ошибка
	}

	err := трз.Commit()
	if err != nil {
		Ошибка("  %+v \n", err)
		return ОшибкаБазы{
			Текст: "не удалось зафиксировать транзакцию, причина: " + err.Error(),
			Код:   ОшибкаФиксацииТранзакции,
		}
	}

	return ОшибкаБазы{
		Код:   Ок,
		Текст: "успешно",
	}
}

/*
Транзакция можно исопльзовать вмесето ТранзакцияЗаписи и ТранзакцияЧтение, передавая первым аргументов флаг изменить/записать
Первый аргумент булевый флаг, если истина то режи чтения/записи если ложь то редим чтения
*/
func (подключение *База) Транзакция(изменение bool, Функ func(трз *Транзакция) ОшибкаБазы) ОшибкаБазы {

	if подключение.IsClosed() {
		return ОшибкаБазы{
			Текст: "соединение с базой закрыто",
			Код:   ОшибкаСоединениеЗакрыто,
		}
	}

	трз := подключение.NewTransaction(изменение)
	defer трз.Discard()

	if Ошибка := Функ(&Транзакция{трз}); Ошибка.Код != 0 {
		трз.Discard()
		return Ошибка
	}
	if изменение {
		err := трз.Commit()
		if err != nil {
			Ошибка("  %+v \n", err)
			return ОшибкаБазы{
				Текст: "не удалось зафиксировать транзакцию, причина: " + err.Error(),
				Код:   ОшибкаФиксацииТранзакции,
			}
		}
	}
	return ОшибкаБазы{
		Код:   Ок,
		Текст: "успешно",
	}
}

/*
Транзакция
Первый аргумент булевый флаг, если истина то режи чтения/записи если ложь то редим чтения
*/
func (подключение *База) ТранзакцияЧтение(Функ func(трз *Транзакция) ОшибкаБазы) ОшибкаБазы {

	if подключение.IsClosed() {
		return ОшибкаБазы{
			Текст: "соединение с базой закрыто",
			Код:   ОшибкаСоединениеЗакрыто,
		}
	}
	трз := подключение.NewTransaction(false)
	defer трз.Discard()

	if Ошибка := Функ(&Транзакция{трз}); Ошибка.Код != 0 {
		трз.Discard()
		return Ошибка
	}
	return ОшибкаБазы{
		Код:   Ок,
		Текст: "успешно",
	}
}

func (трз *Транзакция) Получить(ключПоиска ПервичныйКлюч, результат interface{}) ОшибкаБазы {
	найденоеЗначение, err := трз.Get([]byte(ключПоиска))
	if err != badger.ErrKeyNotFound {
		Ошибка(" не нашли ничего по ключу %+v err  %+v \n", ключПоиска, err.Error())
		return ОшибкаБазы{
			Текст: "не нашли ничего по ключу " + string(ключПоиска) + " \n " + err.Error(),
			Код:   ОшибкаКлючНеНайден,
		}
	} else if err != nil {
		Ошибка(" ошибка отличная от  badger.ErrKeyNotFound %+v err  %+v \n", ключПоиска, err.Error())
		return ОшибкаБазы{
			Текст: "не нашли ничего по ключу " + string(ключПоиска) + " \n " + err.Error(),
			Код:   ОшибкаКлючНеНайден,
		}
	}

	if найденоеЗначение != nil {
		return ОшибкаБазы{
			Код:   Ок,
			Текст: "Документ с ключём " + string(ключПоиска) + " найден",
		}
	}
	копияЗначения, err := найденоеЗначение.ValueCopy(nil)
	if err != nil {
		Ошибка("  %+v \n", err)

	}
	// var результат interface{}

	err = ИзJson(копияЗначения, &результат)
	if err != nil {
		Ошибка("  %+v \n", err)
		return ОшибкаБазы{
			Текст: "не удалось преобразовать документ  \n " + err.Error(),
			Код:   ОшибкаПреобразованияДокумента,
		}
	}
	return ОшибкаБазы{
		Код:   Ок,
		Текст: "Документ с ключём " + string(ключПоиска) + " найден",
	}
}

func (трз *Транзакция) Записать(ключ ПервичныйКлюч, значение []byte) ОшибкаБазы {
	err := трз.Set([]byte(ключ), значение)
	if err != nil {
		return ОшибкаБазы{
			Текст: err.Error(),
			Код:   ОшибкаЗаписи,
		}
	}
	return ОшибкаБазы{
		Код:   Ок,
		Текст: "успешная запись документа с ключём: " + string(ключ),
	}
}
