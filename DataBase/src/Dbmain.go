package DataBase

import (
	"strings"

	. "aoanima.ru/ConnQuic"
	. "aoanima.ru/Logger"
	badger "github.com/dgraph-io/badger/v4"
)

func main() {

	/*
		1 Описать таблицу, имя таблицы
		2 Описать индексы
		3 Описать уникальные индексы
		4 Описать функции

	*/

	таблица := Таблица{
		Имя:           "клиенты",
		Дирректория:   "./database",
		ПервичныйКлюч: "Email", //
		база:          База{},
		индексы: ТаблицаИндексов{
			Версия:      1,
			Дирректория: "./database/index",
			ИмяТаблицы:  "клиенты",
			КартаИндексов: map[ПутьИндекса]struct{}{
				"Адрес.Город": struct{}{},
			},
		},
		уникальныеИндексы: ТаблицаИндексов{
			Версия:      1,
			Дирректория: "./database/uniq_index",
			ИмяТаблицы:  "клиенты",
			КартаИндексов: map[ПутьИндекса]struct{}{
				"Email": struct{}{},
				"Логин": struct{}{},
			},
			Уникальный: true,
		},
		// базаИндексов: &БазаИднексов{
		// 	УниикальныеИндексы: ТаблицаИндексов{
		// 		Дирректория: "./database/index",
		// 		ИмяТаблицы:  "клиенты",
		// 		ПутьИндексов: ,
		// 	},
		// },
	}

	ошибкаБазы := таблица.АктивироватьТаблицу()
	if ошибкаБазы.Код != 0 {
		Ошибка(" ошибкаБазы %+v \n", ошибкаБазы)
	}

	док := Документ{
		// ПервичныйКлюч: значениеПервичногоКлюча,
		Данные: map[string]interface{}{
			"Логин":    "anima",
			"Email":    "anima@ao.ru",
			"Фамилия":  "Петров",
			"Имя":      "Александр",
			"Отчество": "Сергеевич",
			"Адрес": map[string]interface{}{
				"Страна":   "Россия",
				"Город":    "Москва",
				"Улица":    "Льва Толстого",
				"Дом":      "16",
				"Квартира": "2",
			},
		},
	}
	таблица.ВставитьДокумент(&док, false)

	таблица.Найти("Логин", "anima")

}

func (документ *Документ) СоздатьПервичныйКлюч(ПутьКЗначению ПервичныйКлюч) ПервичныйКлюч {
	данные := interface{}(документ.Данные)
	путьКЗначению := strings.Split(string(ПутьКЗначению), ".")
	значениеКлюча := НайтиЗначениеВДанных(путьКЗначению, &данные)
	документ.ПервичныйКлюч = ПутьКЗначению + ":" + значениеКлюча.(ПервичныйКлюч)
	return документ.ПервичныйКлюч
}

/*
ключ это тоже самое что индекс, или путь к искомому значению, может совпадать со строкой индекса
*/
func (таблица *Таблица) Найти(ключ string, значение string) (interface{}, ОшибкаБазы) {
	if ключ == string(таблица.ПервичныйКлюч) {
		var документ interface{}
		ошибкаБазы := таблица.база.ТранзакцияЧтение(func(трз *Транзакция) ОшибкаБазы {
			return трз.Получить(ПервичныйКлюч(таблица.Имя+"."+ключ+":"+значение), документ)
		})
		return документ, ошибкаБазы

	} else {

		if _, ок := таблица.индексы.КартаИндексов[ПутьИндекса(ключ)]; ок {
			var значениеИндекса string
			ошибкаБазы := таблица.уникальныеИндексы.база.ТранзакцияЧтение(func(трз *Транзакция) ОшибкаБазы {

				итератор := трз.NewIterator(badger.DefaultIteratorOptions)
				defer итератор.Close()
				префиксИндекса := []byte(таблица.Имя + "." + ключ + ":" + значение)

				for итератор.Seek(префиксИндекса); итератор.ValidForPrefix(префиксИндекса); итератор.Next() {
					объект := итератор.Item()
					k := объект.Key()
					err := объект.Value(func(v []byte) error {
						Инфо("key=%s, value=%s\n", k, v)
						return nil
					})
					if err != nil {
						Ошибка(" %+v \n", err.Error())
					}
				}
				return трз.Получить(ПервичныйКлюч(таблица.Имя+"."+ключ+":"+значение), значениеИндекса)
			})
			if ошибкаБазы.Код == Ок {
				Инфо(" %+v \n", ошибкаБазы)
				// var документ interface{}
				// ошибкаПолучениДокумента := таблица.база.ТранзакцияЧтение(func(трз *Транзакция) ОшибкаБазы {
				// 	return трз.Получить(ПервичныйКлюч(таблица.Имя+"."+ключ+":"+значение), документ)
				// })
				// return документ, ошибкаПолучениДокумента
			}

		}

		/*
			Документация:

			ключ поиска не совпадает с первичным ключём документов текущей таблицы
			Проверим совпадение с уникальныеИндексы
		*/
		if _, ок := таблица.уникальныеИндексы.КартаИндексов[ПутьИндекса(ключ)]; ок {
			var значениеИндекса string
			ошибкаБазы := таблица.уникальныеИндексы.база.ТранзакцияЧтение(func(трз *Транзакция) ОшибкаБазы {
				return трз.Получить(ПервичныйКлюч(таблица.Имя+"."+ключ+":"+значение), значениеИндекса)
			})
			if ошибкаБазы.Код == Ок {
				var документ interface{}
				ошибкаПолучениДокумента := таблица.база.ТранзакцияЧтение(func(трз *Транзакция) ОшибкаБазы {
					return трз.Получить(ПервичныйКлюч(значениеИндекса), документ)
				})

				if ошибкаПолучениДокумента.Код == ОшибкаКлючНеНайден {
					Ошибка(" %+v \n", ошибкаПолучениДокумента)
					return nil, ошибкаПолучениДокумента

				}
			}
		}

	}
	return nil, ОшибкаБазы{
		Текст: "Документ не найден",
		Код:   ОшибкаКлючНеНайден,
	}
}

func НайтиНеУникальныйИндекс() {
	// нужно итерироваться по префиксам

}

func (таблица *Таблица) ВставитьДокумент(документ *Документ, перезаписатьУникальныйКлюч bool) ОшибкаБазы {
	/*
		Проверить уникальный ключ
		Если его нет то вставить иначе , если стоит флаг перезаписать то перезаписываем
	*/
	if документ.КодДокумента == "" {
		документ.КодДокумента = документ.КодЗаписи()
	}

	if документ.ПервичныйКлюч == "" {
		документ.ПервичныйКлюч = документ.СоздатьПервичныйКлюч(таблица.ПервичныйКлюч)
	}

	ошибкаБазы := таблица.уникальныеИндексы.база.ТранзакцияЧтение(func(трз *Транзакция) ОшибкаБазы {

		ошибкаБазы := трз.Получить(ПервичныйКлюч(таблица.Имя)+"."+документ.ПервичныйКлюч, nil)
		if ошибкаБазы.Код == ОшибкаКлючНеНайден {
			// Создаём новую запись и индексы

			return ошибкаБазы
		}
		return ошибкаБазы
	})

	ошибкаБазы = таблица.база.ТранзакцияЗаписи(func(трз *Транзакция) ОшибкаБазы {
		объектЗаписи, ошибка := Json(документ.Данные)
		if ошибка != nil {
			Ошибка(" %+v \n", ошибка)
			return ОшибкаБазы{
				Код:   ОшибкаПреобразованияДокумента,
				Текст: ошибка.Error()}
		}
		ошибкаБазы := трз.Записать(ПервичныйКлюч(таблица.Имя)+"."+документ.ПервичныйКлюч, объектЗаписи)
		return ошибкаБазы
	})

	if ошибкаБазы.Код == Ок {
		ошибкаБазы = таблица.СоздатьИндексы(документ) //
	}

	return ошибкаБазы
}
