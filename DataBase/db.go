package DataBase

import (
	"strings"
	"sync"

	. "aoanima.ru/ConnQuic"
	. "aoanima.ru/Logger"
	. "aoanima.ru/QErrors"
	badger "github.com/dgraph-io/badger/v4"
)

/*

	ошибкаПодключения := т.база.Подключиться(ПутьКФайламБазы + т.Имя + ".indexes")
	if ошибкаПодключения != nil {
		Ошибка(" ошибка подключения %+v \n", ошибкаПодключения)
		return ОшибкаБазы{
			Код:   ОшибкаПодключения,
			Текст: ошибкаПодключения.Error(),
		}
	}
	т.трз = Транзакция{т.база.NewTransaction(читать)}
	таблица.ПолучитьСигнатуруТаблицы()

	func (т Таблица  )Вставить(){

	}

		// ошибка := т.база.Транзакция(изменить, func(трз *Транзакция) ОшибкаБазы {
		// 	трз.Вставить(данные map[string][]byte, заменитьУникальныйКлюч bool)
		// })
		// или
		// ошибка := т.база.Транзакция(изменить, func(трз *Транзакция) ОшибкаБазы {

		// 	трз.Вставить(данные map[string][]byte, заменитьУникальныйКлюч bool)
		// })

*/

/*

ВСТАВИТЬ не открывет подклчючений к базе и транзакцию, это должно быть создано до вызова функции Всавить
Также до вызова функции должны быть получены индексы таблицы, и записаны в структуру в соответствующие поля
Если поля индексы пустые, то функция считает что индексов нет, и просто делает за  ись в базу данных
*/
// func (т *Таблица) Вставить (данные *map[string]interface{}, заменитьУникальныйКлюч bool) {

//   /*
//   1. прооверяем существует ли запись с ключём документа:
//     если ключ свободен то записывааем данные в базу но не закрываем транзакцию

//   2. Исппользуем
//   */

//		if т.индексы != nil {
//			индексы, ошибка := СоздатьЗначенияИндексов(данные, &т.индексы, ложь)
//			if ошибка != nil {
//				Ошибка("  %+v \n", ошибка)
//			}
//		}
//		if т.униикальныеИндексы != nil {
//			униикальныеИндексы, ошибка := СоздатьЗначенияИндексов(данные, &т.униикальныеИндексы, истина)
//			if ошибка != nil {
//				Ошибка("  %+v \n", ошибка)
//			}
//		}
//	}
type Таблица struct {
	Имя           string
	Дирректория   string
	ПервичныйКлюч ПервичныйКлюч // путь к значению в документе которое используется для генерации ключа документа, во всех документах однойтаблицы все первичные ключи должны .snm подобны : имяТаблицы.первичныйКлюч:значениеб

	// индексы            map[ПутьИндекса]struct{}
	// униикальныеИндексы map[ПутьИндекса]struct{}
	База              База
	Трз               Транзакция
	Индексы           ТаблицаИндексов
	УникальныеИндексы ТаблицаИндексов
	// базаИндексов       *БазаИднексов
}

func (таблица *Таблица) Подключиться(путь string) ОшибкаБазы {
	if путь == "" {
		путь = таблица.Дирректория + "/" + таблица.Имя
	}
	Инфо("Подключиться путь %+v \n", путь)
	база, err := badger.Open(badger.DefaultOptions(путь))
	if err != nil {
		Ошибка("  %+v \n", err)
		return ОшибкаБазы{
			Код:   ОшибкаПодключения,
			Текст: err.Error(),
		}
	}
	таблица.База = База{база}
	return ОшибкаБазы{
		Код:   0,
		Текст: "успешное подключение",
	}
}

/*


 */

/*
Созздаёт покдлючения к базе данныхи и базе индексов , запускает горутину которя возвращает канал, из которого она читает данные для записис в таблицу,
так же создаёт аналогичные каналы для индексов
*/
func (таблица *Таблица) АктивироватьТаблицу() ОшибкаБазы {

	ошибка := таблица.Подключиться("") // открываем соединение к базе данных
	if ошибка.Код != 0 {
		return ошибка
	}
	ошибка = таблица.ПроверитьСоздатьИндексы()
	if ошибка.Код != 0 {
		return ошибка
	}
	return ОшибкаБазы{
		Код:   Ок,
		Текст: "успешно",
	}
}

func (документ *Документ) СоздатьПервичныйКлюч(ПутьКЗначению ПервичныйКлюч) ПервичныйКлюч {
	Инфо("СоздатьПервичныйКлюч  %+v \n", ПутьКЗначению)
	данные := interface{}(документ.Данные)
	путьКЗначению := strings.Split(string(ПутьКЗначению), ".")
	Инфо("СоздатьПервичныйКлюч данные  %#T \n", данные)
	значениеКлюча := НайтиЗначениеВДанных(путьКЗначению, &данные)
	документ.ПервичныйКлюч = ПутьКЗначению + ":" + ПервичныйКлюч(значениеКлюча.(string))
	return документ.ПервичныйКлюч
}

// func (таблица *Таблица) ПоискВИндексе() {
// 	ошибкаБазы := таблица.Индексы.База.ТранзакцияЧтение(func(трз *Транзакция) ОшибкаБазы {
// 		итератор := трз.NewIterator(badger.DefaultIteratorOptions)
// 		defer итератор.Close()
// 		префиксИндекса := []byte(таблица.Имя + "." + ключ + ":" + значение)

// 		for итератор.Seek(префиксИндекса); итератор.ValidForPrefix(префиксИндекса); итератор.Next() {
// 			объект := итератор.Item()
// 			ключДанных, err := объект.ValueCopy(nil)
// 			найденныеКлючи[string(ключДанных)] = struct{}{}
// 			if err != nil {
// 				Ошибка(" %+v \n", err.Error())
// 			}
// 		}

// 		return ОшибкаБазы{
// 			Код: Ок,
// 		}
// 	})
// }

/*
Найти
[монстроузная функция, нужно рефакторить]
Пытается найти просто по ключу в базе, если ключ не совпадает с первичным ключём таблицы, то ищет в индексах, вначаде не в никальном, потом в уникальном, если ни там ни там нет ключа поиска, то ищет по всем документам итерируясь и просматривая значения по пути ключа.
ключ это тоже самое что индекс, или путь к искомому значению, может совпадать со строкой индекса
*/
func (таблица *Таблица) Найти(ключ string, значение string) (map[string]Документ, ОшибкаБазы) {
	var документы = map[string]Документ{}

	// если ключ поиска совпадает с первичным ключём таблицы, то ищем документ по первичному ключу
	if ключ == string(таблица.ПервичныйКлюч) {
		var документ Документ
		ошибкаБазы := таблица.База.ТранзакцияЧтение(func(трз *Транзакция) ОшибкаБазы {
			Инфо("  %+v \n", ПервичныйКлюч(таблица.Имя+"."+ключ+":"+значение))
			// var ошибкаБазы ОшибкаБазы
			результат, ошибкаБазы := трз.Получить(ПервичныйКлюч(таблица.Имя+"."+ключ+":"+значение), &документ)

			Инфо("  %+v \n", результат, документ)
			// документ = результат.(Данные)

			return ошибкаБазы
		})
		документы[ключ] = документ
		return документы, ошибкаБазы

	} else {
		// Иначе ищем в индексах
		естьИндексы := false
		естьУникальныеИндексы := false

		найденныеКлючи := make(map[string]struct{}) // ключи найденные в индексных таблицах

		var ожидание sync.WaitGroup

		if _, естьИндексы := таблица.Индексы.КартаИндексов[ПутьИндекса(ключ)]; естьИндексы {
			Инфо("  Индексы.КартаИндексов %+v \n", таблица.Индексы.КартаИндексов)
			// var значениеИндекса string
			var ошибкаБазы ОшибкаБазы
			ожидание.Add(1)
			go func() {
				ошибкаБазы = таблица.Индексы.База.ТранзакцияЧтение(func(трз *Транзакция) ОшибкаБазы {
					итератор := трз.NewIterator(badger.DefaultIteratorOptions)
					defer итератор.Close()
					префиксИндекса := []byte(таблица.Имя + "." + ключ + ":" + значение)

					for итератор.Seek(префиксИндекса); итератор.ValidForPrefix(префиксИндекса); итератор.Next() {
						объект := итератор.Item()
						ключДанных, err := объект.ValueCopy(nil)
						найденныеКлючи[string(ключДанных)] = struct{}{}
						if err != nil {
							Ошибка(" %+v \n", err.Error())
						}
					}
					return ОшибкаБазы{
						Код: Ок,
					}
				})
				Инфо(" результат поиска по  индексам %+v \n", ошибкаБазы)
				ожидание.Done()
			}()
		}
		// Проверили обычные индексы, , проверим уникальные
		/*	Документация:
			ключ поиска не совпадает с первичным ключём документов текущей таблицы
			Проверим совпадение с уникальныеИндексы
		*/
		if _, естьУникальныеИндексы := таблица.УникальныеИндексы.КартаИндексов[ПутьИндекса(ключ)]; естьУникальныеИндексы {
			// Инфо("  Индексы.КартаИндексов %+v \n", таблица.УникальныеИндексы.КартаИндексов)
			var ошибкаБазы ОшибкаБазы
			var ключИндекса string
			ожидание.Add(1)
			go func() {
				ошибкаБазы = таблица.УникальныеИндексы.База.ТранзакцияЧтение(func(трз *Транзакция) ОшибкаБазы {
					Инфо("  %+v \n", ПервичныйКлюч(таблица.Имя+"."+ключ+":"+значение))
					результат, ошибкаБазы := трз.Получить(ПервичныйКлюч(таблица.Имя+"."+ключ+":"+значение), &ключИндекса)
					найденныеКлючи[ключИндекса] = struct{}{}
					if ошибкаБазы.Код == Ок {
						Инфо(" результат %+v  значениеИндекса %+v \n", результат, ключИндекса)
						// значениеИндекса = результат.(string)
					}
					return ошибкаБазы
				})
				Инфо(" результат поиска по  индексам %+v \n", ошибкаБазы)
				ожидание.Done()
			}()
		}
		ожидание.Wait()

		if len(найденныеКлючи) > 0 {

			for ключИндекса := range найденныеКлючи {
				var документ Документ
				ошибкаПолучениДокумента := таблица.База.ТранзакцияЧтение(func(трз *Транзакция) ОшибкаБазы {
					_, ошибка := трз.Получить(ПервичныйКлюч(ключИндекса), &документ)
					документы[ключИндекса] = документ
					return ошибка
				})
				Инфо(" ошибкаПолучениДокумента %+v ключИндекса  %+v \n", ошибкаПолучениДокумента, ключИндекса, документы)
			}
		}

		Инфо(" документы %+v \n", документы)
		if len(документы) > 0 {
			return документы, ОшибкаБазы{
				Код:   Ок,
				Текст: "документы найдены",
			}
		} else {
			// если ключа нет в индекса, или  уникальных индексах, то будем искать по всему документы
			if !естьУникальныеИндексы || !естьИндексы {
				var данные map[string]Документ
				ошибкаПолучениДокумента := таблица.База.ТранзакцияЧтение(func(трзБаза *Транзакция) ОшибкаБазы {
					var ошибка ОшибкаБазы
					данные, ошибка = трзБаза.НайтиЗначение(ключ, значение)
					return ошибка
				})
				Инфо(" ошибкаПолучениДокумента %+v данные %+v \n", ошибкаПолучениДокумента, данные)
				if ошибкаПолучениДокумента.Код == Ок {
					return данные, ошибкаПолучениДокумента
				}
			}

			return nil, ОшибкаБазы{
				Текст: "Документ не найден",
				Код:   ОшибкаКлючНеНайден,
			}
		}

	}

	// return nil, ОшибкаБазы{
	// 	Текст: "Документ не найден",
	// 	Код:   ОшибкаКлючНеНайден,
	// }
}

func (таблица *Таблица) ВставитьДокумент(документ *Документ, перезаписатьПриСовпаденииКлюча bool) ОшибкаБазы {
	/*
		Проверить уникальный ключ
		Если его нет то вставить иначе , если стоит флаг перезаписать то перезаписываем
	*/
	var ошибкаБазы ОшибкаБазы
	if документ.КодДокумента == "" {
		документ.КодДокумента = документ.КодЗаписи()
	}

	if документ.ПервичныйКлюч == "" {
		документ.ПервичныйКлюч = документ.СоздатьПервичныйКлюч(таблица.ПервичныйКлюч)
	}

	if !перезаписатьПриСовпаденииКлюча { // если передано true то не проводи проверку уникального индекса
		// Рпроверим нет ли документа с таким же уникальным ключём
		ошибкаБазы := таблица.УникальныеИндексы.База.ТранзакцияЧтение(func(трз *Транзакция) ОшибкаБазы {
			Инфо(" Получить УникальныеИндексы %+v \n", ПервичныйКлюч(таблица.Имя)+"."+документ.ПервичныйКлюч)
			_, ошибкаБазы := трз.Получить(ПервичныйКлюч(таблица.Имя)+"."+документ.ПервичныйКлюч, nil)
			Инфо("  %+v \n", ошибкаБазы)
			// Проверим уникальный индекс, если ключ не найден значи записи нет, иначе дублирование ключа
			if ошибкаБазы.Код != ОшибкаКлючНеНайден {
				// Создаём новую запись и индексы

				return ошибкаБазы
			}
			return ошибкаБазы
		})
		if ошибкаБазы.Код != ОшибкаКлючНеНайден { // если ключ найден то вернём ошибку дубликат ключа
			Инфо("Ошибка не ОшибкаКлючНеНайден , значит ключ надйен, дубликат ключа  %+v \n", ошибкаБазы)
			return ОшибкаБазы{
				Текст: "Дубликат ключа: " + таблица.Имя + "." + string(документ.ПервичныйКлюч),
				Код:   ОшибкаДубликатКлюча,
			}
		}
	}

	Инфо(" ошибкаБазы %+v \n", ошибкаБазы)

	ошибкаБазы = таблица.База.ТранзакцияЗаписи(func(трз *Транзакция) ОшибкаБазы {
		if !перезаписатьПриСовпаденииКлюча {
			_, статус := трз.Получить(ПервичныйКлюч(таблица.Имя)+"."+документ.ПервичныйКлюч, nil)
			if статус.Код == Ок {
				// Запись уже существует
				Инфо("  %+v \n", "Дубликат ключа: "+таблица.Имя+"."+string(документ.ПервичныйКлюч))
				return ОшибкаБазы{
					Текст: "Дубликат ключа: " + таблица.Имя + "." + string(документ.ПервичныйКлюч),
					Код:   ОшибкаДубликатКлюча,
				}
			}
		}
		объектЗаписи, ошибка := Json(документ)
		if ошибка != nil {
			Ошибка(" %+v \n", ошибка)
			return ОшибкаБазы{
				Код:   ОшибкаПреобразованияДокумента,
				Текст: ошибка.Error()}
		}
		ошибкаБазы := трз.Записать(ПервичныйКлюч(таблица.Имя)+"."+документ.ПервичныйКлюч, объектЗаписи)
		return ошибкаБазы
	})
	Инфо("ошибкаБазы  %+v \n", ошибкаБазы)
	if ошибкаБазы.Код == Ок {
		ошибкаБазы = таблица.СоздатьИндексы(документ) //
	}

	return ошибкаБазы
}

// func (таблица *Таблица) Изменить(ключИзменяемогоДокумента string, значениеКлючаИзменяемогоДокумента string, ключОбновления string, значениеОбновления interface{}) ОшибкаБазы {

// 	таблица.Найти

// 	return таблица.ВставитьДокумент(документ, false)
// }
