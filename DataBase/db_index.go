package DataBase

import (
	"strings"

	badger "github.com/dgraph-io/badger/v4"

	. "aoanima.ru/ConnQuic"
	. "aoanima.ru/Logger"
)

// type ТаблицаИндексов interface {
// 	Подключиться(путь string) error
// 	// Создать(списокИндексов []string, списокУникальныхИндексов []string) error
// 	// Вставить(индекс map[string]ПервичныйКлюч) error // Доллжна принимать заменитьУникальныйИндекс если  стоит ложь то будет проверка на существованние уникального индекса, если он есть то возврат ошибки - дубликат первичного ключа, вставка не будет произведена
// 	// а если стоит истина, то будет просто запись, без проверки на существование, и данные будут записаны без ошибки.

// 	// Обновить()
// 	// Удалить()
// 	// Получить()
// 	Записать(chan Документ)
// }

type ПутьИндекса string
type ИмяТаблицы string

type ТаблицаИндексов struct {
	Версия      int
	Дирректория string // Путь хранения файлов базы данных /database/КаталогТаблицы
	// КаталогТаблицы string                                  // КаталогТаблицы - подкаталог в Дирректории где хранятся базы, для разделения индексов от других таблиц
	ИмяТаблицы    string                   // имя индексируемой таблицы
	ПутьИндексов  []ПутьИндекса            // Сам индекс , адре.город ... паспорт.серия.
	КартаИндексов map[ПутьИндекса]struct{} // тут  будет хранится в памяти, пока работает сервис, инфомрация о том, какие индексы созданы чтобы быстро создать ключ для поиска индекса в базе.
	Уникальный    bool                     // если  true то  индекс уникальный
	База          База
	Трз           Транзакция
	// КаналыДанных  КаналыДанных
}

// type КаналыДанных struct {
// 	Запись chan Документ
// 	Чтение chan Документ
// }

/*
 КартаИндексов map[ИмяТаблицы]map[Индекс]ПервичныйКлюч

*/

// type БазаИндексов struct {
// 	УниикальныеИндексы ТаблицаИндексов
// 	Индексы            ТаблицаИндексов
// }

func (таблица *Таблица) ПроверитьСоздатьИндексы() ОшибкаБазы {
	var ошибка ОшибкаБазы

	ошибка = таблица.Индексы.Подключиться("")

	if ошибка.Код != 0 {
		return ошибка
	}
	// Если  инексов нету то создает, если есть возвращает ошибку в поле Значение котрой будут картаиндексов в форрмате []byte
	_, ошибка = таблица.Индексы.ПроверитьИндексы()
	// В
	if ошибка.Код == ИндексыСуществуют {
		Инфо(" чтоо с ними делать ? индексы %+v \n", ошибка)
		// таблица.индексы.СравнитьИндексы(ошибка.Значение)
	}
	ошибка = таблица.УникальныеИндексы.Подключиться("")
	if ошибка.Код != 0 {
		return ошибка
	}
	_, ошибка = таблица.УникальныеИндексы.ПроверитьИндексы()

	if ошибка.Код == ИндексыСуществуют {
		Инфо(" УникальныеИндексы чтоо с ними делать ? индексы %+v \n", ошибка)

	}

	return ОшибкаБазы{
		Код:   Ок,
		Текст: "успешно",
	}
}

func (таблица *ТаблицаИндексов) СравнитьИндексы(индексыИзБД []byte) bool {
	индексыИзВходныхДанных, err := Json(таблица.КартаИндексов)
	if err != nil {
		Ошибка("  %+v \n", err.Error())
	}
	// Инфо("  %+s  %+s %+s \n", индексыИзБД, индексыИзВходныхДанных, string(индексыИзБД) == string(индексыИзВходныхДанных))
	return string(индексыИзБД) == string(индексыИзВходныхДанных)
	// }
}

/*
ПроверитьИндексы провеяет существует ли в базе таблица метаданные, если не существует то создаёт запись с ключём имяТбалицы.метаданные и значением КартаИНдексов
если Существуют то возвращем ошибку ИндексыСуществуют и в Поле Значение записываем сущетсующие индексы, в []byte
*/
func (таблица *ТаблицаИндексов) ПроверитьИндексы() (interface{}, ОшибкаБазы) {
	Инфо(" неообходимо проверить существует ли база с индексами, если да то получить структуру и вернуть  \n")

	ошибка := таблица.База.ТранзакцияЗаписи(func(трз *Транзакция) ОшибкаБазы {

		индексыТаблицы, err := трз.Get([]byte(таблица.ИмяТаблицы + "." + "метаданные"))
		// Таблица пуста, добавим данные об индексах, создадим таблицу метаданные
		if err == badger.ErrKeyNotFound {

			Инфо(" Документ   %+v.метаданные не найден %+v, индексы не существуют создаём новую запись \n", таблица.ИмяТаблицы, err.Error())

			ключ := []byte(таблица.ИмяТаблицы + "." + "метаданные")
			значение, err := Json(таблица.КартаИндексов)
			if err != nil {
				Ошибка("  %+v \n", err.Error())
			}
			err = трз.Set(ключ, значение)
			if err != nil {
				Ошибка("  %+v \n", err.Error())
				return ОшибкаБазы{
					Код:   ОшибкаЗаписи,
					Текст: err.Error(),
				}
			}
		} else {

			существующиеИндексы, err := индексыТаблицы.ValueCopy(nil)
			if err != nil {
				Ошибка("  %+v \n", err.Error())
			}
			if !таблица.СравнитьИндексы(существующиеИндексы) {
				Инфо(" Входящие индексы и индексы в металанных не равны... наверное перезапишем новыми входящими... но может сломать , старые данные могут не быть проиндексированны новыми индексами...  %+s != %+s \n", существующиеИндексы, таблица.КартаИндексов)
				// Будем решать проблемы по мере поступления, по идее между рестартами метаданные не должны менятся, можно записывать дополнительный ключ "вN" версия метаданных

			}
			Инфо("  %+s \n", существующиеИндексы)
			return ОшибкаБазы{
				Код:      ИндексыСуществуют,
				Текст:    "Индексы уже созданы, база не пуста",
				Значение: существующиеИндексы,
			}
		}
		return ОшибкаБазы{
			Код:   Ок,
			Текст: "успешно",
		}
	})

	return ошибка.Значение, ошибка

}

// Обёртка  вокруг Set , запписывает в базу
// func (табл *ТаблицаИндексов) Записать(Данные map[ПервичныйКлюч]Документ) ОшибкаБазы {

// 	// Это должно быть сгенерированно до отправки в Запись
// 	// if документ.КодДокумента == "" {
// 	// 	документ.КодЗаписи()
// 	// }
// 	ошибка := табл.база.ТранзакцияЗаписи(func(трз *Транзакция) ОшибкаБазы {
// 		for Ключ, документ := range Данные {

// 			Объект, err := Json(документ)
// 			if err != nil {
// 				Ошибка("  %+v \n", err)
// 				return ОшибкаБазы{
// 					Текст: err.Error(),
// 					Код:   ОшибкаПреобразованияДокумента,
// 				}
// 			}
// 			if err := трз.Set([]byte(Ключ), Объект); err != nil {
// 				return ОшибкаБазы{
// 					Текст: err.Error(),
// 					Код:   ОшибкаЗаписи,
// 				}
// 			}
// 		}

// 		// var КлючОбъекта string
// 		// // если записываем в таблицу уикальных ключей, то не добавляем КодДОкумента, иначе, чтобы создать не уникальный ключ то добавим КодДОкумента к ключу
// 		// if табл.Уникальный {

// 		// 	КлючОбъекта = string(табл.ПутьИндекса) + ":" + string(Данные.ПервичныйКлюч)
// 		// }
// 		// КлючОбъекта = string(табл.ПутьИндекса) + ":" + string(документ.ПервичныйКлюч) + "|" + string(документ.КодДокумента)

// 		return ОшибкаБазы{
// 			Код:   Ок,
// 			Текст: "успешно",
// 		}
// 	})
// 	return ошибка
// }

/*
Подлкючиться- подключается к базе данных по пути созданному из данных Индексиремой  таблицы  [Дирректория, Имя]
если передана не пустая строка в аргументе функции то подключаемс по указанному пути, иначе берём данные из данных таблицы
по  умолчанию

	Дирректория = "./database"

Имя = "index"
*/
func (т *ТаблицаИндексов) Подключиться(путь string) ОшибкаБазы {

	if путь == "" {
		if т.Дирректория == "" {
			т.Дирректория = "./database/index"
			if т.Уникальный {
				т.Дирректория = "./database/uniq_index"
			}
		}
		// if т.КаталогТаблицы == "" {
		// 	т.КаталогТаблицы = "index"
		// }
		// путь = т.Дирректория + "/" + т.КаталогТаблицы
		путь = т.Дирректория
	}
	база, err := badger.Open(badger.DefaultOptions(путь))
	if err != nil {
		Ошибка("  %+v \n", err)
		return ОшибкаБазы{
			Код:   ОшибкаПодключения,
			Текст: err.Error(),
		}
	}
	т.База = База{база}
	return ОшибкаБазы{
		Код:   Ок,
		Текст: "успешно подключились",
	}
}

func (т ТаблицаИндексов) Вставить(индекс map[string]ПервичныйКлюч) error {
	Инфо(" индексы  %+v \n", индекс)

	return nil
}

func (и ТаблицаИндексов) Обновить() {
	Инфо(" индексы  %+v \n", и)
}
func (и ТаблицаИндексов) Удалить() {
	Инфо(" индексы  %+v \n", и)

}

func (и ТаблицаИндексов) Получить() {
	Инфо(" индексы  %+v \n", и)

}

/*
СоздатьИНдексы
Генерирует ключи для индексов, и делает запись в соответствующие таблицы
*/
func (таблица *Таблица) СоздатьИндексы(документ *Документ) ОшибкаБазы {
	Инфо("  %+v \n", "СоздатьИндексы")
	индексы := таблица.Индексы.КартаИндексов
	уникальныеИндексы := таблица.УникальныеИндексы.КартаИндексов

	данныеДокумента := interface{}(документ.Данные)
	КартаИндексов := []string{}
	for индекс, _ := range индексы {
		ПутьКЗначению := strings.Split(string(индекс), ".")
		ЗначениеИндекса := НайтиЗначениеВДанных(ПутьКЗначению, &данныеДокумента)
		КлючИндекса := таблица.Индексы.СоздатьКлючИндекса(string(индекс), ЗначениеИндекса, string(документ.КодДокумента))
		КартаИндексов = append(КартаИндексов, КлючИндекса)

	}

	Инфо(" КартаИндексов %+v \n", КартаИндексов)

	ошибкаБазы := таблица.Индексы.База.ТранзакцияЗаписи(func(трз *Транзакция) ОшибкаБазы {
		for _, КлючИндекса := range КартаИндексов {
			ошибкаБазы := трз.Записать(ПервичныйКлюч(КлючИндекса), []byte(ПервичныйКлюч(таблица.Имя)+"."+документ.ПервичныйКлюч))

			Инфо("Записать Индексы %+v  %+v  %+v \n", ошибкаБазы, КлючИндекса, ПервичныйКлюч(таблица.Имя)+"."+документ.ПервичныйКлюч)

			if ошибкаБазы.Код != Ок {

				return ошибкаБазы
			}
		}
		return ОшибкаБазы{
			Код:   Ок,
			Текст: "успешная запись индексов",
		}
	})
	if ошибкаБазы.Код != Ок {
		return ошибкаБазы
	}
	/*************************Создание уникальных индексов, код дублируется... *************************************/
	КартаУникальныхИндексов := []string{}
	for индекс, _ := range уникальныеИндексы {
		ПутьКЗначению := strings.Split(string(индекс), ".")

		ЗначениеИндекса := НайтиЗначениеВДанных(ПутьКЗначению, &данныеДокумента)
		КлючИндекса := таблица.УникальныеИндексы.СоздатьКлючИндекса(string(индекс), ЗначениеИндекса, string(документ.КодДокумента))
		КартаУникальныхИндексов = append(КартаУникальныхИндексов, КлючИндекса)
	}

	Инфо(" КартаУникальныхИндексов %+v \n", КартаУникальныхИндексов)

	ошибкаБазы = таблица.УникальныеИндексы.База.ТранзакцияЗаписи(func(трз *Транзакция) ОшибкаБазы {
		for _, КлючИндекса := range КартаУникальныхИндексов {
			ошибкаБазы := трз.Записать(ПервичныйКлюч(КлючИндекса), []byte(ПервичныйКлюч(таблица.Имя)+"."+документ.ПервичныйКлюч))

			Инфо("  %+v  %+v  %+v \n", ошибкаБазы, ПервичныйКлюч(КлючИндекса), ПервичныйКлюч(таблица.Имя)+"."+документ.ПервичныйКлюч)

			if ошибкаБазы.Код != Ок {
				return ошибкаБазы
			}
		}
		return ОшибкаБазы{
			Код:   Ок,
			Текст: "успешная запись уникальных индексов",
		}
	})

	return ошибкаБазы
}

func НайтиЗначениеВДанных(ПутьКЗначению []string, данные *interface{}) interface{} {

	копияОбъекта := *данные
	// Инфо("копияОбъекта  %#T \n", копияОбъекта, копияОбъекта)
	for _, ключ := range ПутьКЗначению {
		Инфо("ключ  %+v \n", ключ)
		// Документация: провверим что следующее значение имеет один из типов мап, и приведём к нужному типу, чтобы рантайм мог отличить string от  interface
		/* если  не map[string]interface{} и  не map[string]string то   */
		switch копияОбъекта.(type) {
		case map[string]interface{}:
			// Инфо(" тип %+v \n", копияОбъекта)
			if значение, ok := копияОбъекта.(map[string]interface{})[ключ]; ok {
				// if значение, ok := копияОбъекта[ключ]; ok {
				копияОбъекта = значение
			} else {
				Ошибка("нет такого ключа %+v индекс %+v", ключ, ПутьКЗначению)
				копияОбъекта = nil
			}
		case map[string]string:
			// Инфо(" тип %+v \n", копияОбъекта)
			// if значение, ok := копияОбъекта[ключ]; ok {
			if значение, ok := копияОбъекта.(map[string]string)[ключ]; ok {
				копияОбъекта = значение
			} else {
				Ошибка("нет такого ключа %+v индекс %+v", ключ, ПутьКЗначению)
				копияОбъекта = nil
			}
		case Данные:
			// Инфо(" тип %+v \n", копияОбъекта)
			if значение, ok := копияОбъекта.(Данные)[ключ]; ok {
				// if значение, ok := копияОбъекта[ключ]; ok {
				Инфо(" тип %+v \n", значение)
				копияОбъекта = значение
			} else {
				Ошибка("нет такого ключа %+v индекс %+v", ключ, ПутьКЗначению)
				копияОбъекта = nil
			}
		default:
			Инфо(" тип %#T \n", копияОбъекта)
			Инфо(" посследнее значение копияОбъекта  ПутьКЗначению %+v  \n копияОбъекта %+v \n", ПутьКЗначению, копияОбъекта)
		}
	}
	return копияОбъекта
}

func (таблица *ТаблицаИндексов) СоздатьКлючИндекса(ключИндекса string, значение interface{}, КодДокумента string) string {
	var значениеИндекса string
	if значение != nil {

		switch значение.(type) {
		case []byte:
			значениеИндекса = таблица.ИмяТаблицы + "." + ключИндекса + ":" + string(значение.([]byte))
			// ЗначенияИндекса[ключИндекса+":"+string(значение.([]byte))] = struct{}{}
		case string:
			значениеИндекса = таблица.ИмяТаблицы + "." + ключИндекса + ":" + значение.(string)
			// ЗначенияИндекса[ключИндекса+":"+значение.(string)] =  struct{}{}
		default:
			строка, err := Json(значение)
			if err != nil {
				Ошибка("  %+v \n", err)
			}
			значениеИндекса = таблица.ИмяТаблицы + "." + ключИндекса + ":" + string(строка)
			// ЗначенияИндекса[ключИндекса+":"+string(строка)] = struct{}{}

		}
		// если  стоит флаг униклаьныеИНдексы = ложь значит создаём индекс который будет не уникальным, добавляя в конец "|"+КодЗаписи
		if !таблица.Уникальный {
			значениеИндекса = значениеИндекса + "|" + КодДокумента
		}
	}
	return значениеИндекса
}

// соедин\ет индекс и значение для указанного индекс, проходит по пути указаному в индексе получает значение, и соединяет в одно строку

// type ТаблицаИндексов interface {
// 	Создать(списокИндексов []string, списокУникальныхИндексов []string)
// 	ПолучитьИиндексы()
// 	ПолучитьУниклаьныеИндексы()
// }

// func СоздатьЗначенияИндексов(объект *interface{}, индекс *map[string]struct{}, униклаьныйИндекс bool) (map[string]struct{}, error) {

// 	копияОбъекта := *объект
// 	КодЗаписи := копияОбъекта.(map[string]interface{})["КодЗаписи"]
// 	ЗначенияИндекса := make(map[string]struct{})

// 	for ключИндекса, _ := range *индекс {

// 		ПутьКЗначению := strings.Split(ключИндекса, ".")

// 		for _, ключ := range ПутьКЗначению {
// 			// Документация: провверим что следующее значение имеет один из типов мап, и приведём к нужному типу, чтобы рантайм мог отличить string от  interface
// 			/* если  не map[string]interface{} и  не map[string]string то   */
// 			switch копияОбъекта.(type) {
// 			case map[string]interface{}:
// 				if значение, ok := копияОбъекта.(map[string]interface{})[ключ]; ok {
// 					копияОбъекта = значение
// 				} else {
// 					// return nil, errors.New(fmt.Sprintf("нет такого ключа %+v индекс %+v", ключ, индекс))
// 					Ошибка("нет такого ключа %+v индекс %+v", ключ, индекс)
// 					копияОбъекта = nil
// 				}
// 			case map[string]string:
// 				if значение, ok := копияОбъекта.(map[string]string)[ключ]; ok {
// 					копияОбъекта = значение
// 				} else {
// 					// return nil, errors.New(fmt.Sprintf("нет такого ключа %+v индекс %+v", ключ, индекс))
// 					Ошибка("нет такого ключа %+v индекс %+v", ключ, индекс)
// 					копияОбъекта = nil
// 				}
// 			default:
// 				Инфо(" посследнее значение копияОбъекта  %+v \n", копияОбъекта)
// 			}

// 			/* 	if значение, ok := копияОбъекта.(map[string]interface{})[ключ]; ok {
// 				копияОбъекта = значение
// 			} else {
// 				// return nil, errors.New(fmt.Sprintf("нет такого ключа %+v индекс %+v", ключ, индекс))
// 				Ошибка("нет такого ключа %+v индекс %+v", ключ, индекс)
// 				копияОбъекта = nil
// 			} */
// 		}
// 		// копияОбъекта - содердит искомое значение
// 		if копияОбъекта != nil {
// 			var значениеИндекса string
// 			switch копияОбъекта.(type) {
// 			case []byte:
// 				значениеИндекса = ключИндекса + ":" + string(копияОбъекта.([]byte))
// 				// ЗначенияИндекса[ключИндекса+":"+string(копияОбъекта.([]byte))] = struct{}{}
// 			case string:
// 				значениеИндекса = ключИндекса + ":" + копияОбъекта.(string)
// 				// ЗначенияИндекса[ключИндекса+":"+копияОбъекта.(string)] =  struct{}{}
// 			default:
// 				строка, err := Json(копияОбъекта)
// 				if err != nil {
// 					Ошибка("  %+v \n", err)
// 				}
// 				значениеИндекса = ключИндекса + ":" + string(строка)
// 				// ЗначенияИндекса[ключИндекса+":"+string(строка)] = struct{}{}

// 			}
// 			// если  стоит флаг униклаьныеИНдексы = ложь значит создаём индекс который будет не уникальным, добавляя в конец "|"+КодЗаписи
// 			if !униклаьныйИндекс {
// 				значениеИндекса = значениеИндекса + "|" + КодЗаписи.(string)
// 			}
// 			ЗначенияИндекса[значениеИндекса] = struct{}{}
// 		}
// 	}
// 	return ЗначенияИндекса, nil
// }

type Индекс map[string]struct{}

// func (т Таблица) СоздатьОписаниеИндексов(списокИндексов []string) (Индекс, ОшибкаБазы) {

// 	индексы := make(map[string]struct{}, len(списокИндексов))
// 	for _, индекс := range списокИндексов {
// 		индексы[индекс] = struct{}{}
// 	}
// 	индексыJson, err := Json(индексы)
// 	if err != nil {
// 		Ошибка("  %+v \n", err.Error())
// 	}

// 	т.Подключиться(ПутьКФайламБазы + т.Имя)
// 	ошибка := т.база.Транзакция(изменить, func(трз *Транзакция) ОшибкаБазы {

// 		return трз.Записать(т.ПутьИндекса+".индексы", индексыJson)
// 	})

// 	return индексы, ошибка
// }

/*
Запправшивает данные из таблицы индексов, и дессериализует в структуру таблица.индексы
*/
// func (т Таблица) ПолучитьИндексы() ОшибкаБазы {
// 	ключПоиска := т.Имя + ".индексы"

// 	ошибка := т.трз.Получить(ключПоиска, &т.индексы)
// 	if ошибка.Код != Ок {
// 		return ошибка
// 	}
// 	// т.индексы = индексы.(map[string]struct{})
// 	return ОшибкаБазы{Код: Ок}
// }

// func (т Таблица) ПолучитьУникальныеИндексы() ОшибкаБазы {
// 	ключПоиска := т.Имя + ".индексы.уникальные"
// 	ошибка := т.трз.Получить(ключПоиска, &т.уникальныеИндексы)
// 	if ошибка.Код != Ок {
// 		return ошибка
// 	}
// 	// т.униикальныеИндексы = индексы.(map[string]struct{})
// 	return ОшибкаБазы{Код: Ок}
// }
