package DataBase

import (
	. "aoanima.ru/Logger"
) // соедин\ет индекс и значение для указанного индекс, проходит по пути указаному в индексе получает значение, и соединяет в одно строку

// type ТаблицаДанных interface {
// 	Создать(имяТаблицы string, списокИндексов []string, заменитьУникальныйКлючч []string) error
// 	Вставить(данные map[string][]byte, заменитьУникальныйКлючч bool) // Доллжна принимать заменитьУникальныйИндекс если  стоит ложь то будет проверка на существованние уникального индекса, если он есть то возврат ошибки - дубликат первичного ключа, вставка не будет произведена
// 	// а если стоит истина, то будет просто запись, без проверки на существование, и данные будут записаны без ошибки.

//		Обновить()
//		Удалить()
//		Получить()
//		ИмяТаблицы()
//		Индексы()
//		// Заменить() // если есть запись с уникальным индексом , не требуеться, тк. есть флаг замены уникального индекса в функции Вставить
//	}
// type Таблица struct {
// 	Имя               string
// 	Дирректория       string
// 	индексы           ТаблицаИндексов
// 	уникальныеИндексы ТаблицаИндексов
// 	// индексы            map[ПутьИндекса]struct{}
// 	// униикальныеИндексы map[ПутьИндекса]struct{}
// 	база База
// 	трз  Транзакция
// 	// базаИндексов       *БазаИднексов
// }

// func (т Таблица) Создать(имяТаблицы string, списокИндексов []string, списокУникальныхИндексов []string) {
// 	т.Имя = "таблица"
// 	т.СоздатьСигнатуруТаблицы(имяТаблицы, списокИндексов, списокУникальныхИндексов)
// }

// ИмяТаблицы  если пустая строка то возвращает имя, иначе устанавливает и возвращает
// func (т Таблица) ИмяТаблицы(имя string) string {
// 	if имя == "" {
// 		т.Имя = имя
// 		return т.Имя
// 	} else {
// 		return т.Имя
// 	}
// }

/*
Созздаём записи в системных таблицах,
записываем карту индексов для таблицы

при вставке данных в таблицу, получаем списки индексов, по этим индексам находим значения в документе, создаём ключи индекса, и доавдяем вместе с документом индексированные значения в базу индексов
*/
// func (т Таблица) СоздатьСигнатуруТаблицы(имяТаблицы string, списокИндексов []string, списокУникальныхИндексов []string) ОшибкаБазы {
// 	var ошибка ОшибкаБазы
// 	т.индексы, ошибка = т.СоздатьОписаниеИндексов(списокИндексов)
// 	if ошибка.Код != Ок {
// 		Ошибка("  %+v \n", ошибка)
// 		return ошибка
// 	}
// 	т.униикальныеИндексы, ошибка = т.СоздатьОписаниеИндексов(списокУникальныхИндексов)
// 	if ошибка.Код != Ок {
// 		Ошибка("  %+v \n", ошибка)
// 		return ошибка
// 	}
// 	return ОшибкаБазы{Код: Ок}
// }

// func (т Таблица) ПолучитьСигнатуруТаблицы() ОшибкаБазы {
// 	ошибкаПодключения := т.Подключиться(ПутьКФайламБазы + т.Имя + ".indexes")
// 	if ошибкаПодключения != nil {
// 		Ошибка(" ошибка подключения %+v \n", ошибкаПодключения)
// 		return ОшибкаБазы{
// 			Код:   ОшибкаПодключения,
// 			Текст: ошибкаПодключения.Error(),
// 		}
// 	}
// 	т.трз = Транзакция{т.база.NewTransaction(читать)}
// 	т.ПолучитьИиндексы()
// 	т.ПолучитьУникальныеИндексы()
// 	т.трз.Discard()
// 	return ОшибкаБазы{Код: Ок}
// }

// func (т *Таблица) ВставитьДокумент_(таблица string, ключ string, объект map[string]interface{}, уникальныйИндекс []string, индексы []string) ОшибкаБазы {

// 	// КоддЗаписи := КодЗаписи(таблица + ":" + ключ)

// 	// объект["КодЗаписи"] = КодДокумента.КодЗаписи()
// 	var УникальныеИндексы map[string]string
// 	if уникальныйИндекс != nil {
// 		УникальныеИндексы = make(map[string]string)
// 		УникальныеИндексы, _ = СоздатьКлючиИндекса(объект, &уникальныйИндекс)
// 	}

// 	ошибка := т.база.Транзакция(изменить, func(трз *Транзакция) ОшибкаБазы {
// 		старт := time.Now()
// 		//провряет существование уникального ключа и исключения дубля первиного ключа для документа
// 		ok, ОшибкаДубльКлюча := трз.УникальныйКлюч(таблица, ключ, УникальныеИндексы)
// 		времяРаботы := time.Since(старт)
// 		Инфо("Время поиска ключа и индекса  %+v \n", времяРаботы)

// 		if !ok {
// 			Ошибка(" ОшибкаДубльКлюча %+v \n", ОшибкаДубльКлюча)
// 			return ОшибкаДубльКлюча
// 		}

// 		Объект, err := Json(объект)
// 		if err != nil {
// 			Ошибка("  %+v \n", err)
// 		}

// 		КлючОбъекта := таблица + ":" + ключ

// 		if err := трз.Set([]byte(КлючОбъекта), Объект); err != nil {
// 			return ОшибкаБазы{
// 				Текст: err.Error(),
// 				Код:   ОшибкаЗаписи,
// 			}
// 		}

// 		//  Получается при каждой вставке  будем проверять таблицу индексов, есть, нету и обновлять... накладно, нужно вынести проверку в отдельную функцию
// 		неУникальныеИндексы, _ := СоздатьКлючиИндекса(объект, &индексы)
// 		ошибкаЗаписиИндекса := трз.ВставитьИндекс(таблица, КлючОбъекта, УникальныеИндексы, неУникальныеИндексы, объект["КодЗаписи"].(string))
// 		Инфо(" ошибкаЗаписиИндекса %+v \n", ошибкаЗаписиИндекса)
// 		return ошибкаЗаписиИндекса
// 	})
// 	if ошибка.Код != 0 {
// 		Ошибка("  %+v \n", ошибка)
// 	}
// 	return ошибка
// }

// Функция Вставить принимает ключ и значение, которые нужно записать в базу данных db
// Она также принимает имя таблицы table и уникальное значение unique, которые используются для создания уникального индекса в базе данных idx
// Она возвращает ошибку, если такая есть
// func Вставить(db, idx *badger.DB, key, value, table, unique []byte) error {
//   // Создаем транзакцию для записи данных в db
//   txn := db.NewTransaction(true)
//   defer txn.Discard()

//   // Проверяем, есть ли уже данные с таким же ключом в db
//   _, err := txn.Get(key)
//   if err == nil {
//     // Если есть, то возвращаем ошибку
//     return fmt.Errorf("данные с ключом %s уже существуют в базе данных", key)
//   } else if err != badger.ErrKeyNotFound {
//     // Если произошла другая ошибка, то возвращаем ее
//     return err
//   }

//   // Записываем данные в db
//   err = txn.Set(key, value)
//   if err != nil {
//     // Если произошла ошибка при записи, то возвращаем ее
//     return err
//   }

//   // Создаем транзакцию для записи данных в idx
//   txn2 := idx.NewTransaction(true)
//   defer txn2.Discard()

//   // Создаем ключ для уникального индекса в виде "имяТаблица.уникальноеЗначение"
//   indexKey := append(table, '.')
//   indexKey = append(indexKey, unique...)

//   // Проверяем, есть ли уже данные с таким же ключом в idx
//   _, err = txn2.Get(indexKey)
//   if err == nil {
//     // Если есть, то отменяем транзакцию в db и возвращаем ошибку
//     txn.Discard()
//     return fmt.Errorf("данные с уникальным значением %s уже существуют в базе данных", unique)
//   } else if err != badger.ErrKeyNotFound {
//     // Если произошла другая ошибка, то отменяем транзакцию в db и возвращаем ее
//     txn.Discard()
//     return err
//   }

//   // Записываем данные в idx
//   err = txn2.Set(indexKey, key)
//   if err != nil {
//     // Если произошла ошибка при записи, то отменяем транзакцию в db и возвращаем ее
//     txn.Discard()
//     return err
//   }

//   // Фиксируем обе транзакции
//   err = txn.Commit()
//   if err != nil {
//     // Если произошла ошибка при фиксации, то отменяем транзакцию в idx и возвращаем ее
//     txn2.Discard()
//     return err
//   }
//   err = txn2.Commit()
//   if err != nil {
//     // Если произошла ошибка при фиксации, то возвращаем ее
//     return err
//   }

//   // Возвращаем nil, если все прошло успешно
//   return nil
// }

// Обёртка вокруг Get меттоа badngerdb , втоорым аргументом передаём указатель на тип структуры в который будет Дессериализованы данные из базы
// func (трз *Транзакция) Получить(ключПоиска string, результат interface{}) ОшибкаБазы {
// 	найденоеЗначение, err := трз.Get([]byte(ключПоиска))
// 	if err != badger.ErrKeyNotFound {
// 		Ошибка(" не нашли ничего по ключу %+v err  %+v \n", ключПоиска, err.Error())
// 		return ОшибкаБазы{
// 			Текст: "не нашли ничего по ключу " + ключПоиска + " \n " + err.Error(),
// 			Код:   ОшибкаКлючНеНайден,
// 		}
// 	} else if err != nil {
// 		Ошибка(" ошибка отличная от  badger.ErrKeyNotFound %+v err  %+v \n", ключПоиска, err.Error())
// 		return ОшибкаБазы{
// 			Текст: "не нашли ничего по ключу " + ключПоиска + " \n " + err.Error(),
// 			Код:   ОшибкаПодключения,
// 		}
// 	}
// 	копияЗначения, err := найденоеЗначение.ValueCopy(nil)
// 	if err != nil {
// 		Ошибка("  %+v \n", err)

// 	}
// 	// var результат interface{}
// 	err = ИзJson(копияЗначения, &результат)
// 	if err != nil {
// 		Ошибка("  %+v \n", err)
// 	}
// 	return ОшибкаБазы{Код: Ок}
// }

// func СозданиеТаблицыПример() {
// 	таблица := new(Таблица)
// 	таблица.Создать("таблица", []string{"ключ", "ключ2"}, []string{"уникальныйИндекс", "уникальныйИндекс1"})
// }

// Функция Удалить принимает уникальное значение unique, по которому нужно найти и удалить документ из базы данных db
// Она также принимает имя таблицы table, которое используется для поиска уникального индекса в базе данных idx
// Она возвращает ошибку, если такая есть
// func Удалить(db, idx *badger.DB, table, unique []byte) error {
// 	// Создаем транзакцию для чтения данных из idx
// 	txn := idx.NewTransaction(false)
// 	defer txn.Discard()

// 	// Создаем ключ для уникального индекса в виде "имяТаблица.уникальноеЗначение"
// 	indexKey := append(table, '.')
// 	indexKey = append(indexKey, unique...)

// 	// Ищем ключ документа по уникальному значению индекса в idx
// 	item, err := txn.Get(indexKey)
// 	if err != nil {
// 		// Если произошла ошибка, то возвращаем ее
// 		return err
// 	}

// 	// Получаем значение ключа документа из item
// 	var docKey []byte
// 	err = item.Value(func(val []byte) error {
// 		docKey = append([]byte{}, val...)
// 		return nil
// 	})
// 	if err != nil {
// 		// Если произошла ошибка, то возвращаем ее
// 		return err
// 	}

// 	// Создаем транзакцию для удаления данных из db
// 	txn2 := db.NewTransaction(true)
// 	defer txn2.Discard()

// 	// Удаляем документ из db по ключу docKey
// 	err = txn2.Delete(docKey)
// 	if err != nil {
// 		// Если произошла ошибка, то возвращаем ее
// 		return err
// 	}

// 	// Создаем транзакцию для удаления данных из idx
// 	txn3 := idx.NewTransaction(true)
// 	defer txn3.Discard()

// 	// Удаляем индекс из idx по ключу indexKey
// 	err = txn3.Delete(indexKey)
// 	if err != nil {
// 		// Если произошла ошибка, то возвращаем ее
// 		return err
// 	}

// 	// Фиксируем обе транзакции
// 	err = txn2.Commit()
// 	if err != nil {
// 		// Если произошла ошибка при фиксации, то отменяем транзакцию в idx и возвращаем ее
// 		txn3.Discard()
// 		return err
// 	}
// 	err = txn3.Commit()
// 	if err != nil {
// 		// Если произошла ошибка при фиксации, то возвращаем ее
// 		return err
// 	}

// 	// Возвращаем nil, если все прошло успешно
// 	return nil
// }
