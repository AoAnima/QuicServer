package main

import (
	"fmt"
	"net/url"
	"strconv"
	"strings"

	. "aoanima.ru/ConnQuic"
	. "aoanima.ru/DGApi"
	. "aoanima.ru/Logger"
	. "aoanima.ru/QErrors"
	"github.com/quic-go/quic-go"
)

/*
Очередь обработчиков
Каждый запрос от клиента может быть обработан одним и более количеством микросервисов, для того чтобы правильно отправлять запрос в сервисы нужно описать последовательность обработки запроса Сервиссами, и указать какой HTNL шаблон рендерить, или куда сделать редирект например после автоизации или регистрации)

КРоме того необходимо учитывать права доступа и роли пользователя, чтобы один и тот же маршрут по разному обрабатывался в заивсимости от роли польтзователя и его прав доступа.

дествие  | сервис | маршрут | роль | права | шаблон |  статусОтвета | редирект | ассинхронно |

	| Рендер | /формаРеситрации | ["гость"] | "формаРегистрации" | Ок | /личныйКабинет | нет

регистрация  | Авторизация | /формаРеситрации (url же не меняется) | ["гость"] |   |  |
*/

/*
Обработчик может указываться если значеине в поле действие называетя иначе чем функция которая должна обработать запрос
например действие: регистрация
Обработчик : сохранитьПользователя

таким образом разные действия могут обрабатыватся одним и тем же обработчиком или несколькитми обработчиками

например

дейсвтие: 	оформитьЗаказ
обработчики: сохранитьЗаказ

	отправитьПисьмоКлиенту
	отправитьУведомлениеПродавцу

маршрут: /формаЗаказа - по идее маршрут может быть любой. И обрабатывается если нет дейсвтия
шаблон: /формаЗаказа

По факту нужно проектировать запросы так что если есть только маршрут
exotiki.ru/каталог/цветы - то тут обработчик должен определяться из маршрута, типа шаблон каталог, со списком из категории цветы.

Обращаемся к обработчику отвечающему за базу с товарами
обработчик : получитьТовары - получаем товары из категории "цветы"
шаблон:      каталогТоваров

# Если нужно в зависимости от результата обработки выводить разный шаблон, то можно использовать структуру СОобщение

	map[int]Шаблон - int = Код из QErrors
	Шаблон структура, в которой опиывается при каком коде ответа работы сервиса , какой шаблон рендерить
*/

/*
Добавляет данные об обработчике в БД, особенно важно права доступа
Маршрут может быть пустой если есть действие, и наоборот, если есть маршрут а обработчика нету. не страшно, обработчик будет вычисляться из маршрута.
если есть Действие то оно в приоритете

	// рабочий запрос
	// {
	// 	node(func: eq(<маршрут>, "рабочий/настройки"))  {
	// 	  <доступ>{	//
	// 	  <роль> @filter(eq(<код>, 2)) {
	// 		uid
	// 		<код>
	// 		<имя_роли>
	// 	  }

	// 	}
	//   }
	//   }
*/
func ДобавитьОбработчик(поток quic.Stream, сообщение Сообщение) {

	ответ := сообщение.Ответ[Сервис]
	ответ.Сервис = Сервис
	ответ.ЗапросОбработан = true

	_, статусМаршрут := ЗначениеФормы("маршрут", сообщение.Запрос.Форма)
	_, статусДейсвтия := ЗначениеФормы("имяКоманды", сообщение.Запрос.Форма)

	if статусДейсвтия.Код != Ок && статусМаршрут.Код != Ок {
		ответ.СтатусОтвета = СтатусСервиса{
			Код:   Прочее,
			Текст: "действие и маршрут не заданы, должно быть установлено одно или оба поля",
		}
		сообщение.Ответ[Сервис] = ответ
		ОтправитьСообщение(поток, сообщение)
	}

	очередьОбработчиков, ассинхронныеОбработчики, праваДоступа := СобратьДанныеОбработчика(сообщение.Запрос.Форма)

	Инфо("очередьОбработчиков  %+v ассинхронныеОбработчики %+v \n", очередьОбработчиков, ассинхронныеОбработчики)

	// Шаблон можно указывать как путь рабочийСтол/обработчики - где рабочийСтол это основной слой контента, а обработчики это шаблон который вставляется внутрь предидущего слоя.

	новыйОбработчик := НовыйОбработчикМаршрута(сообщение.Запрос.Форма)

	// шаблон, статусШаблон := ЗначениеФормы("шаблон", сообщение.Запрос.Форма)
	// if статусШаблон.Код != Ок {
	// 	Ошибка(" статус получения описания  %+v \n", статусШаблон)
	// }
	// ш := Шаблон{
	// 	Тип:        "Шаблон",
	// 	Код:        new(int),
	// 	ИмяШаблона: шаблон,
	// }
	// *ш.Код = Ок

	// новыйОбработчик := &ОбработчикМаршрута{
	// 	Тип:      "ОбработчикМаршрута",
	// 	Маршрут:  маршрут,
	// 	Комманда: комманда,
	// 	Обработчики: []Обработчики{
	// 		{
	// 			ОчередьОбработчиков:             очередьОбработчиков,
	// 			АссинхроннаяОчередьОбработчиков: ассинхронныеОбработчики,
	// 			ИмяШаблона:                      шаблон,
	// 			// Роль:                            праваДоступа.H,
	// 		},
	// 	},
	// }
	// type ОбработчикМаршрута struct {
	// 	UID         string                `json:"uid,omitempty"`
	// 	Маршрут     string                `json:"маршрут,omitempty"`
	// 	Комманда    string                `json:"комманда,omitempty"`
	// 	Обработчики []ОчередьОбработчиков `json:"обработчики,omitempty"`
	// 	Описание    string                `json:"описание,omitempty"`
	// 	Тип         string                `json:"dgraph.type,omitempty"`
	// }
	// type ОчередьОбработчиков struct {
	// 	ОчередьОбработчиков             []string `json:"очередь_обработчиков,omitempty"`
	// 	АссинхроннаяОчередьОбработчиков []string `json:"ассинхронная_очередь_обоработчиков,omitempty"`
	// 	Логин                           []string `json:"пользователи,omitempty"`
	// 	Роль                            Роль     `json:"роль"`
	// 	Права                           []Права  `json:"права"`
	// 	ИмяШаблона                      string   `json:"имя_шаблона,omitempty"`
	// 	Тип                             string   `json:"dgraph.type,omitempty"`
	// }

	обработчикБин, статус := Json(новыйОбработчик)
	if статус != nil {
		Ошибка(" статус %+v обработчикБин %+v \n", статус, обработчикБин)
	}
	Инфо(" новыйОбработчик %+v  обработчикБин %+s \n", новыйОбработчик, обработчикБин)

	запрос, данныеПодстановки := собратьЗапросВставкиОбработчика(новыйОбработчик.Маршрут, праваДоступа)
	Инфо(" %+v %+v \n", запрос, данныеПодстановки)

	данные := ДанныеЗапроса{
		// Запрос: запрос,
		Мутация: []Мутация{
			{
				// Условие: "@if(eq(len(count_roles),0))",
				Мутация: обработчикБин,
			},
		},
		Данные: данныеПодстановки,
	}

	Инфо("данные для вставки   %+v \n", данные)

	результатИзменения, статусБазы := База.Изменить(данные)
	if статусБазы.Код != Ок {
		Ошибка(" статус %+v \n данные %+v \n", статусБазы, данные)
	}
	var данныеОтвета interface{}
	ИзJson(результатИзменения, &данныеОтвета)

	Инфо("Исходные данные %+v \n ; данныеОтвета  %+s \n", данные, данныеОтвета)

	ответ.СтатусОтвета = СтатусСервиса{
		Код:   статусБазы.Код,
		Текст: статусБазы.Текст,
	}

	/******Получим данные нового узла, с UID для вставки в html */
	данные = ДанныеЗапроса{
		Запрос: `query <Обработчики>($handler : string, $path : string, $action : string) {					
							<Обработчик>(func: has(<обработчик>)){	
								uid			
								<маршрут>
								<действие>
								<обработчик>
								<доступ>{
									<пользователи>
									<права>
									<роль>
									uid
									dgraph.type
								}
								<описание>
								<шаблонизатор> {
									uid
									<имя_шаблона>
									<код>
									dgraph.type
								}
								<ассинхронно>
								dgraph.type
								expand(_all_)
							}	
			 			} `,

		Данные: map[string]string{
			"$handler": "создатьОбработчик",
			"$path":    "/редакторОбработчиков",
			"$action":  "создатьОбработчик",
		},
	}

	результатИзменения, статусБазы = База.Получить(данные)
	if статусБазы.Код != Ок {
		Ошибка(" статус %+v \n", статусБазы)
	}
	var данныеНовогоУзла КонфигурацияОбработчика
	ИзJson(результатИзменения, &данныеНовогоУзла)
	Инфо(" данныеНовогоУзла %+s \n", данныеНовогоУзла)

	ответ.Данные = map[string]interface{}{
		"НовыйОбработчик": данныеНовогоУзла,
	}
	ответ.ИмяШаблона = "новыйОбработчик"
	сообщение.Ответ[Сервис] = ответ
	ОтправитьСообщение(поток, сообщение)
}

func ЗапросВставкиОбработчика(новыОбработчик *ОбработчикМаршрута) (string, map[string]string) {
	/*
		Нужно пройти по каждому обработчику. получить uid ролей и прав,
		ПОлучить uid сервисов, обработчиков, шаблонов
		и вставить полченные uid  всоответсвующие места ....



	*/
	return "", nil
}

/*
ДОК:
Суть запроса для вставки с проверкой на уникальность, запросить данные только того поля уникальность которого проверяется,
например как тут
нужно проверить маршрут+код.роли
код.роли находиться - Данные.Доступ.Роль.Код
Поэтому первым запросом мы получем записи с маршуртом , и фильтруем роли по нужным значениям, и возвращаем только данные  объекта Роль.
в условии проверки перед вставкой работает только одна фукнция len она вохвращает тупо количество символов в ответе первого запроса, поэтому если мы будем в первом запросе возвращать uid родительского объекта Роли, то мы не сможем определить есть роли или нет.
*/
func собратьЗапросВставкиОбработчика(маршрут string, роли []ПраваДоступа) (string, map[string]string) {
	var фильтрРолей string
	var сигнатураРолей string
	данныеПодстановки := map[string]string{}

	Инфо(" %+v \n", `нужно переделать запрос, чтобы вначале заправшивались UID ролей и прав доступа, потом уже эти uid вставлялись в соотвествующие поля, 
ТОесть получаем UID обрабочтиков  и сервисов из спраовчника ? 
Значит нужно вначале завести справочник сервисов и обработчиков ? Это по идее можно делать частично автоматически из SynQuick когда какойто сервис регистрируется. можно отправлять даныне в бд.

Получаем UID ролей и прав доступа`)

	// nodes as var(func: eq(<маршрут>,"настройки/рабочий")) {
	// 	<доступ>{
	// 	   <роль> @filter(eq(<код.роли>, 6) OR eq(<код.роли>, 5)){
	// 		   uid
	// 		   <код.роли>
	// 		   <имя.роли>
	// 		 }
	//    }
	//  }

	for i, ролиДоступа := range роли {
		фильтрРолей += fmt.Sprintf("eq(<код.роли>, $role%d)", i+1)
		сигнатураРолей += fmt.Sprintf("$role%d: string", i+1)
		if i < len(роли)-1 {
			фильтрРолей += " or "
			сигнатураРолей += ", "
		}
		данныеПодстановки["$role"+strconv.Itoa(i+1)] = strconv.Itoa(ролиДоступа.Роль.Код)
	}
	// eq(<код.роли>, 11) OR eq(<код.роли>, 12)
	запрос := fmt.Sprintf(`query <СохранитьОбработчик>($path : string, %s ) {
				var(func: eq(<маршрут>, $path)) {  
				<доступ>{     				
					count_roles as <роль> @filter(%s){
						uid
						<код.роли>
						<имя.роли>
					}    	
				} 				
			}				
			}`, сигнатураРолей, фильтрРолей)

	данныеПодстановки["$path"] = маршрут

	return запрос, данныеПодстановки
}

//	func generateRoleParams(roles []string) string {
//		var params string
//		for i, _ := range roles {
//			params += fmt.Sprintf("$role%d: string", i+1)
//			if i < len(roles)-1 {
//				params += ", "
//			}
//		}
//		return params
//	}
func НовыйОбработчикМаршрута(форма map[string][]string) *ОбработчикМаршрута {
	маршрут, _ := ЗначениеФормы("маршрут", форма)
	комманда, _ := ЗначениеФормы("имяКоманды", форма)
	данные := СгрупироватьДанныеФОрмы(форма)

	шаблон, статусШаблон := ЗначениеФормы("шаблон", форма)
	if статусШаблон.Код != Ок {
		Ошибка(" статус получения описания  %+v \n", статусШаблон)
	}
	ш := Шаблон{
		Тип:        "Шаблон",
		Код:        new(int),
		ИмяШаблона: шаблон,
	}
	*ш.Код = Ок

	очередьОбработчиков := []Обработчик{}
	очередьАссинхронныхОбработчиков := []Обработчик{}
	праваДоступа := []ПраваДоступа{}

	/*ДОК:
	ИДЕЯ:

	Прийдётся отправлять два запроса в транзакции, первый запрос на получение uid ролей. прав. и обработчиков, второй на вставку в базу плана обработчки маршрута но уже с полученными uid.

	Можно попробовать собирать запросы прям тут вместе с данными.

	*/

	for _, группа := range данные {

		// Если в мапе  есть ключ "роль" то собираем в структуру с правами доступа
		if роль, естьРоль := группа["роль"]; естьРоль {
			кодРоли, ошибка := strconv.Atoi(роль[0])
			if ошибка != nil {
				Ошибка(" ошибка преобразования роли в число  %+v \n", ошибка)
			}

			права := make([]Права, len(группа["права_доступа"]))
			for и, кодПрав := range группа["права_доступа"] {
				КодПрав, ошибка := strconv.Atoi(кодПрав)
				if ошибка != nil {
					Ошибка(" ошибка преобразования роли в число  %+v \n", ошибка)
				}
				права[и] = Права{
					Тип: "Права",
					Код: КодПрав,
				}
			}

			праваДоступа = append(праваДоступа, ПраваДоступа{
				Тип: "ПраваДоступа",
				Роль: Роль{
					Тип: "Роль",
					Код: кодРоли,
				},
				Права: права,
			})

		}
		// Если в мапе  есть ключ "очередь" то собираем в структуру с последовательными очередями
		if очередь, естьОчередь := группа["очередь"]; естьОчередь {
			номерОчереди, ошибка := strconv.Atoi(очередь[0])

			if ошибка != nil {
				Ошибка(" ошибка преобразования очереди в число  %+v \n", ошибка)
			}

			имяСервиса, естьИмяСервиса := группа["сервис"]
			if !естьИмяСервиса {
				Ошибка(" не нашли имя сервиса %+v \n", имяСервиса)
			}
			имяОбработчика, естьимяОбработчика := группа["обработчик"]
			if !естьимяОбработчика {
				Ошибка(" не нашли имя  Обработчика %+v \n", естьимяОбработчика)
			}
			о := Обработчик{
				Очередь:        new(int),
				ИмяСервиса:     имяСервиса[0],
				ИмяОбработчика: имяОбработчика[0],
			}
			*о.Очередь = номерОчереди

			очередьОбработчиков = append(очередьОбработчиков, о)

		}
		// собираем асинхронные обработчики
		if _, естьАссинхронно := группа["ассинхронно"]; естьАссинхронно {
			имяСервиса, естьИмяСервиса := группа["сервис"]
			if !естьИмяСервиса {
				Ошибка(" не нашли имя сервиса %+v \n", имяСервиса)
				continue
			}
			имяОбработчика, естьимяОбработчика := группа["обработчик"]
			if !естьимяОбработчика {
				Ошибка(" не нашли имя  Обработчика %+v \n", естьимяОбработчика)
				continue
			}
			очередьАссинхронныхОбработчиков = append(очередьАссинхронныхОбработчиков, Обработчик{
				ИмяСервиса:     имяСервиса[0],
				ИмяОбработчика: имяОбработчика[0],
			})

		}
	}

	// если передано несоклько ролей с одинаковыми обработчиками, то всё равно создаём две группы
	новыйОбработчик := ОбработчикМаршрута{
		Тип:         "ОбработчикМаршрута",
		Маршрут:     маршрут,
		Комманда:    комманда,
		Обработчики: []Обработчики{},
	}

	// Обработчики{
	// 	ОчередьОбработчиков:             очередьОбработчиков,
	// 	АссинхроннаяОчередьОбработчиков: очередьАссинхронныхОбработчиков,
	// 	ИмяШаблона:                      шаблон,
	// 	Роль: права.Роль.Код,
	// 	Права: права.Права,

	// },

	// Если передано несколько ролей то создам отдельную группу для каждой роли с одинаковыми обработчиками
	for _, права := range праваДоступа {
		новыйОбработчик.Обработчики = append(новыйОбработчик.Обработчики, Обработчики{
			ОчередьОбработчиков:             очередьОбработчиков,
			АссинхроннаяОчередьОбработчиков: очередьАссинхронныхОбработчиков,
			ИмяШаблона:                      шаблон,
			Роль:                            права.Роль.Код,
			Права:                           права.Права,
		})
	}

	return &новыйОбработчик
}

func СгрупироватьДанныеФОрмы(форма map[string][]string) map[string]map[string][]string {
	данные := make(map[string]map[string][]string)
	for ключ, значение := range форма {

		индексКвадратныхСкобок := strings.Index(ключ, "[")
		if индексКвадратныхСкобок == -1 {
			continue
		}

		имяПоля := ключ[:индексКвадратныхСкобок]               // получаем то что до квадратных скобок
		идПоля := ключ[индексКвадратныхСкобок+1 : len(ключ)-1] // получем то что внутри квадртаных скобк

		if _, ok := данные[идПоля]; !ok {
			данные[идПоля] = make(map[string][]string)
		}

		данные[идПоля][имяПоля] = значение
	}
	return данные
}

func СобратьДанныеОбработчика(форма map[string][]string) ([]Обработчик, []Обработчик, []ПраваДоступа) {

	очередьОбработчиков := []Обработчик{}
	очередьАссинхронныхОбработчиков := []Обработчик{}
	праваДоступа := []ПраваДоступа{}

	данные := СгрупироватьДанныеФОрмы(форма)

	for _, группа := range данные {
		if роль, естьРоль := группа["роль"]; естьРоль {

			кодРоли, ошибка := strconv.Atoi(роль[0])
			if ошибка != nil {
				Ошибка(" ошибка преобразования роли в число  %+v \n", ошибка)
			}

			права := make([]Права, len(группа["права_доступа"]))
			for и, кодПрав := range группа["права_доступа"] {

				КодПрав, ошибка := strconv.Atoi(кодПрав)
				if ошибка != nil {
					Ошибка(" ошибка преобразования роли в число  %+v \n", ошибка)
				}
				права[и] = Права{
					Тип:     "Права",
					Код:     КодПрав,
					ИмяПрав: "права_" + роль[0] + "_" + кодПрав,
				}
			}

			праваДоступа = append(праваДоступа, ПраваДоступа{
				Тип: "ПраваДоступа",
				Роль: Роль{
					Тип:     "Роль",
					Код:     кодРоли,
					ИмяРоли: "роль_" + роль[0],
				},
				Права: права,
			})
		}

		if очередь, естьОчередь := группа["очередь"]; естьОчередь {
			номерОчереди, ошибка := strconv.Atoi(очередь[0])

			if ошибка != nil {
				Ошибка(" ошибка преобразования очереди в число  %+v \n", ошибка)
			}

			имяСервиса, естьИмяСервиса := группа["сервис"]
			if !естьИмяСервиса {
				Ошибка(" не нашли имя сервиса %+v \n", имяСервиса)
			}
			имяОбработчика, естьимяОбработчика := группа["обработчик"]
			if !естьимяОбработчика {
				Ошибка(" не нашли имя  Обработчика %+v \n", естьимяОбработчика)
			}
			о := Обработчик{
				Очередь:        new(int),
				ИмяСервиса:     имяСервиса[0],
				ИмяОбработчика: имяОбработчика[0],
			}
			*о.Очередь = номерОчереди

			очередьОбработчиков = append(очередьОбработчиков, о)

		}
		if _, естьАссинхронно := группа["ассинхронно"]; естьАссинхронно {
			имяСервиса, естьИмяСервиса := группа["сервис"]
			if !естьИмяСервиса {
				Ошибка(" не нашли имя сервиса %+v \n", имяСервиса)
				continue
			}
			имяОбработчика, естьимяОбработчика := группа["обработчик"]
			if !естьимяОбработчика {
				Ошибка(" не нашли имя  Обработчика %+v \n", естьимяОбработчика)
				continue
			}
			очередьАссинхронныхОбработчиков = append(очередьАссинхронныхОбработчиков, Обработчик{
				ИмяСервиса:     имяСервиса[0],
				ИмяОбработчика: имяОбработчика[0],
			})

		}
	}

	Инфо(" данные%+v \n", данные)

	return очередьОбработчиков, очередьАссинхронныхОбработчиков, праваДоступа
}

func ИзменитьОбработчик(поток quic.Stream, сообщение Сообщение) {

}
func УдалитьОбработчик(поток quic.Stream, сообщение Сообщение) {

	ответ := сообщение.Ответ[Сервис]
	ответ.Сервис = Сервис
	ответ.ЗапросОбработан = true

	ид_обработчика, статус := ЗначениеФормы("ид_обработчика", сообщение.Запрос.Форма)
	if статус.Код != Ок {
		Ошибка("  %+v \n", статус)
	}

	данные := ДанныеЗапроса{
		Запрос: `query <УдалитьОбработчик>($uid : string) {
							<УдаляемыеУзлы>(func: uid($uid)) {				
								<обработчик_ид> as uid
								<доступ> {
									<доступ_ид> as uid
								}
								<шаблонизатор> {
									<шаблонизатор_ид> as uid
								}
							}
			 			} `,
		Мутация: []Мутация{
			{
				Удалить: []byte(`[
					{"uid": "uid(доступ_ид)"},
					{"uid": "uid(обработчик_ид)"},
					{"uid": "uid(шаблонизатор_ид)"}
					]`),
			},
		},
		Данные: map[string]string{
			"$uid": ид_обработчика,
		},
	}
	результатИзменения, статусБазы := База.Изменить(данные)
	if статусБазы.Код != Ок {
		Ошибка(" статус %+v \n данные %+v \n", статусБазы, данные)
	}
	var данныеОтвета interface{}
	ИзJson(результатИзменения, &данныеОтвета)
	Инфо("Исходные данные %+v \n ответ %+s \n", данные, данныеОтвета)

	ответ.СтатусОтвета = СтатусСервиса{
		Код:   статусБазы.Код,
		Текст: статусБазы.Текст,
	}
	ответ.Данные = map[string]interface{}{

		"удалённыйОбработчик": данныеОтвета,
	}
	ответ.ИмяШаблона = "всплывающееСообщение"

	сообщение.Ответ[Сервис] = ответ
	ОтправитьСообщение(поток, сообщение)

}
func СоздатьОчередьОбработчиков(поток quic.Stream, сообщение Сообщение) {

}

func ИзменитьОчередьОбработчиков(поток quic.Stream, сообщение Сообщение) {

}
func ДобавитьМаршрут(поток quic.Stream, сообщение Сообщение) {

}
func ИзменитьМаршрут(поток quic.Stream, сообщение Сообщение) {

}
func УдалитьМаршрут(поток quic.Stream, сообщение Сообщение) {

}

func ДобавитьРоль(поток quic.Stream, сообщение Сообщение) {
	ответ := сообщение.Ответ[Сервис]
	ответ.Сервис = Сервис
	ответ.ЗапросОбработан = true

	Инфо(" ДобавитьРоль%+v \n", сообщение.Запрос.Форма)
	данныеНовойРоли := сообщение.Запрос.Форма

	if len(данныеНовойРоли["имя.роли"]) < 1 || данныеНовойРоли["имя.роли"][0] == "" {
		ответ.СтатусОтвета = СтатусСервиса{
			Код:   ПустоеПолеФормы,
			Текст: "Имя роли не может быть пустым",
		}
		сообщение.Ответ[Сервис] = ответ
		Ошибка(" ответ %+v \n", ответ)

		ОтправитьСообщение(поток, сообщение)
		return
	}
	if len(данныеНовойРоли["код.роли"]) < 1 {

		ответ.СтатусОтвета = СтатусСервиса{
			Код:   ПустоеПолеФормы,
			Текст: "Код роли не может быть пустым",
		}
		сообщение.Ответ[Сервис] = ответ
		Ошибка(" ответ %+v \n", ответ)
		ОтправитьСообщение(поток, сообщение)
		return
	}
	код, ошибка := strconv.Atoi(данныеНовойРоли["код.роли"][0])
	if ошибка != nil {
		Ошибка(" Ошибка конвертации кода в число  %+v \n", ошибка.Error())
	}

	новаяРоль := Роль{
		Тип:     "Роль",
		ИмяРоли: данныеНовойРоли["имя.роли"][0],
		Код:     код,
	}
	// роли := []Роль{
	// 	{
	// 		Тип:     "Роль",
	// 		ИмяРоли: "Админ",
	// 		Код:     1,
	// 	},
	// 	{
	// 		Тип:     "Роль",
	// 		ИмяРоли: "Модератор",
	// 		Код:     2,
	// 	},
	// 	{
	// 		Тип:     "Роль",
	// 		ИмяРоли: "Продавец",
	// 		Код:     3,
	// 	},
	// 	{
	// 		Тип:     "Роль",
	// 		ИмяРоли: "Модератор продавца",
	// 		Код:     4,
	// 	},
	// 	{
	// 		Тип:     "Роль",
	// 		ИмяРоли: "Администратор продавца",
	// 		Код:     5,
	// 	},
	// 	{
	// 		Тип:     "Роль",
	// 		ИмяРоли: "Клиент",
	// 		Код:     6,
	// 	},
	// 	{
	// 		Тип:     "Роль",
	// 		ИмяРоли: "Гость",
	// 		Код:     7,
	// 	},
	// }
	// запрос := fmt.Sprintf(`query <СохранитьОбработчик>($path : string, %s ) {
	// 	var(func: eq(<маршрут>, $path)) {
	// 	<доступ>{
	// 		count_roles as <роль> @filter(%s){
	// 			uid
	// 			<код.роли>
	// 			<имя.роли>
	// 		}
	// 	}
	// }
	// }`, сигнатураРолей, фильтрРолей)

	// запрос :=

	ролиБинар, статус := Json([]Роль{новаяРоль})
	if статус != nil {
		Ошибка(" статус %+v ролиБинар %+v \n", статус, ролиБинар)
	}
	Инфо("новаяРоль %+v \n", новаяРоль)

	данные := ДанныеЗапроса{
		Запрос: `query <ПроверитьНаличиеРоли>($code: string){
					var(func: eq(<код.роли>, $code)) {			
						uid_role as uid			
					}
					<существующиеРоли>(func: uid(uid_role)) {						
						<код.роли>
						<имя.роли>
						uid
					}     
					
		}`,
		Мутация: []Мутация{
			{
				Условие: "@if(eq(len(uid_role), 0))",
				Мутация: ролиБинар,
			},
		},
		Данные: map[string]string{
			"$code": strconv.Itoa(новаяРоль.Код),
		},
	}
	// Инфо(" %+v \n", данные)

	результатИзменения, статусБазы := База.Изменить(данные)
	if статусБазы.Код != Ок {
		Ошибка(" статус %+v \n данные %+v \n", статусБазы, данные)
	}
	Инфо(" результатИзменения %+s\n", результатИзменения)

	Ответ := map[string][]map[string]interface{}{}

	ИзJson(результатИзменения, &Ответ)
	if существующиеРоли, ок := Ответ["существующиеРоли"]; ок {
		if len(существующиеРоли) > 0 {
			ответ.СтатусОтвета = СтатусСервиса{
				Код:   ОшибкаДубликатИндекса,
				Текст: fmt.Sprintf("Роль уже существует %s", существующиеРоли),
			}
			ответ.Данные["существующиеРоли"] = Ответ
		} else {
			ответ.СтатусОтвета = СтатусСервиса{
				Код:   Ок,
				Текст: "Данные записаны, но это не точно, получим только что записанные данные.",
			}
			// if ответ.СтатусОтвета.Код == Ок {
			ответБазы, статусБазы := ПолучитьРольИзБазы(новаяРоль)
			if статусБазы.Код != Ок {
				Ошибка(" ОписаниеОшибки %+v \n", статусБазы.Текст)
			} else {

				рольИзБазы := map[string][]Роль{}
				ошибка := ИзJson(ответБазы, &рольИзБазы)
				if ошибка != nil {
					Ошибка(" ОписаниеОшибки  %+v \n", ошибка)
				}
				ответ.Данные = map[string]interface{}{
					"НоваяРоль": рольИзБазы,
				}

			}
			// }
		}
	}

	Инфо("Оработали втсавку новой роли %+v \n", ответ)

	сообщение.Ответ[Сервис] = ответ
	ОтправитьСообщение(поток, сообщение)
}
func ИзменитьРоль(поток quic.Stream, сообщение Сообщение) {
	данныеИзмененияРоли := сообщение.Запрос.Форма
	Инфо("данныеИзмененияРоли %+v \n", данныеИзмененияРоли)
	if кодРоли, ок := данныеИзмененияРоли["удалить"]; ок {
		if len(кодРоли) > 0 {
			УдалитьРоль(поток, сообщение)
			return
		}
	}
	ОтправитьСообщение(поток, сообщение)
}

func УдалитьРоль(поток quic.Stream, сообщение Сообщение) {
	Инфо("УдалитьРоль - перед удалением роли нужно проверитть что удаляемая роль не используется в каких либо документах \n")

	ответ := сообщение.Ответ[Сервис]
	ответ.Сервис = Сервис
	ответ.ЗапросОбработан = true

	Инфо(" ДобавитьРоль%+v \n", сообщение.Запрос.Форма)
	данныеИзмененияРоли := сообщение.Запрос.Форма

	// if len(данныеИзмененияРоли["имя.роли"]) < 1 || данныеИзмененияРоли["имя.роли"][0] == "" {
	// 	ответ.СтатусОтвета = СтатусСервиса{
	// 		Код:   ПустоеПолеФормы,
	// 		Текст: "Имя роли не может быть пустым",
	// 	}
	// 	сообщение.Ответ[Сервис] = ответ
	// 	Ошибка(" ответ %+v \n", ответ)

	// 	ОтправитьСообщение(поток, сообщение)
	// 	return
	// }
	if len(данныеИзмененияРоли["код.роли"]) < 1 {

		ответ.СтатусОтвета = СтатусСервиса{
			Код:   ПустоеПолеФормы,
			Текст: "Код роли не может быть пустым",
		}
		сообщение.Ответ[Сервис] = ответ
		Ошибка(" ответ %+v данныеИзмененияРоли %+v \n", ответ, данныеИзмененияРоли)
		ОтправитьСообщение(поток, сообщение)
		return
	}
	код, ошибка := strconv.Atoi(данныеИзмененияРоли["код.роли"][0])
	if ошибка != nil {
		Ошибка(" Ошибка конвертации кода в число  %+v \n", ошибка.Error())
	}

	удаляемаяРоль := Роль{
		Тип: "Роль",
		Код: код,
	}
	// удаляемаяРольБинар, статус := Json([]Роль{удаляемаяРоль})
	// if статус != nil {
	// 	Ошибка(" статус %+v удаляемаяРольБинар %+v \n", статус, удаляемаяРольБинар)
	// }
	// Инфо("удаляемаяРольБинар %+s\n", удаляемаяРольБинар)

	данные := ДанныеЗапроса{
		Запрос: `query <ПроверитьНаличиеРоли>($code: string){
					uid_role as var(func: eq(<код.роли>, $code)) {			
						 uid			
					}
					<удаляемаяРоль>(func: uid(uid_role)) {						
						<код.роли>
						<имя.роли>
						uid
					}
		}`,
		Мутация: []Мутация{
			{
				Удалить: []byte(`[{"uid": "uid(uid_role)"}]`),
			},
		},
		Данные: map[string]string{
			"$code": strconv.Itoa(удаляемаяРоль.Код),
		},
	}
	результатУдаления, статусБазы := База.Изменить(данные)
	if статусБазы.Код != Ок {
		Ошибка(" статус %+v \n данные %+v \n", статусБазы, данные)
		ответ.СтатусОтвета = СтатусСервиса{
			Код:   статусБазы.Код,
			Текст: fmt.Sprintf("Ошибка даления данных %s , код роли: %d ", статусБазы.Текст, удаляемаяРоль.Код),
		}
		сообщение.Ответ[Сервис] = ответ
		ОтправитьСообщение(поток, сообщение)
		return
	}

	/*если результатИзменения {"удаляемаяРоль":[]} пусто то удалять нечего не найдено значение  */
	Инфо(" %+v результатИзменения %+s \n", данные, результатУдаления)

	// проверим что удалили роль

	удаляемыеДанные := map[string][]map[string]interface{}{}
	ошибкаJson := ИзJson(результатУдаления, &удаляемыеДанные)
	if ошибкаJson != nil {
		Ошибка(" ОписаниеОшибки  %+v \n", ошибка.Error())
	}

	if удалённаяРоль, ок := удаляемыеДанные["удаляемаяРоль"]; ок {
		if len(удалённаяРоль) > 0 {
			Инфо("удалённаяРоль %+v \n", удалённаяРоль)

			контрольУдалённнойРоли, статусБазы := ПолучитьРольИзБазы(удаляемаяРоль)
			if статусБазы.Код != Ок {
				Инфо("статусБазы %+v контрольУдалённнойРоли %+v \n", статусБазы, контрольУдалённнойРоли)
			}
			Инфо("контрольУдалённнойРоли %+s \n", контрольУдалённнойРоли)
			контрольныеДанные := map[string][]map[string]interface{}{}

			ошибкаJson = ИзJson(контрольУдалённнойРоли, &контрольныеДанные)
			if ошибкаJson != nil {
				Ошибка(" ОписаниеОшибки  %+v \n", ошибка.Error())
			}
			if роль, ок := контрольныеДанные["роль"]; ок {
				if len(роль) > 0 {
					Ошибка("Данные не были удалены ,Не должно быть ничего: роль %+v \n", роль)
					ответ.Данные = map[string]interface{}{
						"удалённаяРоль": удалённаяРоль,
					}
					ответ.СтатусОтвета = СтатусСервиса{
						Код:   ОшибкаУдаленияДнных,
						Текст: "Не удалось удалить роль " + string(контрольУдалённнойРоли),
					}
				} else {
					Инфо("Данные были удалены: роль %+v \n", роль)
					ответ.Данные = map[string]interface{}{
						"удалённаяРоль": удалённаяРоль,
					}
					ответ.СтатусОтвета = СтатусСервиса{
						Код:   Ок,
						Текст: "Роль успешно удалена " + string(результатУдаления),
					}
				}
			}
		} else {
			ответ.Данные = map[string]interface{}{
				"удалённаяРоль": удалённаяРоль,
			}
			ответ.СтатусОтвета = СтатусСервиса{
				Код:   Ок,
				Текст: "Удалять нечего: " + string(результатУдаления),
			}
		}
	} else {
		ответ.Данные = map[string]interface{}{
			"удалённаяРоль": удалённаяРоль,
		}
		ответ.СтатусОтвета = СтатусСервиса{
			Код:   Прочее,
			Текст: "Запрос не вернул данных: " + string(результатУдаления),
		}
	}
	Инфо("Оработали удаление  роли %+v \n", ответ)
	// ответ.Данные = удаляемаяРоль
	сообщение.Ответ[Сервис] = ответ
	ОтправитьСообщение(поток, сообщение)

}

// Получает все Роли из базы данных
func получитьСписокРолей(поток quic.Stream, сообщение Сообщение) {
	ответ := сообщение.Ответ[Сервис]
	ответ.Сервис = Сервис
	ответ.ЗапросОбработан = true

	Инфо(" ДобавитьРоль%+v \n", сообщение.Запрос.Форма)

	данные := ДанныеЗапроса{
		Запрос: `<роли>(func: type(<Роль>)) {			
						uid			
						<код.роли>
						<имя.роли>
						dgraph.type
					}					
		`,
	}
	// Инфо(" %+v \n", данные)
	// запрос, ошибка := Json(данные)
	// if ошибка != nil {
	// 	Ошибка(" ошибка конвертации   %+v \n", ошибка)
	// }

	данныеРолей, статусОтвета := База.Получить(данные)
	if статусОтвета.Код != Ок {
		Ошибка(" ОписаниеОшибки %+v \n", статусОтвета)

	}
	ответ.СтатусОтвета = СтатусСервиса{
		Код:   Ок,
		Текст: "Список ролей получен",
	}
	ответ.Данные = map[string]interface{}{
		"СписокРолей": данныеРолей,
	}

	сообщение.Ответ[Сервис] = ответ
	ОтправитьСообщение(поток, сообщение)
}

func получитьСписокРолейИПрав(поток quic.Stream, сообщение Сообщение) {
	ответ := сообщение.Ответ[Сервис]
	ответ.Сервис = Сервис
	ответ.ЗапросОбработан = true

	Инфо(" ДобавитьРоль%+v \n", сообщение.Запрос.Форма)

	данные := ДанныеЗапроса{
		Запрос: `<роли>(func: type(<Роль>))   {	
						uid			
						<код.роли>
						<имя.роли>
						dgraph.type
					}	
				<права>(func: type(<Права>)) {			
						uid			
						<код.прав>
						<имя.прав>
						dgraph.type
					}					
		`,
	}
	данныеРолей, статусОтвета := База.Получить(данные)
	if статусОтвета.Код != Ок {
		Ошибка(" ОписаниеОшибки %+v \n", статусОтвета)

	}
	ответ.СтатусОтвета = СтатусСервиса{
		Код:   Ок,
		Текст: "Список ролей получен",
	}
	ПраваДоступа := struct {
		Роли  []Роль  `json:"роли"`
		Права []Права `json:"права"`
	}{}

	ИзJson(данныеРолей, &ПраваДоступа)

	ответ.Данные = map[string]interface{}{
		"Роли":  ПраваДоступа.Роли,
		"Права": ПраваДоступа.Права,
	}

	сообщение.Ответ[Сервис] = ответ
	ОтправитьСообщение(поток, сообщение)
}

func получитьСписокПрав(поток quic.Stream, сообщение Сообщение) {
	ответ := сообщение.Ответ[Сервис]
	ответ.Сервис = Сервис
	ответ.ЗапросОбработан = true

	Инфо(" ДобавитьРоль%+v \n", сообщение.Запрос.Форма)

	данные := ДанныеЗапроса{
		Запрос: `<права>(func: type(<Права>)) {			
						uid			
						<код.прав>
						<имя.прав>
						dgraph.type
					}					
		`,
	}
	данныеРолей, статусОтвета := База.Получить(данные)
	if статусОтвета.Код != Ок {
		Ошибка(" ОписаниеОшибки %+v \n", статусОтвета)

	}
	ответ.СтатусОтвета = СтатусСервиса{
		Код:   Ок,
		Текст: "Список ролей получен",
	}
	ответ.Данные = map[string]interface{}{
		"СписокРолей": данныеРолей,
	}

	сообщение.Ответ[Сервис] = ответ
	ОтправитьСообщение(поток, сообщение)
}

func ПолучитьРольИзБазы(роль Роль) ([]byte, СтатусБазы) {
	данные := ДанныеЗапроса{
		Запрос: `query <ПроверитьНаличиеРоли>($code: string){
					<роль>(func: eq(<код.роли>, $code)) {			
						uid			
						<код.роли>
						<имя.роли>
					}					
		}`,

		Данные: map[string]string{
			"$code": strconv.Itoa(роль.Код),
		},
	}
	// Инфо(" %+v \n", данные)

	return База.Получить(данные)
}

func ДобавитьПрава(поток quic.Stream, сообщение Сообщение) {
	ответ := сообщение.Ответ[Сервис]
	ответ.Сервис = Сервис
	ответ.ЗапросОбработан = true

	Инфо(" ДобавитьРоль%+v \n", сообщение.Запрос.Форма)
	данныеНовыхПрав := сообщение.Запрос.Форма
	имяПрав, ок := данныеНовыхПрав["имя.прав"]

	if ок && (len(имяПрав) < 1 || имяПрав[0] == "") {
		ответ.СтатусОтвета = СтатусСервиса{
			Код:   ПустоеПолеФормы,
			Текст: "Имя прав не может быть пустым",
		}
		сообщение.Ответ[Сервис] = ответ
		Ошибка(" ответ %+v \n", ответ)

		ОтправитьСообщение(поток, сообщение)
		return
	}
	кодПрав, ок := данныеНовыхПрав["код.прав"]
	if ок && len(кодПрав) < 1 {

		ответ.СтатусОтвета = СтатусСервиса{
			Код:   ПустоеПолеФормы,
			Текст: "Код прав не может быть пустым",
		}
		сообщение.Ответ[Сервис] = ответ
		Ошибка(" ответ %+v \n", ответ)
		ОтправитьСообщение(поток, сообщение)
		return
	}
	код, ошибка := strconv.Atoi(кодПрав[0])
	if ошибка != nil {
		Ошибка(" Ошибка конвертации кода в число  %+v \n", ошибка.Error())
	}

	новыеПрава := Права{
		Тип:     "Права",
		ИмяПрав: имяПрав[0],
		Код:     код,
	}

	праваБинар, статус := Json([]Права{новыеПрава})
	if статус != nil {
		Ошибка(" статус %+v праваБинар %+v \n", статус, праваБинар)
	}
	Инфо("новаяРоль %+v \n", праваБинар)

	данные := ДанныеЗапроса{
		Запрос: `query <ПроверитьНаличиеРоли>($code: string){
					var(func: eq(<код.прав>, $code)) {			
						uid_access as uid			
					}
					<существующиеПрава>(func: uid(uid_access)) {						
						<код.прав>
						<имя.прав>
						uid
					}     
					
		}`,
		Мутация: []Мутация{
			{
				Условие: "@if(eq(len(uid_access), 0))",
				Мутация: праваБинар,
			},
		},
		Данные: map[string]string{
			"$code": strconv.Itoa(новыеПрава.Код),
		},
	}

	результатИзменения, статусБазы := База.Изменить(данные)
	if статусБазы.Код != Ок {
		Ошибка(" статус %+v \n данные %+v \n", статусБазы, данные)
	}
	Инфо(" результатИзменения %+s\n", результатИзменения)

	Ответ := map[string][]map[string]interface{}{}

	ИзJson(результатИзменения, &Ответ)
	if существующиеРоли, ок := Ответ["существующиеПрава"]; ок {
		if len(существующиеРоли) > 0 {
			ответ.СтатусОтвета = СтатусСервиса{
				Код:   ОшибкаДубликатИндекса,
				Текст: fmt.Sprintf("Права уже существует %s", существующиеРоли),
			}
			ответ.Данные = map[string]interface{}{
				"существующиеПрава": Ответ["существующиеПрава"],
			}
		} else {
			ответ.СтатусОтвета = СтатусСервиса{
				Код:   Ок,
				Текст: "Данные записаны, но это не точно, получим только что записанные данные.",
			}
			// if ответ.СтатусОтвета.Код == Ок {
			ответБазы, статусБазы := ПолучитьПраваИзБазы(новыеПрава)
			if статусБазы.Код != Ок {
				Ошибка(" ОписаниеОшибки %+v \n", статусБазы.Текст)
			} else {

				праваИзБазы := map[string][]Права{}
				ошибка := ИзJson(ответБазы, &праваИзБазы)
				if ошибка != nil {
					Ошибка(" ОписаниеОшибки  %+v \n", ошибка)
				}
				ответ.Данные = map[string]interface{}{
					"НовыеПрава": праваИзБазы,
				}

			}
			// }
		}
	}

	Инфо("Оработали втсавку новой роли %+v \n", ответ)

	сообщение.Ответ[Сервис] = ответ
	ОтправитьСообщение(поток, сообщение)

}
func ИзменитьПрава(поток quic.Stream, сообщение Сообщение) {

}
func УдалитьПрава(поток quic.Stream, сообщение Сообщение) {
	Инфо("УдалитьПрава - перед удалением прав  нужно проверитть что удаляемые права не используется в каких либо документах \n")
}

func ПолучитьПраваИзБазы(роль Права) ([]byte, СтатусБазы) {
	данные := ДанныеЗапроса{
		Запрос: `query <ПроверитьНаличиеПрав>($code: string){
					<роль>(func: eq(<код.прав>, $code)) {			
						uid			
						<код.прав>
						<имя.прав>
					}					
		}`,
		Данные: map[string]string{
			"$code": strconv.Itoa(роль.Код),
		},
	}
	Инфо(" %+v \n", данные)

	return База.Получить(данные)
}

// получает структуру очереди обработчикав для всех маршрутов
func ПолучитьОчередьОбработчиков(поток quic.Stream, сообщение Сообщение) {
	// query {
	// 	var(func: eq(<маршрут>, "/some/route")) {
	// 	  <доступ> @filter(eq(<роль>, "role1")) {
	// 		uid
	// 	  }
	// 	}

	// 	обработчики(func: uid(uid)) {
	// 	  <маршрут>
	// 	  <доступ> {
	// 		<роль> {
	// 		  <имяРоли>
	// 		}
	// 	  }
	// 	  # Другие поля обработчика маршрута
	// 	}
	//   }
	маршрутЗапроса, err := url.Parse(сообщение.Запрос.МаршрутЗапроса)
	Инфо(" маршрутЗапроса %+v \n", маршрутЗапроса)

	if err != nil {
		Ошибка("Parse маршрутЗапроса: ", err)
	}
	маршрутЗапроса.Path = strings.Trim(маршрутЗапроса.Path, "/")
	urlКарта := strings.Split(маршрутЗапроса.Path, "/")

	/*
		Для получения очереди обработчиков нужно проанализировать url и данные формы
		если метод post то аналиируем форму
		если метод get то анализируем Сообщение.ЗАпрос.СтрокаЗапроса содержащую Query часть
		если там не передан параметр "действие" то ищем обработчик из path




	*/
	if сообщение.Запрос.ТипЗапроса == GET || сообщение.Запрос.ТипЗапроса == AJAX {
		// анализируем url параметры
		параметрыЗапроса := маршрутЗапроса.Query()
		дейсвтие, естьДействие := параметрыЗапроса["действие"]
		if естьДействие {
			// получить очередь из БД
			Инфо("получить очередь из БД для: %+v \n", дейсвтие)

		} else {
			if len(urlКарта) > 0 {
				/*
					может пройти по всем частам url и получить очереь обрабочиковдля каждого шага ?
					или брать только первый ?
				*/
				дейсвтие := urlКарта[0]
				Инфо("получить очередь из БД для: %+v \n", дейсвтие)

			}
		}

	}

	if сообщение.Запрос.ТипЗапроса == POST || сообщение.Запрос.ТипЗапроса == AJAXPost {

	}

}

func ПолучитьСписокОчередей(поток quic.Stream, сообщение Сообщение) {

}

func ПолучитьОбработчикиДляЗапроса(поток quic.Stream, сообщение Сообщение) {
	роль := наивысшаяРольПользвоателя(&сообщение)
	маршрут := сообщение.Запрос.МаршрутЗапроса
	данные := ДанныеЗапроса{
		Запрос: `query <ПолучитьОбработчикиМаршурта>($path : string, $role : string) {
						<очереди>(func: eq(<маршрут>, $path)) {  
						<доступ>{     				
							count_roles as <роль> @filter(%s){
								uid
								<код.роли>
								<имя.роли>
							}    	
						} 				
					}				
				}`,
		Данные: map[string]string{
			"$path": маршрут,
			"$role": strconv.Itoa(роль.Код),
		},
	}
	Инфо(" %+v \n", данные)

	// return База.Получить(данные)

	// if len(сообщение.Запрос.КартаМаршрута) > 1 {
	// 	картаМаршрута := сообщение.Запрос.КартаМаршрута
	// 	for i := len(картаМаршрута) - 1; i >= 0; i-- {
	// 		маршрут = append(маршрут, картаМаршрута[i])
	// 	}
	// } else if len(сообщение.Запрос.КартаМаршрута) == 1 {
	// 	маршрут = append(маршрут, сообщение.Запрос.КартаМаршрута[0])
	// 	// сообщениеЗапрос.Запрос.ИмяБазовогоШаблона = ИмяШаблона(сообщениеЗапрос.Запрос.КартаМаршрута[0])
	// } else {
	// 	маршрут = append(маршрут, "/")
	// 	// сообщениеЗапрос.Запрос.ИмяБазовогоШаблона = ИмяШаблона("main")
	// }
	// map[ИмяСервиса]ОчередьОбработчикиЗапроса{}
	// очередь := ОчередностьСервисовИзБД{
	// 	Очередь:            маршрут,
	// 	ПаралельнаяОчередь: make([]string, 0),
	// }

}

func наивысшаяРольПользвоателя(сообщение *Сообщение) Роль {
	праваПользователя := сообщение.ДанныеКлиента.ПраваДоступа

	наивысшаяРоль := Роль{}

	for _, права := range праваПользователя {
		if наивысшаяРоль.Код == 0 && наивысшаяРоль.ИмяРоли == "" {
			наивысшаяРоль = права.Роль
			continue
		}

		if наивысшаяРоль.Код > права.Роль.Код {
			наивысшаяРоль = права.Роль
		}
	}
	return наивысшаяРоль
}
