package main

/*
Доступ может складываться из 	<пользователь>+роль или <пользователь>+права

type типы в dgraph не играют по сути никакой особой роли, поидее они должны на стадии мутации ругатся если в данных с указаным типом есть предикат который в типе не объявлен но это не точно и не работает.


Чтобы филтровать данные по вложенным данным. то нужно использовать филтр на этих данных

	// рабочий запрос - не рабочий
	// {
	// 	node(func: eq(<маршрут>, "рабочий/настройки"))  {
	// 	  uid
	// 		  <маршрут>
	// 	  <доступ>{
	// 		  uid
	// 	  <роль> @filter(eq(<код>, 2)) { - филтруем по доступ.роль.код = 2
	// 			  uid
	// 		<код>
	// 		<имя_роли>
	// 	  }

	// 	}
	//   }
	//   }

*/
// type Шаблонизатор struct {
// 	Код    int    `json:"код,omitempty"` // статус ответа сервиса QErrors
// 	Шаблон string `json:"имя_шаблона,omitempty"`
// }
var СхемаБазы = `<маршрут>: string @index(exact) @upsert .
<путь>:  string @index(exact) @upsert .
<имя_обработчика>:  string @index(exact) @upsert .
<обработчик>:  uid  .
<сервис>:  string  .
<комманда>:  string @index(exact) @upsert .
<описание>: string .
<имя_шаблона>: string .
<шаблон>: uid .
<очередь>: int .
<код>: int .
<код.роли>: int @index(int) .
<код.прав>: int  @index(int) .
<ассинхронно>: bool  .
<шаблонизатор>: [uid] .	
<доступ>: [uid] @reverse @count  .	
<пользователь>: uid . 
<роль>: uid  @reverse @count . 
<логин>: string . 
<права>: [uid] .
<имя.роли>: string @index(term) .
<имя.прав>:string @index(term) .
<дата_создания>: dateTime  .	
<очередь_обработчиков>: [uid] .
<ассинхронная_очередь_обоработчиков>: [uid] .
<создатель>: uid .
type <Обработчик> {	
    <очередь>
    <сервис>
	<имя_обработчика> 
}
type <Роль> {	
    <код.роли> 
	<имя.роли>
}
type <Права> {
    <код.прав>	 
	<имя.прав> 
}

type <Шаблон>{
	<код>
	<имя_шаблона>
}
type <Доступ> {
	<роль>
	<права>
}
type <ОбработчикМаршрута> {
	<маршрут>
	<комманда>
	<очередь_обработчиков> 
	<ассинхронная_очередь_обоработчиков> 
    <доступ>  
	<описание>
    <имя_шаблона>	
}	
`

// type <Маршрут> {
//     <путь>
// 	<роль>
// 	<права>
// 	<очередь_обработчиков>
// 	<имя_шаблона>
// }
//     type <ОчередьОбработчиков> {
//         <маршрут>
//         <очередь_обоработчиков>
//         <дата_создания>
//         <создатель>
// }

/*
						// Определение структуры для типа "ОчередьОбработчиков"
type ОчередьОбработчиков struct {
    UID     string `json:"uid,omitempty"`
    Имя     string `json:"имя,omitempty"`
    Статус  string `json:"статус,omitempty"`
}

// Создание новой записи типа "ОчередьОбработчиков"
newHandler := &ОчередьОбработчиков{
    Имя:    "Обработчик 1",
    Статус: "Активный",
}

// Добавление записи в Dgraph
resp, err := База.Мутация(ДанныеЗапроса{
    Запрос: `
        mutation {
            addОчередьОбработчиков(input: [
                {
                    имя: $имя
                    статус: $статус
                }
            ]) {
                ОчередьОбработчиков {
                    uid
                    имя
                    статус
                }
            }
        }
    `,
    Данные: map[string]interface{}{
        "имя":    newHandler.Имя,
        "статус": newHandler.Статус,
    },
})

if err != nil {
    Ошибка("Ошибка при добавлении данных: %v", err)
    return
}

Инфо("Новая запись добавлена: %+v", resp.Json)

В этом примере:
Определяется структура ОчередьОбработчиков для типа, определенного в схеме.
Создается новый экземпляр ОчередьОбработчиков с заполненными полями.
Используется метод База.Мутация() для добавления новой записи в Dgraph.
В запросе мутации используется ключевое слово addОчередьОбработчиков, которое соответствует типу, определенному в схеме.
Данные для новой записи передаются в виде параметров запроса.
Результат мутации выводится в лог.
Убедитесь, что структура ОчередьОбработчиков соответствует типу, определенному в схеме Dgraph.

*/
