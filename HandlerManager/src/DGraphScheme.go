package main

/*
Доступ может складываться из 	<пользователь>+роль или <пользователь>+права

type типы в dgraph не играют по сути никакой особой роли, поидее они должны на стадии мутации ругатся если в данных с указаным типом есть предикат который в типе не объявлен но это не точно и не работает.


Чтобы филтровать данные по вложенным данным. то нужно использовать филтр на этих данных

	// рабочий запрос - не рабочий
	// {
	// 	node(func: eq(<маршрут>, "рабочий/настройки"))  {
	// 	  uid
	// 		  <маршрут>
	// 	  <доступ>{
	// 		  uid
	// 	  <роль> @filter(eq(<код>, 2)) { - филтруем по доступ.роль.код = 2
	// 			  uid
	// 		<код>
	// 		<имя_роли>
	// 	  }

	// 	}
	//   }
	//   }

*/
// type Шаблонизатор struct {
// 	Код    int    `json:"код,omitempty"` // статус ответа сервиса QErrors
// 	Шаблон string `json:"имя_шаблона,omitempty"`
// }

// type <ОбработчикМаршрута> {
// 	<маршрут>
// 	<комманда>
// 	<обработчики> [
//         {
//             <роль>
//             <права>
//             <очередь_обработчиков>
//             <ассинхронная_очередь_обоработчиков>
//             <имя_шаблона>
//         }

//	   ]
//	}
var СхемаБазы = `<маршрут>: string @index(exact) @upsert .
<путь>:  string @index(exact) @upsert .
<имя_обработчика>:  string @index(exact) @upsert .
<обработчик>:  uid  .
<обработчики>:  [uid]  .
<сервис>:  string  .
<комманда>:  string @index(exact) @upsert .
<описание>: string .
<имя_шаблона>: string .
<шаблон>: uid .
<очередь>: int .
<код_ответа>: int .
<код.роли>: int @index(int) .
<код.прав>: int  @index(int) .
<ассинхронно>: bool  .
<шаблонизатор>: [uid] .	
<доступ>: [uid] @reverse @count  .	
<пользователь>: uid . 
<пользователи>: [uid] . 
<роль>: uid  @reverse @count . 
<логин>: string . 
<права>: [uid] .
<имя.роли>: string @index(term) .
<имя.прав>:string @index(term) .
<дата_создания>: dateTime  .	
<очередь_обработчиков>: [uid] .
<ассинхронная_очередь_обоработчиков>: [uid] .
<создатель>: uid .
<описание>: string .


type <Роль> {	
  <код.роли> 
	<имя.роли>
}
type <Права> {
  <код.прав>	 
	<имя.прав> 
}

type <Шаблон>{
	<код_ответа>
	<имя_шаблона>
}
type <Доступ> {
	<роль>
	<права>
}

type <ОбработчикМаршрута> {
	<маршрут>
	<комманда>	
  <обработчики> 
  <описание>
}	

type <Обработчики> {	
  <код.роли>
  <права>
  <пользователи>
  <очередь_обработчиков>
  <ассинхронная_очередь_обоработчиков>
  <имя_шаблона> 
}
type <Обработчик> {	   
  <сервис>
  <имя_обработчика> 
}
type <ОчередностьОбработчика> {
  <очередь>
  <обработчик>
}


type <ОбработчикМаршрута_в1> {
	<маршрут>
	<комманда>
    <обработчики>
	<очередь_обработчиков> 
	<ассинхронная_очередь_обоработчиков> 
    <доступ>  
	<описание>
    <имя_шаблона>	
}	
`

/*

"Форма": {
    "очередь[lwkeh6ihaywkm]": [
      "2"
    ],
    "сервис[lwkehcj5e1ow5]": [
      "option4"
    ],
    "ассинхронно[d1hpz3gzclglLC9ha]": [
      "1"
    ],
    "маршрут": [
      "рабочий/настройки"
    ],
    "обработчик[d1hpz3gzclglLC9ha]": [
      "option2"
    ],
    "очередь[d1hpz3gzamokyU4iD]": [
      "1"
    ],
    "шаблон": [
      "имя шаблона"
    ],
    "сервис[lwkeh6ihaywkm]": [
      "option2"
    ],
    "действие": [
      "добавитьОбработчик"
    ],
    "права_доступа[d1hpz3gz56muO8Lkm]": [
      "1",
      "2",
      "3"
    ],
    "имяКомманды": [
      ""
    ],
    "роль[d1hpz3gz56muO8Lkm]": [
      "1"
    ],
    "ассинхронно[lwkehcj5e1ow5]": [
      "1"
    ],
    "сервис[d1hpz3gzamokyU4iD]": [
      "option3"
    ],
    "обработчик[lwkeh6ihaywkm]": [
      "option3"
    ],
    "сервис[d1hpz3gzclglLC9ha]": [
      "option2"
    ],
    "обработчик[d1hpz3gzamokyU4iD]": [
      "option2"
    ],
    "обработчик[lwkehcj5e1ow5]": [
      "option4"
    ],
    "isActive": [
      "1"
    ]
  },


  ОбработчикМаршрута{
		Тип:      "ОбработчикМаршрута",
		Маршрут:  маршрут,
		Комманда: комманда,
		Обработчики: []Обработчики{
			{
				ОчередьОбработчиков:             []Обработчик{
                                                            Очередь:        new(int),
                                                            ИмяСервиса:     имяСервиса[0],
                                                            ИмяОбработчика: имяОбработчика[0],
                                                        }, // обработчики у которых есть поле очередь, определяющее индекс обработчика в массиве
				АссинхроннаяОчередьОбработчиков:  []Обработчик{
                                                            ИмяСервиса:     имяСервиса[0],
                                                            ИмяОбработчика: имяОбработчика[0],
                                                        }, // обработчики у которых есть поле ассинхронно
				ИмяШаблона:                      шаблон,
				Роль: кодРоли,
                Права: []права_доступа
			},
		},
	}

Мне приходят данные формы, нужно сгрупировать эти данные по идентификаторам в квадратных скобка, а затем поместить всё в структуру ОбработчикМаршрута
*/

// type <Маршрут> {
//     <путь>
// 	<роль>
// 	<права>
// 	<очередь_обработчиков>
// 	<имя_шаблона>
// }
//     type <ОчередьОбработчиков> {
//         <маршрут>
//         <очередь_обоработчиков>
//         <дата_создания>
//         <создатель>
// }

/*
						// Определение структуры для типа "ОчередьОбработчиков"
type ОчередьОбработчиков struct {
    UID     string `json:"uid,omitempty"`
    Имя     string `json:"имя,omitempty"`
    Статус  string `json:"статус,omitempty"`
}

// Создание новой записи типа "ОчередьОбработчиков"
newHandler := &ОчередьОбработчиков{
    Имя:    "Обработчик 1",
    Статус: "Активный",
}

// Добавление записи в Dgraph
resp, err := База.Мутация(ДанныеЗапроса{
    Запрос: `
        mutation {
            addОчередьОбработчиков(input: [
                {
                    имя: $имя
                    статус: $статус
                }
            ]) {
                ОчередьОбработчиков {
                    uid
                    имя
                    статус
                }
            }
        }
    `,
    Данные: map[string]interface{}{
        "имя":    newHandler.Имя,
        "статус": newHandler.Статус,
    },
})

if err != nil {
    Ошибка("Ошибка при добавлении данных: %v", err)
    return
}

Инфо("Новая запись добавлена: %+v", resp.Json)

В этом примере:
Определяется структура ОчередьОбработчиков для типа, определенного в схеме.
Создается новый экземпляр ОчередьОбработчиков с заполненными полями.
Используется метод База.Мутация() для добавления новой записи в Dgraph.
В запросе мутации используется ключевое слово addОчередьОбработчиков, которое соответствует типу, определенному в схеме.
Данные для новой записи передаются в виде параметров запроса.
Результат мутации выводится в лог.
Убедитесь, что структура ОчередьОбработчиков соответствует типу, определенному в схеме Dgraph.

*/
