package main

import (
	"crypto/rand"
	"encoding/base64"
	"errors"
	"time"

	. "aoanima.ru/ConnQuic"
	. "aoanima.ru/DGApi"

	. "aoanima.ru/Logger"
	. "aoanima.ru/QErrors"
	jwt "github.com/golang-jwt/jwt/v5"
	"github.com/google/uuid"
)

type ПараметрыКлиента struct {
	ИдКлиента string `json:"UID"`
	// Роль      []string `json:"role"`
	// Права     []string `json:"access"`
	jwt.RegisteredClaims
}

func СоздатьJWT(данныеТокена ДанныеКлиента) (string, СтатусСервиса) {

	требование := ПараметрыКлиента{
		ИдКлиента: данныеТокена.ИдКлиента.String(),
		// Права:     данныеТокена.Права,
		RegisteredClaims: jwt.RegisteredClaims{
			// ExpiresAt: jwt.NewNumericDate(time.Now().Add(24 * time.Hour)),
			ExpiresAt: jwt.NewNumericDate(time.Now().Add(24 * time.Hour).Round(time.Second)),
			IssuedAt:  jwt.NewNumericDate(time.Now()),
			NotBefore: jwt.NewNumericDate(time.Now()),
			ID:        uuid.New().String(),
		},
	}
	// секрет, статус := СоздатьСекретКлиента(данныеТокена.ИдКлиента.String())
	секрет, статус := ПолучитьСекретныйКлючКлиента(данныеТокена.ИдКлиента)
	if статус.Код != Ок {
		return "", статус
	}
	return ПодписатьJWT(требование, секрет.Секрет)
}

func ПроверитьСрокСекрета(секрет Секрет) СтатусСервиса {

	осталосьВремениДоИстечения := секрет.Обновлен.Sub(time.Now())
	if осталосьВремениДоИстечения < 5*time.Minute {
		return СтатусСервиса{
			Код:   СрокСекретаИстекает,
			Текст: "Секрет истекает через " + осталосьВремениДоИстечения.String(),
		}
	} else {
		return СтатусСервиса{
			Код: Ок,
		}
	}

}

func ПодписатьJWT(данныеJWT ПараметрыКлиента, секрет string) (string, СтатусСервиса) {

	token := jwt.NewWithClaims(jwt.SigningMethodHS256, данныеJWT)

	// Подписываем токен с использованием секретного ключа
	подписаннаяСтрока, err := token.SignedString([]byte(секрет))
	if err != nil {
		return "", СтатусСервиса{
			Код:   ОшибкаПодписиJWT,
			Текст: "Не удалось подписать токен: " + err.Error(),
		}
	}

	return подписаннаяСтрока, СтатусСервиса{
		Код:   Ок,
		Текст: "JWT успешно подписан",
	}
}

func ПолучитьСекретныйКлючКлиента(ИдКлиента uuid.UUID) (Секрет, СтатусСервиса) {

	ответ, ошибка := СекретноеСоединение.Получить(ДанныеЗапроса{
		Запрос: `query Секрет($ид_клиента: string){
			Секрет(func eq (<ид_клиента>, $ид_клиента)) {
				<секрет>
				<обновлен>
				<ид_клиента>
			}
		}`,
		Данные: map[string]string{
			"ид_клиента": ИдКлиента.String(),
		},
	})
	if ошибка.Код != Ок {
		return Секрет{}, СтатусСервиса{
			Код:   ошибка.Код,
			Текст: ошибка.Текст,
		}
	}
	секрет := Секрет{}
	err := ИзJson(ответ, &секрет)
	if err != nil {
		Ошибка("  %+v \n", err.Error())
		return Секрет{}, СтатусСервиса{
			Код:   ОшибкаJSONКодирования,
			Текст: err.Error(),
		}
	}
	статусСекрета := ПроверитьСрокСекрета(секрет)
	if статусСекрета.Код != Ок {
		if статусСекрета.Код == СрокСекретаИстекает {
			новвыйСекрет, статусСоздания := СоздатьСекретКлиента(ИдКлиента.String())
			if статусСоздания.Код != Ок {
				Ошибка("  %+v \n", статусСоздания)
				return Секрет{}, статусСоздания
			}
			секрет = новвыйСекрет
		}
	}
	return секрет, СтатусСервиса{
		Код: Ок,
	}
	// откроем файл в котором храниться скертный ключ
	// данные, статус := БазаСекретов.Найти("ИдКлиента", ИдКлиента.String())
	// if статус.Код != Ок {
	// 	Инфо("  %+v \n", статус)
	// 	return "", ОшибкаСервиса{
	// 		Код:   СекретНеНайден,
	// 		Текст: "Секретный ключ не найден",
	// 	}
	// }
	// секрет := данные["ИдКлиента"].Данные["секрет"]
	// return секрет.(string), ОшибкаСервиса{
	// 	Код:   Ок,
	// 	Текст: "Секретный ключ получен",
	// }
}

// генерирует случайну строку указанной длины, можно использвоать например для того чтобы подставлять в форму запроса кода подтверждения чтобы верифицировать.
func СоздатьСлучайныйТокен(размер int) string {
	key := make([]byte, размер)
	_, err := rand.Read(key)
	if err != nil {
		return ""
	}

	// Кодируем байты в base64 строку
	keyString := base64.URLEncoding.EncodeToString(key)
	return keyString
}

/*
СоздатьСекретКлиента
Генерирует случайнную строку для подписи jwt токена  длиной 256 байт и сохраняет а базу секеретов
*/
func СоздатьСекретКлиента(ИдКлиента string) (Секрет, СтатусСервиса) {
	// Генерируем байты случайных данных
	key := make([]byte, 256)
	_, err := rand.Read(key)
	if err != nil {
		return Секрет{}, СтатусСервиса{
			Код:   Прочее,
			Текст: "Не удалось сгенерировать случайное значение: " + err.Error(),
		}
	}

	// Кодируем байты в base64 строку
	секрет := base64.URLEncoding.EncodeToString(key)
	времяОбновления := jwt.NewNumericDate(time.Now())
	СекретноеСоединение.Изменить(ДанныеЗапроса{
		Запрос: `query{
			"set": {
				"ид_клиента": "` + ИдКлиента + `",
				"секрет": "` + секрет + `",
				"обновлен": ` + времяОбновления.String() + `,
				"dgraph.type": "Секрет"
			}
		}`,
	})

	// документСекрет := Документ{
	// 	ПервичныйКлюч: ПервичныйКлюч("ИдКлиента"),
	// 	Данные: map[string]interface{}{
	// 		"секрет":    секрет,
	// 		"ИдКлиента": ИдКлиента,
	// 	},
	// }

	// статус := БазаСекретов.ВставитьДокумент(&документСекрет, true)
	// if статус.Код != Ок {
	// 	Инфо("  %+v \n", статус)
	// 	return "", ОшибкаСервиса{
	// 		Код:   ОшибкаЗаписи,
	// 		Текст: "Секретный ключ не удалось записать в базу",
	// 	}
	// }
	return Секрет{
			Секрет:    секрет,
			ИдКлиента: ИдКлиента,
			Обновлен:  времяОбновления.Time,
		}, СтатусСервиса{
			Код:   Ок,
			Текст: "Секретный ключ создан",
		}
}

func ВлаидацияТокена(сообщение *Сообщение) (bool, СтатусСервиса) {
	// секрет, статус := ПолучитьСекретныйКлючКлиента(сообщение.ИдКлиента)
	// if статус.Код != Ок {
	// 	return false, ОшибкаСервиса{
	// 		Код:   СекретНеНайден,
	// 		Текст: "не удалось получить секретный ключ клиента",
	// 	}
	// }
	if сообщение.JWT == "" && сообщение.ТокенКлиента.ИдКлиента == uuid.Nil {
		return false, СтатусСервиса{
			Код:   НетДанныхКлиента,
			Текст: "Клиет не опознан, нет данных jwt",
		}
	}
	секрет, статус := ПолучитьСекретныйКлючКлиента(сообщение.ИдКлиента)
	if статус.Код != Ок {
		Ошибка("  %+v \n", статус)
	}
	токен, err := jwt.Parse(сообщение.JWT, func(token *jwt.Token) (interface{}, error) {
		if _, ok := token.Method.(*jwt.SigningMethodHMAC); !ok {
			return nil, errors.New("Не известный метод шифрования")
		}
		// сюда  п идее можно вставить функциб получения скерата из базы
		// секрет, статус := ПолучитьСекретныйКлючКлиента(сообщение.ИдКлиента)
		// if статус.Код != Ок {
		// 	return nil, errors.New("не удалось получить секретный ключ клиента")
		// }
		// return []byte(секрет), nil
		return секрет.Секрет, nil
	})

	if err != nil {
		return false, СтатусСервиса{
			Код:   ОшибкаВалидацииJWT,
			Текст: "не удалось валидировать токен: " + err.Error(),
		}
	}
	/*
	   утверджение это своего рода - утверждение того что должно быть в токене подписано. типа требование что вот эти данные должны юбыть подписаны!!
	*/
	// Проверяем валидность токена
	if утверждения, ok := токен.Claims.(ПараметрыКлиента); !ok || !токен.Valid {
		Ошибка(" токен не валидныйутверждения%+v \n", утверждения)
		сообщение.JWT = "invaild"

		return false, СтатусСервиса{
			Код:   ОшибкаВалидацииJWT,
			Текст: "Токен не валидный",
		}
	} else {
		истекает, err := утверждения.GetExpirationTime()
		if err != nil {
			Ошибка("  %+v \n", err.Error())
		}
		// истекает := time.Unix(токен["expires"].(int64), 0)

		Инфо(" токен Валидный, подпишем заново %+v \n", утверждения)
		// если осталось менее 5 минут переподпишем токен
		/*
			Вместо time.Duration(осталосьВремениДоИстечения.Minutes()) < 5*time.Minute используйте осталосьВремениДоИстечения < 5*time.Minute. Функция time.Duration возвращает продолжительность в наносекундах, поэтому нет необходимости умножать на time.Minute.
		*/
		// if осталосьВремениДоИстечения := истекает.Sub(time.Now()); time.Duration(осталосьВремениДоИстечения.Minutes()) < 5*time.Minute {
		if осталосьВремениДоИстечения := истекает.Sub(time.Now()); осталосьВремениДоИстечения < 5*time.Minute {

			утверждения.ExpiresAt = jwt.NewNumericDate(time.Now().Add(24 * time.Hour).Round(time.Second))
			утверждения.IssuedAt = jwt.NewNumericDate(time.Now())

			новыйСекрет, статус := СоздатьСекретКлиента(утверждения.ИдКлиента)
			if статус.Код != Ок {
				Ошибка(" Убедитесь, что вы обрабатываете все возможные ошибки. Например, что произойдет, если СоздатьСекретКлиента вернет ошибку? %+v \n", статус)
				return false, статус
			}

			сообщение.ТокенКлиента.Истекает = утверждения.ExpiresAt.Time
			сообщение.ТокенКлиента.Создан = утверждения.IssuedAt.Time

			новыйJWT, ошибкаСервиса := ПодписатьJWT(утверждения, новыйСекрет.Секрет)
			if ошибкаСервиса.Код != Ок {
				Ошибка("  %+v \n", err)
				return true, СтатусСервиса{
					Код:   ОшибкаПодписиJWT,
					Текст: "НЕ удалось подписать JWT токен: " + ошибкаСервиса.Текст,
				}
			}
			сообщение.JWT = новыйJWT

			// ответ := сообщение.Ответ[Сервис]

			// ответ.Сервис = Сервис
			// ответ.ЗапросОбработан = true
			// ответ.Данные = map[string]bool{
			// 	"ТокенВерный": true,
			// }
			// ответ.ОшибкаСервиса = ОшибкаСервиса{
			// 	Код:   Ок,
			// 	Текст: "Токен валидный",
			// }
			// сообщение.Ответ[Сервис] = ответ

			return true, СтатусСервиса{
				Код:   Ок,
				Текст: "Токен валидный",
			}
		}

		// ответ := сообщение.Ответ[Сервис]

		// ответ.Сервис = Сервис
		// ответ.ЗапросОбработан = true
		// ответ.Данные = map[string]bool{
		// 	"ТокенВерный": true,
		// }
		// ответ.ОшибкаСервиса = ОшибкаСервиса{
		// 	Код:   Ок,
		// 	Текст: "Токен валидный",
		// }
		// сообщение.Ответ[Сервис] = ответ

		return true, СтатусСервиса{
			Код:   Ок,
			Текст: "Токен валидный",
		}
	}
}
