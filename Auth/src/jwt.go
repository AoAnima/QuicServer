package main

import (
	"crypto/rand"
	"encoding/base64"
	"errors"
	"time"

	. "aoanima.ru/ConnQuic"
	. "aoanima.ru/DataBase"
	. "aoanima.ru/Logger"
	. "aoanima.ru/QErrors"
	jwt "github.com/golang-jwt/jwt/v5"
	"github.com/google/uuid"
)

type КлиентClaims struct {
	ИдКлиента string   `json:"UID"`
	Роль      []string `json:"role"`
	Права     []string `json:"access"`
	jwt.RegisteredClaims
}

func СоздатьJWT(данныеТокена ДанныеКлиента) (string, ОшибкаСервиса) {

	claims := КлиентClaims{
		ИдКлиента: данныеТокена.ИдКлиента.String(),
		Роль:      данныеТокена.Роль,
		Права:     данныеТокена.Права,
		RegisteredClaims: jwt.RegisteredClaims{
			ExpiresAt: jwt.NewNumericDate(time.Now().Add(24 * time.Hour)),
			IssuedAt:  jwt.NewNumericDate(time.Now()),
			NotBefore: jwt.NewNumericDate(time.Now()),
			ID:        uuid.New().String(),
		},
	}
	секрет, статус := СоздатьСекретКлиента(данныеТокена.ИдКлиента.String())
	if статус.Код != Ок {
		return "", статус
	}
	return ПодписатьJWT(claims, секрет)
}

func ПодписатьJWT(данныеJWT КлиентClaims, секрет string) (string, ОшибкаСервиса) {

	token := jwt.NewWithClaims(jwt.SigningMethodHS256, данныеJWT)

	// Подписываем токен с использованием секретного ключа
	подписаннаяСтрока, err := token.SignedString([]byte(секрет))
	if err != nil {
		return "", ОшибкаСервиса{
			Код:   ОшибкаПодписиJWT,
			Текст: "Не удалось подписать токен: " + err.Error(),
		}
	}

	return подписаннаяСтрока, ОшибкаСервиса{
		Код:   Ок,
		Текст: "JWT успешно подписан",
	}
}

func ПолучитьСекретныйКлючКлиента(ИдКлиента uuid.UUID) (string, ОшибкаСервиса) {
	// откроем файл в котором храниться скертный ключ
	данные, статус := БазаСекретов.Найти("ИдКлиента", ИдКлиента.String())
	if статус.Код != Ок {
		Инфо("  %+v \n", статус)
		return "", ОшибкаСервиса{
			Код:   СекретНеНайден,
			Текст: "Секретный ключ не найден",
		}
	}
	секрет := данные["ИдКлиента"].Данные["секрет"]
	return секрет.(string), ОшибкаСервиса{
		Код:   Ок,
		Текст: "Секретный ключ получен",
	}
}

// генерирует случайну строку указанной длины, можно использвоать например для того чтобы подставлять в форму запроса кода подтверждения чтобы верифицировать.
func СоздатьСлучайныйТокен(размер int) string {
	key := make([]byte, размер)
	_, err := rand.Read(key)
	if err != nil {
		return ""
	}

	// Кодируем байты в base64 строку
	keyString := base64.URLEncoding.EncodeToString(key)
	return keyString
}

/*
СоздатьСекретКлиента
Генерирует случайнную строку для подписи jwt токена  длиной 256 байт и сохраняет а базу секеретов
*/
func СоздатьСекретКлиента(ИдКлиента string) (string, ОшибкаСервиса) {
	// Генерируем байты случайных данных
	key := make([]byte, 256)
	_, err := rand.Read(key)
	if err != nil {
		return "", ОшибкаСервиса{
			Код:   Прочее,
			Текст: "Не удалось сгенерировать случайное значение: " + err.Error(),
		}
	}

	// Кодируем байты в base64 строку
	секрет := base64.URLEncoding.EncodeToString(key)

	документСекрет := Документ{
		ПервичныйКлюч: ПервичныйКлюч("ИдКлиента"),
		Данные: map[string]interface{}{
			"секрет":    секрет,
			"ИдКлиента": ИдКлиента,
		},
	}

	статус := БазаСекретов.ВставитьДокумент(&документСекрет, true)
	if статус.Код != Ок {
		Инфо("  %+v \n", статус)
		return "", ОшибкаСервиса{
			Код:   ОшибкаЗаписи,
			Текст: "Секретный ключ не удалось записать в базу",
		}
	}
	return секрет, ОшибкаСервиса{
		Код:   Ок,
		Текст: "Секретный ключ создан",
	}
}

func ВлаидацияТокена(сообщение *Сообщение) (bool, ОшибкаСервиса) {
	// секрет, статус := ПолучитьСекретныйКлючКлиента(сообщение.ИдКлиента)
	// if статус.Код != Ок {
	// 	return false, ОшибкаСервиса{
	// 		Код:   СекретНеНайден,
	// 		Текст: "не удалось получить секретный ключ клиента",
	// 	}
	// }
	token, err := jwt.Parse(сообщение.JWT, func(token *jwt.Token) (interface{}, error) {
		if _, ok := token.Method.(*jwt.SigningMethodHMAC); !ok {
			return nil, errors.New("Не известный метод шифрования")
		}
		// сюда  п идее можно вставить функциб получения скерата из базы
		секрет, статус := ПолучитьСекретныйКлючКлиента(сообщение.ИдКлиента)
		if статус.Код != Ок {
			return nil, errors.New("не удалось получить секретный ключ клиента")
		}
		return []byte(секрет), nil
	})

	if err != nil {
		return false, ОшибкаСервиса{
			Код:   ОшибкаВалидацииJWT,
			Текст: "не удалось валидировать токен: " + err.Error(),
		}
	}

	// Проверяем валидность токена
	if токен, ok := token.Claims.(КлиентClaims); !ok || !token.Valid {
		Ошибка(" токен не валидный %+v \n", токен)
		сообщение.JWT = "invaild"

		return false, ОшибкаСервиса{
			Код:   ОшибкаВалидацииJWT,
			Текст: "Токен не валидный",
		}
	} else {
		истекает, err := токен.GetExpirationTime()
		if err != nil {
			Ошибка("  %+v \n", err.Error())
		}
		// истекает := time.Unix(токен["expires"].(int64), 0)

		Инфо(" токен Валидный, подпишем заново %+v \n", токен)
		// если осталось менее 5 минут переподпишем токен
		if осталосьВремениДоИстечения := истекает.Sub(time.Now()); time.Duration(осталосьВремениДоИстечения.Minutes()) < 5*time.Minute {

			токен.ExpiresAt = jwt.NewNumericDate(time.Now().Add(24 * time.Hour))
			токен.IssuedAt = jwt.NewNumericDate(time.Now())

			новыйСекрет, статус := СоздатьСекретКлиента(токен.ИдКлиента)
			if статус.Код != Ок {
				Ошибка(" %+v \n", статус)
				return false, статус
			}

			сообщение.ТокенКлиента.Истекает = токен.ExpiresAt.Time
			сообщение.ТокенКлиента.Создан = токен.IssuedAt.Time

			новыйJWT, ошибкаСервиса := ПодписатьJWT(токен, новыйСекрет)
			if ошибкаСервиса.Код != Ок {
				Ошибка("  %+v \n", err)
			}
			сообщение.JWT = новыйJWT

			// ответ := сообщение.Ответ[Сервис]

			// ответ.Сервис = Сервис
			// ответ.ЗапросОбработан = true
			// ответ.Данные = map[string]bool{
			// 	"ТокенВерный": true,
			// }
			// ответ.ОшибкаСервиса = ОшибкаСервиса{
			// 	Код:   Ок,
			// 	Текст: "Токен валидный",
			// }
			// сообщение.Ответ[Сервис] = ответ

			return true, ОшибкаСервиса{
				Код:   Ок,
				Текст: "Токен валидный",
			}
		}

		// ответ := сообщение.Ответ[Сервис]

		// ответ.Сервис = Сервис
		// ответ.ЗапросОбработан = true
		// ответ.Данные = map[string]bool{
		// 	"ТокенВерный": true,
		// }
		// ответ.ОшибкаСервиса = ОшибкаСервиса{
		// 	Код:   Ок,
		// 	Текст: "Токен валидный",
		// }
		// сообщение.Ответ[Сервис] = ответ

		return true, ОшибкаСервиса{
			Код:   Ок,
			Текст: "Токен валидный",
		}
	}
}
