package main

import (
	"crypto/rand"
	"errors"
	"math"
	"math/big"
	"net/smtp"
	"net/url"
	"os"
	"strings"
	"sync"

	. "aoanima.ru/ConnQuic"
	. "aoanima.ru/DataBase"
	. "aoanima.ru/Logger"
	. "aoanima.ru/QErrors"
	"github.com/google/uuid"
	json "github.com/json-iterator/go"
	"github.com/quic-go/quic-go"
)

var клиент = make(Клиент)
var Сервис ИмяСервиса = "Авторизация"

// TODO
var БазаДанных Таблица
var БазаСекретов Таблица

type ДанныеКлиента struct {
	ИдКлиента       uuid.UUID
	Роль            []string
	Права           []string
	ТокенОбновления string
	Email           string
	Логин           string
	Пароль          string
	JWT             string
	Профиль         map[string]interface{}
}

func main() {
	Инфо("  %+v \n", " Запуск сервиса Авторизации")
	сервер := &СхемаСервера{
		Имя:   "SynQuic",
		Адрес: "localhost:4242",
		ДанныеСессии: ДанныеСессии{
			Блок:   &sync.RWMutex{},
			Потоки: []quic.Stream{},
		},
	}
	сообщениеРегистрации := Сообщение{
		Сервис:      Сервис,
		Регистрация: true,
		Маршруты:    []Маршрут{"reg", "auth", "verify", "checkLogin", "code"},
	}

	клиент.Соединиться(сервер,
		сообщениеРегистрации,
		ОбработчикОтветаРегистрации,
		ОбработчикЗапросовСервера)
}

func ИнициализацияБазыДанных() {
	БазаДанных = Таблица{
		Имя:           "клиенты",
		Дирректория:   "./database",
		ПервичныйКлюч: "ИдКлиента", //
		База:          База{},
		// Индексы: ТаблицаИндексов{
		// 	Версия:      1,
		// 	Дирректория: "./database/index",
		// 	ИмяТаблицы:  "клиенты",
		// 	// КартаИндексов: map[ПутьИндекса]struct{}{
		// 	// 	"Адрес.Город": struct{}{},
		// 	// },
		// },
		УникальныеИндексы: ТаблицаИндексов{
			Версия:      1,
			Дирректория: "./database/uniq_index",
			ИмяТаблицы:  "клиенты",
			КартаИндексов: map[ПутьИндекса]struct{}{
				"Email": {},
				"Логин": {},
			},
			Уникальный: true,
		},
	}

	ошибкаБазы := БазаДанных.АктивироватьТаблицу()
	if ошибкаБазы.Код != 0 {
		Ошибка(" ошибкаБазы %+v \n", ошибкаБазы)
	}

	БазаСекретов = Таблица{
		Имя:           "секрет",
		Дирректория:   "./database",
		ПервичныйКлюч: "ИдКлиента", //
		База:          База{},
		// Индексы: ТаблицаИндексов{
		// 	Версия:      1,
		// 	Дирректория: "./database/index",
		// 	ИмяТаблицы:  "клиенты",
		// 	// КартаИндексов: map[ПутьИндекса]struct{}{
		// 	// 	"Адрес.Город": struct{}{},
		// 	// },
		// },
		// УникальныеИндексы: ТаблицаИндексов{
		// 	Версия:      1,
		// 	Дирректория: "./database/uniq_index",
		// 	ИмяТаблицы:  "клиенты",
		// 	КартаИндексов: map[ПутьИндекса]struct{}{
		// 		"Email": {},
		// 		"Логин": {},
		// 	},
		// 	Уникальный: true,
		// },
	}
	ошибкаБазы = БазаСекретов.АктивироватьТаблицу()
	if ошибкаБазы.Код != 0 {
		Ошибка(" ошибкаБазы %+v \n", ошибкаБазы)
	}
}

func ОбработчикОтветаРегистрации(сообщение Сообщение) {
	Инфо("  ОбработчикОтветаРегистрации %+v \n", сообщение)
}

func ОбработчикЗапросовСервера(поток quic.Stream, сообщение Сообщение) {
	Инфо("  ОбработчикЗапросовСервера %+v \n", сообщение)
	var err error
	// var ошибкаБазы ОшибкаБазы
	var ошибкаСервиса ОшибкаСервиса
	var ok bool
	var email string
	параметрыЗапроса, err := url.Parse(сообщение.Запрос.МаршрутЗапроса)
	Инфо(" параметрыЗапроса %+v \n", параметрыЗапроса)
	if err != nil {
		Ошибка("Ошибка при парсинге СтрокаЗапроса запроса:", err)
	}

	параметрыЗапроса.Path = strings.Trim(параметрыЗапроса.Path, "/")
	дейсвтия := strings.Split(параметрыЗапроса.Path, "/")

	var Действие string
	if len(дейсвтия) == 0 {
		Инфо(" Пустой маршрут, добавляем в маршруты обработку по умолчанию.... \n")
		// Читаем заголовки парсим и проверяем JWT
		Действие = "verify"

	} else {
		Действие = дейсвтия[0]
	}

	switch Действие {
	case "reg":
		ok, ошибкаСервиса = Регистрация(&сообщение)

		Инфо(" Регистрация ок  %+v  %+v \n", ok, ошибкаСервиса)
		отправить, err := Кодировать(сообщение)
		if err != nil {
			Ошибка("  %+v \n", err)
		}
		поток.Write(отправить)
		return
	case "auth":

		ok, email, err = Авторизация(&сообщение)
		if ok && email != "" {
			ОтправитьПроверочныйКод(&сообщение, email)
		}
		Инфо(" Авторизация ок  %+v \n", ok)

	case "code":
		ok, err = ПроверитьКод(&сообщение)
		Инфо(" ПроверитьКод ок  %+v \n", ok)
	case "checkLogin":
		_, ошибкаСервиса = ПроверитьЛогин(&сообщение)
		отправить, err := Кодировать(сообщение)
		if err != nil {
			Ошибка("  %+v \n", err)
		}
		поток.Write(отправить)
		return
	case "checkEmail":
		_, ошибкаСервиса = ПроверитьEmail(&сообщение)
		отправить, err := Кодировать(сообщение)
		if err != nil {
			Ошибка("  %+v \n", err)
		}
		поток.Write(отправить)
		return
	case "verify":

		ok, статус := ВлаидацияТокена(&сообщение)
		if ok {
			отправить, err := Кодировать(сообщение)
			if err != nil {
				Ошибка("  %+v \n", err)
			}
			поток.Write(отправить)
		} else {
			Ошибка("  %+v \n", статус)
		}
		return
	default:
		// если не совпадает ни с одним из действий то проверим если токен не пустой то проверим подпись
		ok, статус := ВлаидацияТокена(&сообщение)
		if ok {
			отправить, err := Кодировать(сообщение)
			if err != nil {
				Ошибка("  %+v \n", err)
			}
			поток.Write(отправить)
		} else {
			Ошибка("  %+v \n", статус)
		}
		return
	}

	// if ошибкаСервиса.Код != Ок {
	// 	Ошибка(" Генерируем сообщение ощибки или возвращаем сообщение ошибки %+v \n", err)
	// 	ответ := сообщение.Ответ[Сервис]
	// 	ответ.Сервис = Сервис
	// 	ответ.ТипОтвета = Error
	// 	if ответ.ОшибкаСервиса.Код == Ок { // если какойто из обработчиков вернул ошибку, отличную от той которая записана в исходном сообщении то заменяем ошибку
	// 		ответ.ОшибкаСервиса = ошибкаСервиса
	// 	}

	// 	// if ответ.Данные != nil {
	// 	// 	// если в данных уже есть какаято инфа, заполенная одной из функций , то добавим ошбку
	// 	// 	ответ.Данные.(map[string]string)["error"] = err.Error()
	// 	// } else {
	// 	// 	ответ.Данные = err
	// 	// }

	// 	ответ.ЗапросОбработан = true
	// 	сообщение.Ответ[Сервис] = ответ
	// } else {

	// }

	// отправить, err := Кодировать(сообщение)
	// if err != nil {
	// 	Ошибка("  %+v \n", err)
	// }
	// поток.Write(отправить)

}

func Авторизация(сообщение *Сообщение) (bool, string, error) {
	форма := сообщение.Запрос.Форма
	if len(форма) > 0 {
		var логин, пароль []string

		if логин = форма["login"]; len(логин) > 0 && логин[0] == "" {
			return false, "", errors.New("нет логина")
		}
		if пароль = форма["password"]; len(пароль) > 0 && пароль[0] == "" {
			return false, "", errors.New("нет пароля")
		}

		status, токен, email, err := ПроверитьДанныеВБД(сообщение.ИдКлиента.String(), логин[0], пароль[0])
		if err != nil {
			return status, "", err
		}
		сообщение.ТокенКлиента = токен
		JWT, ошибкаПодписи := СоздатьJWT(токен)
		if ошибкаПодписи.Код != Ок {
			Ошибка(" не удалось создать токен  %+v \n", err)

			return false, "", err
		}

		сообщение.JWT = JWT

		return status, email, nil
	} else {
		return false, "", errors.New("нет данных для авторизации, логин и пароль обязательны")
	}
}

func ОтправитьПроверочныйКод(сообщение *Сообщение, email string) {
	Инфо(" ОтправитьПроверочныйКод ? отправялем сообщение на почту или смс %+v \n")

	// в сообщение в ответ добавляем токен для сверки с кодом, который будет подставлен в форму подтверждения
	ответ := сообщение.Ответ[Сервис]
	токенВерификации := СоздатьТокенОбновления(16)
	ответ.Данные = map[string]string{
		"токенВерификации": токенВерификации,
	}
	ответ.Сервис = Сервис
	ответ.ЗапросОбработан = true

	проверочныйКод := СгенерироватьПроверочныйКод(6)
	СохранитьКодАвторизации(email, сообщение.ИдКлиента.String(), проверочныйКод, токенВерификации)

	сообщение.Ответ[Сервис] = ответ

	go ОтправитьEmail([]string{email}, "Проверочный код", "Введите проверочный код на странице атворизации "+проверочныйКод)

}

func ПроверитьЛогин(сообщение *Сообщение) (bool, ОшибкаСервиса) {
	логин := сообщение.Запрос.Форма["Логин"][0]
	ok, ошибкаСервиса := ЛогинСвободен(логин)
	if ошибкаСервиса.Код != Ок {
		Ошибка("  %+v \n", ошибкаСервиса)
	}
	Инфо(" ЛогинСвободен ок  %+v \n", ошибкаСервиса)

	ответ := сообщение.Ответ[Сервис]
	ответ.ОшибкаСервиса = ошибкаСервиса
	ответ.Данные = map[string]string{
		"Статус": "Логин свободен",
	}
	сообщение.Ответ[Сервис] = ответ
	return ok, ошибкаСервиса
}

func ЛогинСвободен(логин string) (bool, ОшибкаСервиса) {
	Инфо("ПроверитьЛогин , нужно проверить логин на свободу \n")

	данные, ошибка := БазаДанных.Найти("Логин", логин)

	if ошибка.Код == ОшибкаКлючНеНайден {
		Инфо("  %+v  %+v \n", данные, ошибка)
		return true, ОшибкаСервиса{
			Код:   Ок,
			Текст: "Логин свободен",
		}
	} else if ошибка.Код == Ок {
		Инфо("  %+v  %+v \n", данные, ошибка)
		if len(данные) > 0 {
			return false, ОшибкаСервиса{
				Код:   Прочее,
				Текст: "Логин занят",
			}
		}
		return false, ОшибкаСервиса{
			Код:   Прочее,
			Текст: "Логин занят",
		}
	}
	Инфо("  %+v  %+v \n", данные, ошибка)
	return true, ОшибкаСервиса{
		Код:   Ок,
		Текст: "Логин свободен",
	}
}

func ПроверитьEmail(сообщение *Сообщение) (bool, ОшибкаСервиса) {
	email := сообщение.Запрос.Форма["Email"][0]
	ok, ошибкаСервиса := EmailСвободен(email)
	if ошибкаСервиса.Код != Ок {
		Ошибка("  %+v \n", ошибкаСервиса)
	}
	ответ := сообщение.Ответ[Сервис]
	ответ.ОшибкаСервиса = ошибкаСервиса
	ответ.Данные = map[string]string{
		"Статус": "Email свободен",
	}
	сообщение.Ответ[Сервис] = ответ
	Инфо(" EmailСвободен ок  %+v \n", ошибкаСервиса)
	return ok, ошибкаСервиса
}

func EmailСвободен(email string) (bool, ОшибкаСервиса) {

	данные, ошибка := БазаДанных.Найти("Email", email)
	if ошибка.Код == ОшибкаКлючНеНайден {
		Инфо("  %+v  %+v \n", данные, ошибка)
		return true, ОшибкаСервиса{
			Код:   Ок,
			Текст: "Email свободен",
		}
	} else if ошибка.Код == Ок {
		Инфо("  %+v  %+v \n", данные, ошибка)
		if len(данные) > 0 {
			return false, ОшибкаСервиса{
				Код:   Прочее,
				Текст: "Email занят",
			}
		}
		return false, ОшибкаСервиса{
			Код:   Прочее,
			Текст: "Email занят",
		}
	}
	Инфо("  %+v  %+v \n", данные, ошибка)
	return true, ОшибкаСервиса{
		Код:   Ок,
		Текст: "Email свободен",
	}
}

func ПроверитьКод(сообщение *Сообщение) (bool, error) {
	Инфо("ПроверитьКод , нужно проверить отправленный смс код или код на email \n")
	файл, err := os.ReadFile("authCode/" + сообщение.ИдКлиента.String())
	if err != nil {
		Ошибка("  %+v \n", err)
	}
	// кодПроверки := map[string]string{
	// 	токенВерификации: проверочныйКод,
	// 	"email":          email,
	// }
	кодПроверки := make(map[string]string)
	json.Unmarshal(файл, &кодПроверки)

	форма := сообщение.Запрос.Форма
	токенВерификации, естьТокен := форма["token"]
	if !естьТокен || len(токенВерификации) < 1 {
		Ошибка(" Нет токена верификации в данных формы %+v \n", форма)
	}
	код, естьКод := форма["code"]
	if !естьКод || len(код) < 1 {
		Ошибка(" Нет кода подтверждения в данных формы %+v \n", форма)
	}

	if СохранённыйКод, есть := кодПроверки[токенВерификации[0]]; есть {
		if СохранённыйКод == код[0] {

			ответ := сообщение.Ответ[Сервис]
			ответ.Сервис = Сервис
			ответ.ЗапросОбработан = true
			ответ.Данные = map[string]string{
				"статусПроверкиКода": "Проверочный код верный",
			}

			return true, nil
		} else {
			if кодПроверки["email"] != "" {
				//
				ОтправитьПроверочныйКод(сообщение, кодПроверки["email"])
			}

		}
	}

	return true, nil
}

/*
принимает массив искомого поля формы, возвращает значение первого попавшегося значения даже если их несколько
*/
func ПолучитьЗначениеПоляФормы(вариантИмениПоля []string, форма map[string][]string) (string, ОшибкаСервиса) {
	for _, имяПоля := range вариантИмениПоля {
		значение, есть := форма[имяПоля]
		if есть {
			if len(значение) == 1 {
				return значение[0], ОшибкаСервиса{
					Код: Ок,
				}
			} else {
				return "", ОшибкаСервиса{
					Код:   БолееОдногоЗначения,
					Текст: "Более одного значения в поле формы " + имяПоля,
				}
			}
		}
		return "", ОшибкаСервиса{
			Код:   ПустоеПолеФормы,
			Текст: "Пустое Поле Формы " + имяПоля,
		}
	}
	return "", ОшибкаСервиса{
		Код:   ПустоеПолеФормы,
		Текст: "Нет полей для поиска",
	}
}

func ПолучитьЗначениЯПоляФормы(имяПоля string, форма map[string][]string) ([]string, ОшибкаСервиса) {
	значение, есть := форма[имяПоля]
	if есть {
		if len(значение) > 0 {
			return значение, ОшибкаСервиса{
				Код: Ок,
			}
		} else {
			return nil, ОшибкаСервиса{
				Код:   ПустоеПолеФормы,
				Текст: "Пустое Поле Формы " + имяПоля,
			}
		}
	}
	return nil, ОшибкаСервиса{
		Код:   ПустоеПолеФормы,
		Текст: "Пустое Поле Формы " + имяПоля,
	}
}

func ПроверитьДанныеВБД(ИдКлиента string, логин string, пароль string) (bool, ТокенКлиента, string, error) {
	файл, err := os.ReadFile("users/" + ИдКлиента)
	if err != nil {
		Ошибка("  %+v \n", err)
	}
	var данныеКлиента ДанныеКлиента
	json.Unmarshal(файл, &данныеКлиента)

	клиент := данныеКлиента.Данные
	if клиент["login"][0] != логин {
		Ошибка("  %+v \n", err)
		return false, ТокенКлиента{}, "", errors.New("Неверный логин")
	}
	if клиент["password"][0] != пароль {
		Ошибка("  %+v \n", err)
		return false, ТокенКлиента{}, "", errors.New("Неверный пароль")
	}

	// токен := данныеКлиента.JWT
	// токен.Токен = СоздатьТокенОбновления(16)
	// токен.Истекает = time.Now().Add(60 * time.Minute).Unix()
	// токен.Создан = time.Now().Unix()

	if клиент["email"][0] == "" {
		Ошибка("  %+v \n", err)
		return false, ТокенКлиента{}, "", errors.New("Не задан email")
	}

	return true, токен, клиент["email"][0], nil

}

func ПреобразоватьДанныеКлиентаВДокументБД(данныеКлиента ДанныеКлиента) *Документ {
	return &Документ{
		Данные: map[string]interface{}{
			"ИдКлиента":       данныеКлиента.ИдКлиента,
			"Логин":           данныеКлиента.Логин,
			"Пароль":          данныеКлиента.Пароль,
			"Email":           данныеКлиента.Email,
			"Роль":            данныеКлиента.Роль,
			"Права":           данныеКлиента.Права,
			"ТокенОбновления": данныеКлиента.ТокенОбновления,
			"JWT":             данныеКлиента.JWT,
		},
	}
}

func СохранитьКлиентаВБД(новыйКлиент ДанныеКлиента) ОшибкаСервиса {

	ошибкаБазы := БазаДанных.ВставитьДокумент(ПреобразоватьДанныеКлиентаВДокументБД(новыйКлиент), false)
	if ошибкаБазы.Код != Ок {
		return ОшибкаСервиса{
			Код:   ошибкаБазы.Код,
			Текст: ошибкаБазы.Текст,
		}
	}
	return ОшибкаСервиса{
		Код:   Ок,
		Текст: "успешная запись",
	}
}

func СохранитьКодАвторизации(email string, ИдКлиента string, проверочныйКод string, токенВерификации string) error {

	кодПроверки := map[string]string{
		токенВерификации: проверочныйКод,
		"email":          email,
	}

	данныеДляСохранения, err := json.Marshal(кодПроверки)
	if err != nil {
		Ошибка("  %+v \n", err)
		return err
	}
	err = os.WriteFile("authCode/"+ИдКлиента, данныеДляСохранения, 0644)
	if err != nil {
		Ошибка("  %+v \n", err)
		return err
	}
	return nil
}
func ОтправитьEmail(кому []string, тема string, тело string) error {
	from := "79880970078@ya.ru"
	password := "Satori@27$"
	smtpHost := "smtp.yandex.ru"
	smtpPort := "465"

	auth := smtp.PlainAuth("", from, password, smtpHost)

	msg := []byte("To: " + кому[0] + "\r\n" +
		"Subject: " + тема + "\r\n" +
		"\r\n" +
		тело + "\r\n")

	err := smtp.SendMail(smtpHost+":"+smtpPort, auth, from, кому, msg)
	if err != nil {
		return err
	}

	return nil
}
func СгенерироватьПроверочныйКод(КоличествоСимволов int) string {
	код, err := rand.Int(
		rand.Reader,
		big.NewInt(int64(math.Pow(10, float64(КоличествоСимволов)))),
	)
	if err != nil {
		panic(err)
	}

	str := код.String()
	if len(str) < КоличествоСимволов {
		str = "0" + str
	}
	return str
}
