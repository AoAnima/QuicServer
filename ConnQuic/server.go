package ConnQuic

import (
	"encoding/binary"
	"io"
	"sync"
	"time"

	. "aoanima.ru/Logger"
	. "aoanima.ru/QErrors"
	quic "github.com/quic-go/quic-go"
)

// функция вызывается в сервисе  для отправки ответа в поток, а ну наверно ето же самое можно и на стороне сервера вызывать для отправки сообщения клиенту..... имеет значение только сторона с которой идет запись в поток
func ОтправитьСообщение(поток quic.Stream, сообщение Сообщение) СтатусСервиса {

	сообщениеВОтправку, err := Кодировать(сообщение)
	if err != nil {
		Ошибка("  %+v \n", err)
		return СтатусСервиса{
			Код:   ОшибкаJSONКодирования,
			Текст: err.Error(),
		}
	}
	отправленно, err := поток.Write(сообщениеВОтправку)
	if err != nil {
		Ошибка(" %+v ", err)
		return СтатусСервиса{
			Код:   ОшибкаЗаписиВПоток,
			Текст: err.Error(),
		}
	} else {
		Инфо("отправленно %+v байт; сообщение: %+v; \n поток %+v \n", отправленно, string(сообщениеВОтправку), поток.StreamID())
	}
	return СтатусСервиса{
		Код: Ок,
	}
}

// Читаем ответы от сервсо
func ЧитатьСообщения(поток quic.Stream, каналСообщения chan Сообщение) {

	длинаСообщения := make([]byte, 4)
	var прочитаноБайт int
	var err error
	for {

		// Инфо("  читаю из поток %+v \n", поток.StreamID())
		прочитаноБайт, err = поток.Read(длинаСообщения)

		// Инфо(" длинаСообщения %+v , прочитаноБайт %+v \n", длинаСообщения, прочитаноБайт)
		if err != nil {
			Ошибка(" прочитаноБайт %+v  err %+v поток %+v \n", прочитаноБайт, err, поток.StreamID())
			break
		}
		// получаем число байткоторое нужно прочитать
		длинаДанных := binary.LittleEndian.Uint32(длинаСообщения)
		буферСообщения := make([]byte, длинаДанных)
		прочитаноБайт, err := io.ReadFull(поток, буферСообщения)
		// прочитаноБайт, err = поток.Read(сообщениеБинарное)
		if err != nil {
			Ошибка("Ошибка при десериализации структуры: %+v ", err)
		}
		if длинаДанных != uint32(прочитаноБайт) {
			Ошибка("Количество прочитаных байт не ранво длине данных :\n длинаДанных %+v  <> прочитаноБайт %+v ", длинаДанных, прочитаноБайт)
		} else {
			сообщение, err := ДекодироватьПакет(буферСообщения)
			if err != nil {
				Ошибка("  %+v  поток.StreamID()  %+v \n", err.Error(), поток.StreamID())
			} else {
				каналСообщения <- сообщение
			}
		}
		// Инфо(" продолжаем читать из потока  %+v \n", поток)
	}
}

/*
func ЧитатьСообщениеИзПотока(поток quic.Stream) Сообщение {
	меткаВремени := time.Now()
	Инфо("  Читаем из потока  %+v - поток № %+v \n", меткаВремени, поток.StreamID())
	длинаСообщения := make([]byte, 4)
	var прочитаноБайт int
	var err error

	прочитаноБайт, err = поток.Read(длинаСообщения)
	// Инфо(" длинаСообщения %+v , прочитаноБайт %+v \n", длинаСообщения, прочитаноБайт)
	if err != nil {
		Ошибка(" прочитаноБайт %+v  err %+v \n", прочитаноБайт, err)
		return Сообщение{}
	}
	// получаем число байткоторое нужно прочитать
	длинаДанных := binary.LittleEndian.Uint32(длинаСообщения)

	// Инфо(" длинаДанных %+v  \n", длинаДанных)
	Инфо(" %+v Читаем из потока  %+v длинаДанных %+v \n", меткаВремени, поток.StreamID(), длинаДанных)

	сообщениеБинарное := make([]byte, длинаДанных)

	прочитаноБайт, err = поток.Read(сообщениеБинарное)
	if err != nil {
		Ошибка("Ошибка при десериализации структуры: %+v ", err)
		return Сообщение{}
	}

	// Инфо(" длинаСообщения %+v , прочитаноБайт %+v \n", длинаСообщения, прочитаноБайт)

	if длинаДанных != uint32(прочитаноБайт) {

		Ошибка("%+v  Количество прочитаных байт не ранво длине данных :\n длинаДанных %+v  <> прочитаноБайт %+v \n %+v \n поток StreamID %+v ", меткаВремени, длинаДанных, прочитаноБайт, string(сообщениеБинарное), поток.StreamID())

		return Сообщение{}
	} else {
		сообщение, err := ДекодироватьПакет(сообщениеБинарное)
		// Инфо(" сообщение %+v \n", сообщение)
		if err != nil {
			Ошибка("  %+v  %+v \n", err, сообщение)
			return Сообщение{}
		} else {
			return сообщение
		}
	}
}*/
/*
func ЧитатьСообщениеВБуфер(поток quic.Stream) Сообщение {
	меткаВремени := time.Now()
	Инфо("  Читаем из потока  %+v - поток № %+v \n", меткаВремени, поток.StreamID())
	длинаСообщения := make([]byte, 4)
	var прочитаноБайт int
	var err error

	прочитаноБайт, err = поток.Read(длинаСообщения)
	// Инфо(" длинаСообщения %+v , прочитаноБайт %+v \n", длинаСообщения, прочитаноБайт)
	if err != nil {
		Ошибка(" прочитаноБайт %+v  err %+v \n", прочитаноБайт, err)
		return Сообщение{}
	}
	// получаем число байткоторое нужно прочитать
	длинаДанных := binary.LittleEndian.Uint32(длинаСообщения)

	// Инфо(" длинаДанных %+v  \n", длинаДанных)
	Инфо(" %+v Читаем из потока  %+v длинаДанных %+v \n", меткаВремени, поток.StreamID(), длинаДанных)

	буферСообщения := []byte{}
	ВсегоПрочитаноБайт := 0

	for ВсегоПрочитаноБайт != int(длинаДанных) {

		партияСообщения := make([]byte, int(длинаДанных)-ВсегоПрочитаноБайт)
		Инфо("создал буфер размером партияСообщения  %+v \n", len(партияСообщения))
		прочитано, err := поток.Read(партияСообщения)

		if err != nil {
			Ошибка("Ошибка при чтении из потока: %+v %+v %+s прочитано %+v", err, поток, партияСообщения, прочитано)
			return Сообщение{}
		}

		ВсегоПрочитаноБайт += прочитано

		буферСообщения = append(буферСообщения, партияСообщения[:прочитано-1]...)

		Инфо(" ВсегоПрочитаноБайт %+v ; буферСообщения %+s размер %+v \n партияСообщения %+v ; len(партияСообщения)  %+s ; должно быть длинаДанных %+s\n", ВсегоПрочитаноБайт, буферСообщения, len(буферСообщения), партияСообщения, len(партияСообщения), длинаДанных)

		Инфо("  %v \n", поток)

	}

	// Инфо(" длинаСообщения %+v , прочитаноБайт %+v \n", длинаСообщения, прочитаноБайт)

	if длинаДанных != uint32(ВсегоПрочитаноБайт) {

		Ошибка("%+v  Количество прочитаных байт не ранво длине данных :\n длинаДанных %+v  <> прочитаноБайт %+v \n %+v \n поток StreamID %+v ", меткаВремени, длинаДанных, прочитаноБайт, string(буферСообщения), поток.StreamID())

		return Сообщение{}
	} else {
		сообщение, err := ДекодироватьПакет(буферСообщения)

		if err != nil {
			Ошибка("  %+v  %+v %+s \n", err, сообщение, буферСообщения)
			return Сообщение{}
		} else {
			if сообщение.Пинг || сообщение.Понг {
				return сообщение
			} else {
				Инфо(" сообщение %+v \n", сообщение)
				return сообщение
			}

		}
	}
}*/
func ЧитатьСообщение(поток quic.Stream, имяСервиса string) Сообщение {
	меткаВремени := time.Now()
	Инфо("имяСервиса  %+v  Читаем из потока  %+v - поток № %+v \n", имяСервиса, меткаВремени, поток.StreamID())
	длинаСообщения := make([]byte, 4)
	var прочитаноБайт int
	var err error

	прочитаноБайт, err = поток.Read(длинаСообщения)
	// Инфо(" длинаСообщения %+v , прочитаноБайт %+v \n", длинаСообщения, прочитаноБайт)
	if err != nil {
		Ошибка(" прочитаноБайт %+v  err %+v \n", прочитаноБайт, err)
		return Сообщение{}
	}
	// получаем число байткоторое нужно прочитать
	длинаДанных := binary.LittleEndian.Uint32(длинаСообщения)

	// Инфо(" длинаДанных %+v  \n", длинаДанных)
	Инфо("имяСервиса %+v  %+v Читаем из потока  %+v длинаДанных %+v \n", имяСервиса, меткаВремени, поток.StreamID(), длинаДанных)

	if длинаДанных > 30000 {
		Ошибка("не кореектная длинаДанных %+v прочитанные данные: %+s ;\n", длинаДанных, длинаСообщения)

		return Сообщение{}
	}

	буферСообщения := make([]byte, длинаДанных)

	прочитано, err := io.ReadFull(поток, буферСообщения)
	if err != nil {
		Ошибка("  %+v \n", err)
	}
	// буферСообщения := []byte{}
	// ВсегоПрочитаноБайт := 0

	// for ВсегоПрочитаноБайт != int(длинаДанных) {

	// 	партияСообщения := make([]byte, int(длинаДанных)-ВсегоПрочитаноБайт)
	// 	Инфо("создал буфер размером партияСообщения  %+v \n", len(партияСообщения))
	// 	прочитано, err := поток.Read(партияСообщения)

	// 	if err != nil {
	// 		Ошибка("Ошибка при чтении из потока: %+v %+v %+s прочитано %+v", err, поток, партияСообщения, прочитано)
	// 		return Сообщение{}
	// 	}

	// 	ВсегоПрочитаноБайт += прочитано

	// 	буферСообщения = append(буферСообщения, партияСообщения[:прочитано-1]...)

	// 	Инфо(" ВсегоПрочитаноБайт %+v ; буферСообщения %+s размер %+v \n партияСообщения %+v ; len(партияСообщения)  %+s ; должно быть длинаДанных %+s\n", ВсегоПрочитаноБайт, буферСообщения, len(буферСообщения), партияСообщения, len(партияСообщения), длинаДанных)

	// 	Инфо("  %v \n", поток)

	// }

	// Инфо(" длинаСообщения %+v , прочитаноБайт %+v \n", длинаСообщения, прочитаноБайт)

	if длинаДанных != uint32(прочитано) {

		Ошибка("%+v  Количество прочитаных байт не ранво длине данных :\n длинаДанных %+v  <> прочитаноБайт %+v \n %+v прочитано %+v \n поток StreamID %+v ", меткаВремени, длинаДанных, прочитаноБайт, string(буферСообщения), прочитано, поток.StreamID())

		return Сообщение{}
	} else {
		сообщение, err := ДекодироватьПакет(буферСообщения)

		if err != nil {
			Ошибка("  %+v  %+v %+s \n", err, сообщение, буферСообщения)
			return Сообщение{}
		} else {
			if сообщение.Пинг || сообщение.Понг {
				return сообщение
			} else {
				Инфо(" сообщение %+v \n", сообщение)
				return сообщение
			}

		}
	}
}

var АктивныеHTTPСесии = make(map[НомерСессии]HTTPСессии)

type HTTPСессии struct {
	Блок       *sync.RWMutex
	Соединение quic.Connection
	Потоки     []quic.Stream
}

func ПульсСессии() {
	Инфо(" Реализовать периодическую проверку сессий, и очустку отвалившихся %+v \n", "ПульсСессии")
}

var АктивныеСессии = make(КартаСервисов)

var БлокКартыОбработчиков = sync.RWMutex{}
var КартаОбработчиков = make(map[Маршрут]ИмяСервиса)

// ДОДЕЛАТЬ: Не сделан ресистратор маршрутов по сообщению полученному от сервиса
func РегистрацияСервиса(сессия quic.Connection, поток quic.Stream, сообщение *Сообщение) {

	// Создвём новую очередь потоков,
	очередьПотоков := НоваяОчередьПотоков()
	// открываем исходящий поток,
	исходящийПоток, err := сессия.OpenStream()
	if err != nil {
		Ошибка("  %+v \n", err)
	}
	// добавляем его в очередь
	очередьПотоков.Добавить(исходящийПоток)
	//системный потом кладём в отдлельное поле карты, из него данные читаються постоянно

	новаяСессия := КартаСессий{
		Соединение:     сессия,
		ОчередьПотоков: очередьПотоков,
		СистемныйПоток: поток,
	}

	// Если в активных сессиях есть подключения с сервисом, то добавляем в карту этого сервиса новыую сессию
	if _, ok := АктивныеСессии[сообщение.Сервис]; ok {
		БлокКартаСервисов.Lock()
		// АктивныеСессии[сообщение.Сервис] = append(АктивныеСессии[сообщение.Сервис], новаяСессия)
		АктивныеСессии[сообщение.Сервис].Сессии[НомерСессии(len(АктивныеСессии[сообщение.Сервис].Сессии))] = новаяСессия
		БлокКартаСервисов.Unlock()

	} else {

		БлокКартаСервисов.Lock()
		// АктивныеСессии[сообщение.Сервис] = []КартаСессий{новаяСессия}
		новыйСервис := struct {
			Блок           *sync.RWMutex
			Сессии         map[НомерСессии]КартаСессий
			НеПолныеСессии map[НомерСессии]int
		}{
			Блок:           &sync.RWMutex{},
			Сессии:         make(map[НомерСессии]КартаСессий),
			НеПолныеСессии: make(map[НомерСессии]int),
		}

		новыйСервис.Сессии[НомерСессии(1)] = новаяСессия
		АктивныеСессии[сообщение.Сервис] = новыйСервис
		БлокКартаСервисов.Unlock()
		БлокКартыОбработчиков.RLock()
		for _, маршрут := range сообщение.Маршруты {
			КартаОбработчиков[маршрут] = сообщение.Сервис
		}
		БлокКартыОбработчиков.RUnlock()
	}
	Инфо("КартаОбработчиков  %+v \n", КартаОбработчиков)
	Инфо(" Активные соединения  %+v \n", АктивныеСессии)
	ПульсСессии()
}

// ! ЧитатьСистемныйПоток принимает Один Поток от клиента, ичитает из него сообщения
// func ЧитатьСистемныйПоток(сессия quic.Connection) {

// 	поток, err := сессия.AcceptStream(context.Background())
// 	if err != nil {
// 		Ошибка("  %+v \n", err)
// 	}
// 	// получается читаем постоянно системый поток,
// 	// ЧитатьСообщения(сессия, поток, ОбработчикСистемныхСообщений)

// 	// каналСооб/щений := make(chan Сообщение, 5)
// 	// Читаем данные из потока , декодируем и возвращаем в канал
// 	go ЧитатьСообщения(поток, каналСообщений)
// 	// читаем из канала сообщения и отправляем в обработчик
// 	for сообщение := range каналСообщений {
// 		if сообщение.Регистрация {
// 			if сообщение.Сервис == "КлиентСервер" {
// 				РегистрацияHTTPсервера(сессия, поток, &сообщение)
// 			} else {
// 				РегистрацияСервиса(сессия, поток, &сообщение)
// 			}

// 		} else {
// 			ОбработчикСистемныхСообщений(поток, сообщение)
// 		}
// 	}
// }

// ! ОбработчикСессии запускается когда происходит новое соединение,
// ! Открывает один поток и запускает ЧтениеСообщений из потока,... но зачем???
// !  Нудно просто создать один исходящий поток, и положить его  в очередь, и всё. Запуск ЧтенияСообщений будет происхдить после отправки сообщения в клиент. В Данный момент больше не нужно ничего делать
// func ОбработчикСессии(сессия quic.Connection, обработчикСообщений func(поток quic.Stream, сообщение Сообщение), ОбработчикСистемныхСОобщений func(поток quic.Stream, сообщение Сообщение)) {

// 	// for {
// 	поток, err := сессия.OpenStream()

// 	if err != nil {
// 		Ошибка(" %+v ", err)
// 	}

// 	// go ЧитатьСообщения(сессия, поток, обработчикСообщений) // Ждём ответа от клиента

// 	// }
// }

/**
Читаем мы сообщение из поток, в надежде что это будет ответ на запрос а не другое сообщение, значит по завершинии нужно завершать работу Функции

*/

// func ЧитатьСообщения(сессия quic.Connection, поток quic.Stream, обработчикСообщений func(поток quic.Stream, сообщение Сообщение)) {

// 	длинаСообщения := make([]byte, 4)
// 	var прочитаноБайт int
// 	var err error
// 	for {
// 		прочитаноБайт, err = поток.Read(длинаСообщения)
// 		Инфо(" длинаСообщения %+v , прочитаноБайт %+v \n", длинаСообщения, прочитаноБайт)
// 		if err != nil {
// 			Ошибка(" прочитаноБайт %+v  err %+v \n", прочитаноБайт, err)
// 			break
// 		}
// 		// получаем число байткоторое нужно прочитать
// 		длинаДанных := binary.LittleEndian.Uint32(длинаСообщения)
// 		сообщениеБинарное := make([]byte, длинаДанных)
// 		прочитаноБайт, err = поток.Read(сообщениеБинарное)
// 		if err != nil {
// 			Ошибка("Ошибка при десериализации структуры: %+v ", err)
// 		}
// 		if длинаДанных != uint32(прочитаноБайт) {
// 			Ошибка("Количество прочитаных байт не ранво длине данных :\n длинаДанных %+v  <> прочитаноБайт %+v ", длинаДанных, прочитаноБайт)
// 		} else {
// 			сообщение := ДекодироватьПакет(сообщениеБинарное)
// 			if сообщение.Регистрация {

// 				РегистрацияСервиса(сессия, nil, &сообщение)

// 			} else {
// 				//! функция которая передаёться в момент установления соединения, будет обрабатывать сообщения в соттветсвии с требованиями сервиса
// 				go обработчикСообщений(поток, сообщение)
// 			}

// 			// break
// 		}

// 		// каналПолученияСообщений <- пакетОтвета

// 	}

// }
