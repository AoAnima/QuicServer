package ConnQuic

import (
	"context"
	"crypto/tls"
	"crypto/x509"
	"encoding/binary"
	"log"
	"os"
	"sync"

	. "aoanima.ru/logger"
	quic "github.com/quic-go/quic-go"
)

// type КартаСессий struct {
//    sync.RWMutex
//		СессииСервисов  quic.Connection       // кладём соовтетсвие сессий и потоков
//		ОчередьПотоков *ОчередьПотоков // все потоки всех сессий кладём в одну очередь
//	}
/*
Создаём новый Серверв
сервер := &СхемаСервера{
			Имя:         "SynQuic",
			Адрес:       "localhost:4242",
			КартаСессий: КартаСессий{},
		}

Вызываем мтед Соединиться? в него передаёт сообщение для регистрации клиента на сервере , с перечнем маршрутов
Клиент.Соединиться(Адрес string, сообщениеРегистрации Сообщение)

После установки соединения открываем 1 поток, и отправляем в него сообщение, сервер регистрирует и отвечает что всё ок.
Этот поток не кладём в очередь потоков

Дальше сервер Открывает поток,


*/

// где string это адрес или имя сервиса.. лучше наверное адрес
type Сервер string
type СхемаСервера struct {
	Имя   Сервер
	Адрес string
	ДанныеСессии
}

type ДанныеСессии struct {
	*sync.RWMutex
	Сессия      quic.Connection
	Потоки      []quic.Stream
	СистемныйПоток quic.Stream // сохраним первый поток как сервисный, ля отправки каких то уведомлений... проверки загруженности или ещё что то
}

// Массив подключений, вдруг понадобится открыть несоклько подключений к одному серверу
type Клиент map[Сервер][]*СхемаСервера

// func (к Клиент) Соединиться(сервер СхемаСервера, обработчикСообщений func(поток quic.Stream, сообщение Сообщение)) {
func (к Клиент) Соединиться(сервер *СхемаСервера, сообщениеРегистрации Сообщение, ОбработчикЗапросовСервера func(поток quic.Stream, сообщение Сообщение)) {
	конфигТлс, err := клиентскийТлсКонфиг("root.crt")
	if err != nil {
		Ошибка("  %+v \n", err)
	}
	// Адрес = "localhost:4242"
	if сервер.Адрес == "" {
		сервер := &СхемаСервера{
			Имя:          "SynQuic",
			Адрес:        "localhost:4242",
			ДанныеСессии: ДанныеСессии{},
		}
		к["SynQuic"] = append(к["SynQuic"], сервер)
	}

	сессия, err := quic.DialAddr(context.Background(), сервер.Адрес, конфигТлс, &quic.Config{})
	// Добавляем сессию соединения с сервером в карту сессий
	сервер.ДанныеСессии.Сессия = сессия
	// слушаем запрос на открытиые потока от сервера
	go сервер.ДанныеСессии.ОжиданиеОткрытияПотока(ОбработчикЗапросовСервера)
	if err != nil {
		log.Fatal(err)
	}

	// к.Сессии = append(к.Сессии, &сессия)
	// к.Блок.RUnlock()
	// for {

	// поток, err := сессия.AcceptStream(context.Background())
	// этот поток не добавляем в очередь потоков, в него мы писать ничгео не будем в адльнейшем, отпраавляем сейчас только регистрационное сообщение с маршрутами котоые обрабатывает сервис
	поток, err := сессия.OpenStream()
	if err != nil {
		Ошибка("  %+v \n", err)
	}
	// сохраним первый поток как сервисный, ля отправки каких то уведомлений... проверки загруженности или ещё что то
	сервер.ДанныеСессии.СистемныйПоток = поток
	сбин, err := Кодировать(сообщениеРегистрации)
	поток.Write(сбин)

	if err != nil {
		Ошибка("  %+v \n", err)
	}
	//статусРегистрации функция которая поверяет что ответил сервер на сообщение регистраии сервиса
	сервер.ДанныеСессии.ЧитатьСообщение(поток, статусРегистрации)

	// }
}

func (данныеСессий ДанныеСессии) ОжиданиеОткрытияПотока(ОбработчикЗапросовСервера func(поток quic.Stream, сообщение Сообщение)) {
	for {
		// принимаем запрос на открытиые потока, и добавляем его в очередь потоков
		поток, err := данныеСессий.Сессия.AcceptStream(context.Background())
		if err != nil {
			Ошибка("  %+v \n", err)
		}
		//! если это клиент, то хачем мне хранить потоки на клиенте в очереди, клиент не будет сам отправлять серверу сообщения...
		//! можно не закрывать первый поток, пометив его например как системный, тоесть через него клиент будет отправлет какието уведомления серверу.
		//!
		go данныеСессий.ЧитатьСообщение(поток, ОбработчикЗапросовСервера)
		данныеСессий.Потоки = append(данныеСессий.Потоки, поток)
	}
}

func статусРегистрации(поток quic.Stream, сообщение Сообщение) {

	Инфо(" статусРегистрации %+v \n", сообщение)

	if len(сообщение.Ответ) > 0 {
		for сервис, данные := range сообщение.Ответ {
			Инфо("сервис  %+v данные  %+v \n", сервис, данные)
		}
	}

}

func (данныеСессий ДанныеСессии) ЧитатьСообщение(поток quic.Stream, обработчикСообщений func(поток quic.Stream, сообщение Сообщение)) {

	длинаСообщения := make([]byte, 4)
	var прочитаноБайт int
	var err error

	for {
		прочитаноБайт, err = поток.Read(длинаСообщения)
		Инфо(" длинаСообщения %+v , прочитаноБайт %+v \n", длинаСообщения, прочитаноБайт)

		if err != nil {
			Ошибка(" прочитаноБайт %+v  err %+v \n", прочитаноБайт, err)
			break
		}

		// получаем число байткоторое нужно прочитать
		длинаДанных := binary.LittleEndian.Uint32(длинаСообщения)

		Инфо(" длинаДанных  %+v \n", длинаДанных)
		Инфо(" длинаСообщения %+v ,  \n прочитаноБайт %+v ,  \n длинаДанных %+v \n", длинаСообщения,
			прочитаноБайт, длинаДанных)

		//читаем количество байт = длинаСообщения
		// var запросКлиента ЗапросКлиента
		сообщениеБинарное := make([]byte, длинаДанных)
		прочитаноБайт, err = поток.Read(сообщениеБинарное)
		if err != nil {
			Ошибка("Ошибка при десериализации структуры: %+v ", err)
		}

		if длинаДанных != uint32(прочитаноБайт) {
			Ошибка("Количество прочитаных байт не ранво длине данных :\n длинаДанных %+v  <> прочитаноБайт %+v ", длинаДанных, прочитаноБайт)
		} else {

			сообщение := ДекодироватьПакет(сообщениеБинарное)

			go обработчикСообщений(поток, сообщение)

			// break
		}
		// каналПолученияСообщений <- пакетОтвета

	}

}

func клиентскийТлсКонфиг(caCertFile string) (*tls.Config, error) {
	caCert, err := os.ReadFile(caCertFile)
	if err != nil {
		return nil, err
	}

	caCertPool := x509.NewCertPool()
	caCertPool.AppendCertsFromPEM(caCert)

	return &tls.Config{
		RootCAs:    caCertPool,
		NextProtos: []string{"http/1.1", "h2", "h3", "quic", "websocket"},
	}, nil
}
