package ConnQuic

import (
	"errors"
	"fmt"
	"sync"

	. "aoanima.ru/Logger"
	quic "github.com/quic-go/quic-go"
)

var БлокКартаСервисов sync.RWMutex
var МакимальноеКоличествоПотоковНаСессию = 100

type КартаСервисов map[ИмяСервиса]struct {
	Блок           *sync.RWMutex
	Сессии         map[НомерСессии]КартаСессий
	НеПолныеСессии map[НомерСессии]int // Количество открытых потоков в сессии
}

type НомерСессии int
type КартаСессий struct {
	Блок           *sync.RWMutex
	Соединение     quic.Connection
	ОчередьПотоков *ОчередьПотоков
	СистемныйПоток quic.Stream
}

// --- Очередь для работы с потоками и сессиями quic

type Поток struct {
	поток     quic.Stream
	следующий *Поток
}

type ОчередьПотоков struct {
	Блок       *sync.RWMutex
	Первый     *Поток
	Последний  *Поток
	Количество int // Количество открытых потоков в Сесии
}

func НоваяОчередьПотоков() *ОчередьПотоков {
	return &ОчередьПотоков{
		Блок:       &sync.RWMutex{},
		Первый:     nil,
		Последний:  nil,
		Количество: 0,
	}
}

type ПотокСессии struct {
	ИмяСервиса  ИмяСервиса
	НомерСессии НомерСессии
	Поток       quic.Stream
}

func (картаСервисов КартаСервисов) Вернуть(сервис ИмяСервиса, потокСессии ПотокСессии) {
	картаСервисов[сервис].Сессии[потокСессии.НомерСессии].ОчередьПотоков.Вернуть(потокСессии.Поток)
}

func (картаСервисов КартаСервисов) ПолучитьПоток(сервис ИмяСервиса) (ПотокСессии, error) {
	Инфо(" ПолучитьПоток - %+v \n", сервис)
	if сессииСервиса, есть := картаСервисов[сервис]; есть {
		// КоличествоАктивныхСессий := len(сессииСервиса)
		// НеПолныеСессии := make([]НомерСессии, len(картаСервисов))

		for номерСессии, сессия := range сессииСервиса.Сессии {
			if поток := сессия.ОчередьПотоков.Взять(); поток != nil {
				ПотокСессии := ПотокСессии{
					ИмяСервиса:  сервис,
					НомерСессии: номерСессии,
					Поток:       поток,
				}
				return ПотокСессии, nil
			}
		}

		// Если попали сюда значит нет свободных потоков в пуле потоков

		// Пройдём по не полным сессиям, откроем в первой сессии новый поток, если количество потоков меньше максимального, то вернём ПотокСессии, если количество потоков в сессии стало максимальным то удалим картуСессии из неПолныхСессий.
		if len(сессииСервиса.НеПолныеСессии) > 0 {
			for номерСессии := range сессииСервиса.НеПолныеСессии {
				новыйПоток, err := сессииСервиса.Сессии[номерСессии].Соединение.OpenStream()
				if err != nil {
					Ошибка(" НЕ УДАЛОСЬ ОТКРЫТЬ НОВЫЙ ПОТОК %+v \n", err)

				}
				сессииСервиса.Сессии[номерСессии].ОчередьПотоков.Добавить(новыйПоток)
				сессииСервиса.Сессии[номерСессии].ОчередьПотоков.Количество++

				if сессииСервиса.Сессии[номерСессии].ОчередьПотоков.Количество == МакимальноеКоличествоПотоковНаСессию {
					сессииСервиса.Блок.Lock()
					delete(сессииСервиса.НеПолныеСессии, номерСессии)
					сессииСервиса.Блок.Unlock()
				}
				ПотокСессии := ПотокСессии{
					ИмяСервиса:  сервис,
					НомерСессии: номерСессии,
					Поток:       новыйПоток,
				}
				return ПотокСессии, nil
			}
		} else {

			текстОшибки := fmt.Sprintf("Не возможно создать новый поток, количество потоков во всех сессиях  Достило максимально разрешённого: %+v ; нужно открыть новое соединение, либо дождаться осовбождения потоков", МакимальноеКоличествоПотоковНаСессию)

			return ПотокСессии{}, errors.New(текстОшибки)
		}

		// Если мы вышли сюда значит все очереди потоков пустые,
	} else {

		Ошибка("  %+v  %+v \n", картаСервисов, сервис)

	}

	текстОшибки := fmt.Sprintf("Не найдено соединение с %s", сервис)
	return ПотокСессии{}, errors.New(текстОшибки)
}

// func (картаСессий КартаСессий) Поток() (quic.Stream, error) {
// 	поток := картаСессий.ОчередьПотоков.Взять()
// 	if поток == nil {
// 		if картаСессий.ОчередьПотоков.Количество < МакимальноеКоличествоПотоковНаСессию {
// 			новыйПток, err := картаСессий.Соединение.OpenStream()
// 			if err != nil {
// 				Ошибка(" не удалось открыть новый поток %+v \n", err)
// 				return nil, err
// 			} else {
// 				картаСессий.ОчередьПотоков.Добавить(новыйПток)
// 				картаСессий.ОчередьПотоков.Количество++
// 				return новыйПток, nil
// 			}

// 		} else {
// 			СистемноеСообщение := СистемноеСообщение{
// 				Запрос: map[string]string{
// 					"КоличествоПотоков":             fmt.Sprint(картаСессий.ОчередьПотоков.Количество),
// 					"МаксимальноеКоличествоПотоков": fmt.Sprint(МакимальноеКоличествоПотоковНаСессию),
// 				},
// 				Сервис: "ОбработчикПотоков",
// 			}
// 			отправить, err := Кодировать(СистемноеСообщение)
// 			if err != nil {
// 				Ошибка("  %+v \n", err)
// 			}
// 			картаСессий.СистемныйПоток.Write(отправить)
// 		}
// 	}
// }

func (картаСессий КартаСессий) НовыйПоток() (quic.Stream, error) {
	if картаСессий.ОчередьПотоков.Количество < МакимальноеКоличествоПотоковНаСессию {
		новыйПток, err := картаСессий.Соединение.OpenStream()
		if err != nil {
			Ошибка(" не удалось открыть новый поток %+v \n", err)
			return nil, err
		} else {
			картаСессий.ОчередьПотоков.Добавить(новыйПток)
			картаСессий.ОчередьПотоков.Количество++
			return новыйПток, nil
		}
	} else {

		текстОшибки := fmt.Sprintf("Не возможно создать новый поток, количество потоков %+v Достило максимально разрешённого: %+v ; нужно открыть новое соединение, либо дождать осовбождения потоков", картаСессий.ОчередьПотоков.Количество, МакимальноеКоличествоПотоковНаСессию)

		return nil, errors.New(текстОшибки)
	}
}

func (очередь *ОчередьПотоков) Добавить(новыйПоток quic.Stream) {
	очередь.Вернуть(новыйПоток)
}
func (очередь *ОчередьПотоков) Вернуть(новыйПоток quic.Stream) {
	очередь.Блок.RLock()
	поток := &Поток{поток: новыйПоток}
	if очередь.Последний == nil {
		очередь.Первый = поток
		очередь.Последний = поток
	} else {
		очередь.Последний.следующий = поток
		очередь.Последний = поток
	}
	// очередь.Количество++
	очередь.Блок.RUnlock()
}

func (очередь *ОчередьПотоков) Взять() quic.Stream {
	очередь.Блок.RLock()
	defer очередь.Блок.RUnlock()
	if очередь.Пусто() {
		Инфо(" пусто в очереди  %+v очередь.Первый %+v \n", очередь, очередь.Первый)
		return nil
	}
	очереднойЭлемент := очередь.Первый.поток
	очередь.Первый = очередь.Первый.следующий
	if очередь.Первый == nil {
		очередь.Последний = nil
	}
	// очередь.Количество--
	return очереднойЭлемент
}

func (очередь *ОчередьПотоков) Пусто() bool {
	return очередь.Первый == nil
}

// type ОчередьПотоковКанал struct {
// 	Потоки chan quic.Stream
// }

// func НоваяОчередьПотоковКанал(размер int) *ОчередьПотоковКанал {
// 	return &ОчередьПотоковКанал{
// 		Потоки: make(chan quic.Stream, размер),
// 	}
// }
// func (о *ОчередьПотоковКанал) Взять() (quic.Stream, error) {
// 	select {
// 	case поток := <-о.Потоки:
// 		return поток, nil
// 	default:
// 		return nil, errors.New("Нет свободных потоков")
// 	}

// }

// func (о *ОчередьПотоковКанал) Вернуть(поток quic.Stream) {
// 	select {
// 	case о.Потоки <- поток:
// 	default:
// 		// Если канал полон, просто закрываем поток
// 		// поток.Close()
// 	}
// }

// --- Очередь для любого типа данных

type Узел struct {
	значение  interface{}
	следующий *Узел
}

type Очередь struct {
	Блок      *sync.RWMutex
	Первый    *Узел
	Последний *Узел
}

func НоваяОчередь() *Очередь {
	return &Очередь{
		Блок:      &sync.RWMutex{},
		Первый:    nil,
		Последний: nil,
	}

}

func (очередь *Очередь) Добавить(новыйУзел interface{}) {
	Инфо(" очередь %+v \n", очередь)
	очередь.Блок.RLock()
	defer очередь.Блок.RUnlock()
	узел := &Узел{значение: новыйУзел}
	if очередь.Последний == nil {
		очередь.Первый = узел
		очередь.Последний = узел
	} else {
		очередь.Последний.следующий = узел
		очередь.Последний = узел
	}
}

func (очередь *Очередь) Далее() interface{} {
	очередь.Блок.RLock()
	defer очередь.Блок.RUnlock()
	if очередь.Пусто() {
		return nil
	}
	очереднойЭлемент := очередь.Первый.значение
	очередь.Первый = очередь.Первый.следующий
	if очередь.Первый == nil {
		очередь.Последний = nil
	}
	return очереднойЭлемент
}

func (очередь *Очередь) Пусто() bool {
	return очередь.Первый == nil
}
