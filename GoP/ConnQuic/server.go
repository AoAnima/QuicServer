package ConnQuic

import (
	"encoding/binary"
	"sync"

	. "aoanima.ru/Logger"
	quic "github.com/quic-go/quic-go"
)

// функция вызывается в сервисе  для отправки ответа в поток, а ну наверно ето же самое можно и на стороне сервера вызывать для отправки сообщения клиенту..... имеет значение только сторона с которой идет запись в поток
func ОтправитьСообщение(поток quic.Stream, сообщение Сообщение) error {
	сообщениеВОтправку, err := Кодировать(сообщение)
	if err != nil {
		Ошибка("  %+v \n", err)
		return err
	}
	отправленно, err := поток.Write(сообщениеВОтправку)
	if err != nil {
		Ошибка(" %+v ", err)
		return err
	} else {
		Инфо("отправленно %+v  байт; сообщение: %+v  %#T \n", отправленно, string(сообщениеВОтправку), поток)
	}
	return nil
}

// Читаем ответы от сервсо
func ЧитатьСообщения(поток quic.Stream, каналСообщения chan Сообщение) {

	длинаСообщения := make([]byte, 4)
	var прочитаноБайт int
	var err error
	for {
		прочитаноБайт, err = поток.Read(длинаСообщения)
		// Инфо(" длинаСообщения %+v , прочитаноБайт %+v \n", длинаСообщения, прочитаноБайт)
		if err != nil {
			Ошибка(" прочитаноБайт %+v  err %+v \n", прочитаноБайт, err)
			break
		}
		// получаем число байткоторое нужно прочитать
		длинаДанных := binary.LittleEndian.Uint32(длинаСообщения)
		сообщениеБинарное := make([]byte, длинаДанных)
		прочитаноБайт, err = поток.Read(сообщениеБинарное)
		if err != nil {
			Ошибка("Ошибка при десериализации структуры: %+v ", err)
		}
		if длинаДанных != uint32(прочитаноБайт) {
			Ошибка("Количество прочитаных байт не ранво длине данных :\n длинаДанных %+v  <> прочитаноБайт %+v ", длинаДанных, прочитаноБайт)
		} else {
			сообщение, err := ДекодироватьПакет(сообщениеБинарное)
			if err != nil {
				Ошибка("  %+v \n", err)
			} else {
				каналСообщения <- сообщение
			}
		}
		// Инфо(" продолжаем читать из потока  %+v \n", поток)
	}
}

func ЧитатьСообщение(поток quic.Stream) Сообщение {

	длинаСообщения := make([]byte, 4)
	var прочитаноБайт int
	var err error

	прочитаноБайт, err = поток.Read(длинаСообщения)
	// Инфо(" длинаСообщения %+v , прочитаноБайт %+v \n", длинаСообщения, прочитаноБайт)
	if err != nil {
		Ошибка(" прочитаноБайт %+v  err %+v \n", прочитаноБайт, err)
		return Сообщение{}
	}
	// получаем число байткоторое нужно прочитать
	длинаДанных := binary.LittleEndian.Uint32(длинаСообщения)
	// Инфо(" длинаДанных %+v  \n", длинаДанных)

	сообщениеБинарное := make([]byte, длинаДанных)
	прочитаноБайт, err = поток.Read(сообщениеБинарное)
	if err != nil {
		Ошибка("Ошибка при десериализации структуры: %+v ", err)
		return Сообщение{}
	}
	// Инфо(" длинаСообщения %+v , прочитаноБайт %+v \n", длинаСообщения, прочитаноБайт)

	if длинаДанных != uint32(прочитаноБайт) {
		Ошибка("Количество прочитаных байт не ранво длине данных :\n длинаДанных %+v  <> прочитаноБайт %+v \n %+v \n поток %+v ", длинаДанных, прочитаноБайт, string(сообщениеБинарное), поток)
		return Сообщение{}
	} else {
		сообщение, err := ДекодироватьПакет(сообщениеБинарное)
		// Инфо(" сообщение %+v \n", сообщение)
		if err != nil {
			Ошибка("  %+v  %+v \n", err, сообщение)
			return Сообщение{}
		} else {
			return сообщение
		}
	}
}

var АктивныеHTTPСесии = make(map[НомерСессии]HTTPСессии)

type HTTPСессии struct {
	Блок       *sync.RWMutex
	Соединение quic.Connection
	Потоки     []quic.Stream
}

func ПульсСессии() {
	Инфо(" Реализовать периодическую проверку сессий, и очустку отвалившихся %+v \n", "ПульсСессии")
}

var АктивныеСессии = make(КартаСервисов)

var БлокКартыОбработчиков = sync.RWMutex{}
var КартаОбработчиков = make(map[Маршрут]ИмяСервиса)

// ДОДЕЛАТЬ: Не сделан ресистратор маршрутов по сообщению полученному от сервиса
func РегистрацияСервиса(сессия quic.Connection, поток quic.Stream, сообщение *Сообщение) {

	// Создвём новую очередь потоков,
	очередьПотоков := НоваяОчередьПотоков()
	// открываем исходящий поток,
	исходящийПоток, err := сессия.OpenStream()
	if err != nil {
		Ошибка("  %+v \n", err)
	}
	// добавляем его в очередь
	очередьПотоков.Добавить(исходящийПоток)
	//системный потом кладём в отдлельное поле карты, из него данные читаються постоянно

	новаяСессия := КартаСессий{
		Соединение:     сессия,
		ОчередьПотоков: очередьПотоков,
		СистемныйПоток: поток,
	}

	// Если в активных сессиях есть подключения с сервисом, то добавляем в карту этого сервиса новыую сессию
	if _, ok := АктивныеСессии[сообщение.Сервис]; ok {
		БлокКартаСервисов.Lock()
		// АктивныеСессии[сообщение.Сервис] = append(АктивныеСессии[сообщение.Сервис], новаяСессия)
		АктивныеСессии[сообщение.Сервис].Сессии[НомерСессии(len(АктивныеСессии[сообщение.Сервис].Сессии))] = новаяСессия
		БлокКартаСервисов.Unlock()

	} else {

		БлокКартаСервисов.Lock()
		// АктивныеСессии[сообщение.Сервис] = []КартаСессий{новаяСессия}
		новыйСервис := struct {
			Блок           *sync.RWMutex
			Сессии         map[НомерСессии]КартаСессий
			НеПолныеСессии map[НомерСессии]int
		}{
			Блок:           &sync.RWMutex{},
			Сессии:         make(map[НомерСессии]КартаСессий),
			НеПолныеСессии: make(map[НомерСессии]int),
		}

		новыйСервис.Сессии[НомерСессии(1)] = новаяСессия
		АктивныеСессии[сообщение.Сервис] = новыйСервис
		БлокКартаСервисов.Unlock()
		БлокКартыОбработчиков.RLock()
		for _, маршрут := range сообщение.Маршруты {
			КартаОбработчиков[маршрут] = сообщение.Сервис
		}
		БлокКартыОбработчиков.RUnlock()
	}
	Инфо(" Активные соединения  %+v \n", АктивныеСессии)
	ПульсСессии()
}

// ! ЧитатьСистемныйПоток принимает Один Поток от клиента, ичитает из него сообщения
// func ЧитатьСистемныйПоток(сессия quic.Connection) {

// 	поток, err := сессия.AcceptStream(context.Background())
// 	if err != nil {
// 		Ошибка("  %+v \n", err)
// 	}
// 	// получается читаем постоянно системый поток,
// 	// ЧитатьСообщения(сессия, поток, ОбработчикСистемныхСообщений)

// 	// каналСооб/щений := make(chan Сообщение, 5)
// 	// Читаем данные из потока , декодируем и возвращаем в канал
// 	go ЧитатьСообщения(поток, каналСообщений)
// 	// читаем из канала сообщения и отправляем в обработчик
// 	for сообщение := range каналСообщений {
// 		if сообщение.Регистрация {
// 			if сообщение.Сервис == "КлиентСервер" {
// 				РегистрацияHTTPсервера(сессия, поток, &сообщение)
// 			} else {
// 				РегистрацияСервиса(сессия, поток, &сообщение)
// 			}

// 		} else {
// 			ОбработчикСистемныхСообщений(поток, сообщение)
// 		}
// 	}
// }

// ! ОбработчикСессии запускается когда происходит новое соединение,
// ! Открывает один поток и запускает ЧтениеСообщений из потока,... но зачем???
// !  Нудно просто создать один исходящий поток, и положить его  в очередь, и всё. Запуск ЧтенияСообщений будет происхдить после отправки сообщения в клиент. В Данный момент больше не нужно ничего делать
// func ОбработчикСессии(сессия quic.Connection, обработчикСообщений func(поток quic.Stream, сообщение Сообщение), ОбработчикСистемныхСОобщений func(поток quic.Stream, сообщение Сообщение)) {

// 	// for {
// 	поток, err := сессия.OpenStream()

// 	if err != nil {
// 		Ошибка(" %+v ", err)
// 	}

// 	// go ЧитатьСообщения(сессия, поток, обработчикСообщений) // Ждём ответа от клиента

// 	// }
// }

/**
Читаем мы сообщение из поток, в надежде что это будет ответ на запрос а не другое сообщение, значит по завершинии нужно завершать работу Функции

*/

// func ЧитатьСообщения(сессия quic.Connection, поток quic.Stream, обработчикСообщений func(поток quic.Stream, сообщение Сообщение)) {

// 	длинаСообщения := make([]byte, 4)
// 	var прочитаноБайт int
// 	var err error
// 	for {
// 		прочитаноБайт, err = поток.Read(длинаСообщения)
// 		Инфо(" длинаСообщения %+v , прочитаноБайт %+v \n", длинаСообщения, прочитаноБайт)
// 		if err != nil {
// 			Ошибка(" прочитаноБайт %+v  err %+v \n", прочитаноБайт, err)
// 			break
// 		}
// 		// получаем число байткоторое нужно прочитать
// 		длинаДанных := binary.LittleEndian.Uint32(длинаСообщения)
// 		сообщениеБинарное := make([]byte, длинаДанных)
// 		прочитаноБайт, err = поток.Read(сообщениеБинарное)
// 		if err != nil {
// 			Ошибка("Ошибка при десериализации структуры: %+v ", err)
// 		}
// 		if длинаДанных != uint32(прочитаноБайт) {
// 			Ошибка("Количество прочитаных байт не ранво длине данных :\n длинаДанных %+v  <> прочитаноБайт %+v ", длинаДанных, прочитаноБайт)
// 		} else {
// 			сообщение := ДекодироватьПакет(сообщениеБинарное)
// 			if сообщение.Регистрация {

// 				РегистрацияСервиса(сессия, nil, &сообщение)

// 			} else {
// 				//! функция которая передаёться в момент установления соединения, будет обрабатывать сообщения в соттветсвии с требованиями сервиса
// 				go обработчикСообщений(поток, сообщение)
// 			}

// 			// break
// 		}

// 		// каналПолученияСообщений <- пакетОтвета

// 	}

// }
