package ConnQuic

import (
	"context"
	"encoding/binary"
	"sync"

	. "aoanima.ru/logger"
	quic "github.com/quic-go/quic-go"
)

// var Адрес = "localhost:4242"
// Запускаем сервер который слушает на адресе,
// принимает соединиеие, и отправляет его в обработчик Сессии
// обработчикСообщенийHTTPсервера - функция в которую передаётся сообщение из HTTP сервера, от клиента, реализцется непосредственно в саомо приложени в сервисе выступабщим в качестве менеджера сообщений, в данном случае SynQuic

// Запускаем SynQuic сервер
func ЗапуститьСервер(Адрес string,
	обработчикСообщенийHTTPсервера func(сообщение Сообщение) (Сообщение, error),
	ОбработчикСистемныхСообщений func(поток quic.Stream, сообщение Сообщение)) {
	кофигТлс, err := серверныйТлсКонфиг()
	if err != nil {
		Ошибка("  %+v \n", err)
	}
	listener, err := quic.ListenAddr(Адрес, кофигТлс, nil)
	if err != nil {
		Ошибка(" %+v ", err)
	}
	Инфо("  Запустил SynQuic сервер %+v \n", Адрес)

	for {
		сессия, err := listener.Accept(context.Background())

		if err != nil {
			Ошибка(" %+v ", err)
		}
		// go ЧитатьСистемныйПоток(сессия, ОбработчикСистемныхСообщений)

		каналСообщений := make(chan Сообщение, 5)
		поток, err := сессия.AcceptStream(context.Background())
		if err != nil {
			Ошибка("  %+v \n", err)
		}

		go ЧитатьСообщения(поток, каналСообщений)

		for сообщение := range каналСообщений {
			if сообщение.Регистрация {
				if сообщение.Сервис == "КлиентСервер" {
					РегистрацияHTTPсервера(сессия, поток, &сообщение, обработчикСообщенийHTTPсервера)
				} else {
					РегистрацияСервиса(сессия, поток, &сообщение)
				}
			} else {
				ОбработчикСистемныхСообщений(поток, сообщение)
			}
		}

		// НУЖНО СДЕЛАТЬ обработчик для входящих стримов и обработки регистрации сервисов, после чего открывать исходящий поток.

		// go ОбработчикСессии(сессия, обработчикСообщений)
	}
}

// функция вызывается в сервисе  для отправки ответа в поток, а ну наверно ето же самое можно и на стороне сервера вызывать для отправки сообщения клиенту..... имеет значение только сторона с которой идет запись в поток
func ОтправитьСообщение(поток quic.Stream, сообщение Сообщение) error {
	сообщениеВОтправку, err := Кодировать(сообщение)
	if err != nil {
		Ошибка("  %+v \n", err)
		return err
	}
	_, err = поток.Write(сообщениеВОтправку)
	if err != nil {
		Ошибка(" %+v ", err)
		return err
	}
	return nil
}

// Читаем ответы от сервсо
func ЧитатьСообщения(поток quic.Stream, каналСообщения chan Сообщение) {

	длинаСообщения := make([]byte, 4)
	var прочитаноБайт int
	var err error
	for {
		прочитаноБайт, err = поток.Read(длинаСообщения)
		Инфо(" длинаСообщения %+v , прочитаноБайт %+v \n", длинаСообщения, прочитаноБайт)
		if err != nil {
			Ошибка(" прочитаноБайт %+v  err %+v \n", прочитаноБайт, err)
			break
		}
		// получаем число байткоторое нужно прочитать
		длинаДанных := binary.LittleEndian.Uint32(длинаСообщения)
		сообщениеБинарное := make([]byte, длинаДанных)
		прочитаноБайт, err = поток.Read(сообщениеБинарное)
		if err != nil {
			Ошибка("Ошибка при десериализации структуры: %+v ", err)
		}
		if длинаДанных != uint32(прочитаноБайт) {
			Ошибка("Количество прочитаных байт не ранво длине данных :\n длинаДанных %+v  <> прочитаноБайт %+v ", длинаДанных, прочитаноБайт)
		} else {
			сообщение, err := ДекодироватьПакет(сообщениеБинарное)
			if err != nil {
				Ошибка("  %+v \n", err)
			} else {
				каналСообщения <- сообщение
			}
		}
	}
}

func ЧитатьСообщение(поток quic.Stream) Сообщение {

	длинаСообщения := make([]byte, 4)
	var прочитаноБайт int
	var err error

	прочитаноБайт, err = поток.Read(длинаСообщения)
	Инфо(" длинаСообщения %+v , прочитаноБайт %+v \n", длинаСообщения, прочитаноБайт)
	if err != nil {
		Ошибка(" прочитаноБайт %+v  err %+v \n", прочитаноБайт, err)
		return Сообщение{}
	}
	// получаем число байткоторое нужно прочитать
	длинаДанных := binary.LittleEndian.Uint32(длинаСообщения)
	сообщениеБинарное := make([]byte, длинаДанных)
	прочитаноБайт, err = поток.Read(сообщениеБинарное)
	if err != nil {
		Ошибка("Ошибка при десериализации структуры: %+v ", err)
		return Сообщение{}
	}
	if длинаДанных != uint32(прочитаноБайт) {
		Ошибка("Количество прочитаных байт не ранво длине данных :\n длинаДанных %+v  <> прочитаноБайт %+v ", длинаДанных, прочитаноБайт)
		return Сообщение{}
	} else {
		сообщение, err := ДекодироватьПакет(сообщениеБинарное)
		if err != nil {
			Ошибка("  %+v \n", err)
			return Сообщение{}
		} else {
			return сообщение
		}
	}
}

var АктивныеHTTPСесии = make(map[НомерСессии]HTTPСессии)

type HTTPСессии struct {
	*sync.RWMutex
	Соединение quic.Connection
	Потоки     []quic.Stream
}

func РегистрацияHTTPсервера(сессия quic.Connection, поток quic.Stream, сообщение *Сообщение, обработчикСообщенийHTTPсервера func(сообщение Сообщение) (Сообщение, error)) {
	// TODO добавить обработчик для регистрации HTTP сервера? т.к. сервер инциирует открытиые новых потоков то он регистриаруется чуть по другом, чтобы не загромоэдать функцию ергнситарции сервисов, реализуем логику тут:

	// очередьПотоков := НоваяОчередьПотоков()
	// новаяСессия := КартаСессий{
	// 	Соединение:     сессия,
	// 	ОчередьПотоков: очередьПотоков,
	// 	СистемныйПоток: поток,
	// }

	номерСессии := НомерСессии(len(АктивныеHTTPСесии))
	новаяСессия := HTTPСессии{
		// RWMutex: &sync.RWMutex{},
		Соединение: сессия,
		Потоки:     []quic.Stream{поток},
	}
	АктивныеHTTPСесии[номерСессии] = новаяСессия

	go ОжиданиеВходящихПотоковHTTP(&новаяСессия, обработчикСообщенийHTTPсервера)
}

func ОжиданиеВходящихПотоковHTTP(сессия *HTTPСессии, обработчикСообщенийHTTPсервера func(сообщение Сообщение) (Сообщение, error)) {
	for {
		// принимаем поток от http сервера
		поток, err := сессия.Соединение.AcceptStream(context.Background())
		if err != nil {
			Ошибка("  %+v \n", err)
		}
		сессия.RLock()
		сессия.Потоки = append(сессия.Потоки, поток)
		сессия.RUnlock()
		go ЧитатьHTTPПоток(поток, обработчикСообщенийHTTPсервера)
		// читаем сообщения из поток

	}
}

func ЧитатьHTTPПоток(поток quic.Stream, обработчикСообщенийHTTPсервера func(сообщение Сообщение) (Сообщение, error)) {
	сообщение := ЧитатьСообщение(поток)
	ответ, err := обработчикСообщенийHTTPсервера(сообщение)
	if err != nil {
		Ошибка("  %+v \n", err)

	}
	err = ОтправитьСообщение(поток, ответ)
	if err != nil {
		Ошибка("  %+v \n", err)
	}
}

var АктивныеСессии = make(КартаСервисов)

var БлокКартыОбработчиков = sync.RWMutex{}
var КартаОбработчиков = make(map[Маршрут]ИмяСервиса)

// ДОДЕЛАТЬ: Не сделан ресистратор маршрутов по сообщению полученному от сервиса
func РегистрацияСервиса(сессия quic.Connection, поток quic.Stream, сообщение *Сообщение) {

	// Создвём новую очередь потоков,
	очередьПотоков := НоваяОчередьПотоков()
	// открываем исходящий поток,
	исходящийПоток, err := сессия.OpenStream()
	if err != nil {
		Ошибка("  %+v \n", err)
	}
	// добавляем его в очередь
	очередьПотоков.Добавить(исходящийПоток)
	//системный потом кладём в отдлельное поле карты, из него данные читаються постоянно

	новаяСессия := КартаСессий{
		Соединение:     сессия,
		ОчередьПотоков: очередьПотоков,
		СистемныйПоток: поток,
	}

	// Если в активных сессиях есть подключения с сервисом, то добавляем в карту этого сервиса новыую сессию
	if _, ok := АктивныеСессии[сообщение.Сервис]; ok {
		БлокКартаСервисов.Lock()
		// АктивныеСессии[сообщение.Сервис] = append(АктивныеСессии[сообщение.Сервис], новаяСессия)
		АктивныеСессии[сообщение.Сервис].Сессии[НомерСессии(len(АктивныеСессии[сообщение.Сервис].Сессии))] = новаяСессия
		БлокКартаСервисов.Unlock()

	} else {

		БлокКартаСервисов.Lock()
		// АктивныеСессии[сообщение.Сервис] = []КартаСессий{новаяСессия}
		новыйСервис := struct {
			*sync.RWMutex
			Сессии         map[НомерСессии]КартаСессий
			НеПолныеСессии map[НомерСессии]int
		}{
			RWMutex:        &sync.RWMutex{},
			Сессии:         make(map[НомерСессии]КартаСессий),
			НеПолныеСессии: make(map[НомерСессии]int),
		}

		новыйСервис.Сессии[НомерСессии(1)] = новаяСессия
		АктивныеСессии[сообщение.Сервис] = новыйСервис
		БлокКартаСервисов.Unlock()
		БлокКартыОбработчиков.RLock()
		for _, маршрут := range сообщение.Маршруты {
			КартаОбработчиков[маршрут] = сообщение.Сервис
		}
		БлокКартыОбработчиков.RUnlock()
	}
}

// ! ЧитатьСистемныйПоток принимает Один Поток от клиента, ичитает из него сообщения
// func ЧитатьСистемныйПоток(сессия quic.Connection) {

// 	поток, err := сессия.AcceptStream(context.Background())
// 	if err != nil {
// 		Ошибка("  %+v \n", err)
// 	}
// 	// получается читаем постоянно системый поток,
// 	// ЧитатьСообщения(сессия, поток, ОбработчикСистемныхСообщений)

// 	// каналСооб/щений := make(chan Сообщение, 5)
// 	// Читаем данные из потока , декодируем и возвращаем в канал
// 	go ЧитатьСообщения(поток, каналСообщений)
// 	// читаем из канала сообщения и отправляем в обработчик
// 	for сообщение := range каналСообщений {
// 		if сообщение.Регистрация {
// 			if сообщение.Сервис == "КлиентСервер" {
// 				РегистрацияHTTPсервера(сессия, поток, &сообщение)
// 			} else {
// 				РегистрацияСервиса(сессия, поток, &сообщение)
// 			}

// 		} else {
// 			ОбработчикСистемныхСообщений(поток, сообщение)
// 		}
// 	}
// }

// ! ОбработчикСессии запускается когда происходит новое соединение,
// ! Открывает один поток и запускает ЧтениеСообщений из потока,... но зачем???
// !  Нудно просто создать один исходящий поток, и положить его  в очередь, и всё. Запуск ЧтенияСообщений будет происхдить после отправки сообщения в клиент. В Данный момент больше не нужно ничего делать
// func ОбработчикСессии(сессия quic.Connection, обработчикСообщений func(поток quic.Stream, сообщение Сообщение), ОбработчикСистемныхСОобщений func(поток quic.Stream, сообщение Сообщение)) {

// 	// for {
// 	поток, err := сессия.OpenStream()

// 	if err != nil {
// 		Ошибка(" %+v ", err)
// 	}

// 	// go ЧитатьСообщения(сессия, поток, обработчикСообщений) // Ждём ответа от клиента

// 	// }
// }

/**
Читаем мы сообщение из поток, в надежде что это будет ответ на запрос а не другое сообщение, значит по завершинии нужно завершать работу Функции

*/

// func ЧитатьСообщения(сессия quic.Connection, поток quic.Stream, обработчикСообщений func(поток quic.Stream, сообщение Сообщение)) {

// 	длинаСообщения := make([]byte, 4)
// 	var прочитаноБайт int
// 	var err error
// 	for {
// 		прочитаноБайт, err = поток.Read(длинаСообщения)
// 		Инфо(" длинаСообщения %+v , прочитаноБайт %+v \n", длинаСообщения, прочитаноБайт)
// 		if err != nil {
// 			Ошибка(" прочитаноБайт %+v  err %+v \n", прочитаноБайт, err)
// 			break
// 		}
// 		// получаем число байткоторое нужно прочитать
// 		длинаДанных := binary.LittleEndian.Uint32(длинаСообщения)
// 		сообщениеБинарное := make([]byte, длинаДанных)
// 		прочитаноБайт, err = поток.Read(сообщениеБинарное)
// 		if err != nil {
// 			Ошибка("Ошибка при десериализации структуры: %+v ", err)
// 		}
// 		if длинаДанных != uint32(прочитаноБайт) {
// 			Ошибка("Количество прочитаных байт не ранво длине данных :\n длинаДанных %+v  <> прочитаноБайт %+v ", длинаДанных, прочитаноБайт)
// 		} else {
// 			сообщение := ДекодироватьПакет(сообщениеБинарное)
// 			if сообщение.Регистрация {

// 				РегистрацияСервиса(сессия, nil, &сообщение)

// 			} else {
// 				//! функция которая передаёться в момент установления соединения, будет обрабатывать сообщения в соттветсвии с требованиями сервиса
// 				go обработчикСообщений(поток, сообщение)
// 			}

// 			// break
// 		}

// 		// каналПолученияСообщений <- пакетОтвета

// 	}

// }
