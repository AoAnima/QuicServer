package ConnQuic

import (
	"context"
	"encoding/binary"
	"sync"

	. "aoanima.ru/logger"
	quic "github.com/quic-go/quic-go"
)

// var Адрес = "localhost:4242"
// Запускаем сервер который слушает на адресе,
// принимает соединиеие, и отправляет его в обработчик Сессии
// обработчикСообщений - функция которая релаизует логику обработки входящего сообщения, сообщщение уэе прочитано, , логику обработки сообщений пишем в самом сервисе... И отправляем ответ в поток, который передаётся в фукнцию

func ЗапуститьСервер(Адрес string,
	обработчикСообщенийHTTPсервера func(поток quic.Stream, сообщение Сообщение),
	ОбработчикСистемныхСообщений func(поток quic.Stream, сообщение Сообщение)) {
	кофигТлс, err := серверныйТлсКонфиг()
	if err != nil {
		Ошибка("  %+v \n", err)
	}
	listener, err := quic.ListenAddr(Адрес, кофигТлс, nil)
	if err != nil {
		Ошибка(" %+v ", err)
	}

	for {
		сессия, err := listener.Accept(context.Background())

		if err != nil {
			Ошибка(" %+v ", err)
		}
		// go ЧитатьСистемныйПоток(сессия, ОбработчикСистемныхСообщений)

		каналСообщений := make(chan Сообщение, 5)
		поток, err := сессия.AcceptStream(context.Background())
		if err != nil {
			Ошибка("  %+v \n", err)
		}

		go ЧитатьСообщения(поток, каналСообщений)

		for сообщение := range каналСообщений {
			if сообщение.Регистрация {
				if сообщение.Сервис == "КлиентСервер" {
					РегистрацияHTTPсервера(сессия, поток, &сообщение, обработчикСообщенийHTTPсервера)
				} else {
					РегистрацияСервиса(сессия, поток, &сообщение)
				}
			} else {
				ОбработчикСистемныхСообщений(поток, сообщение)
			}
		}

		// НУЖНО СДЕЛАТЬ обработчик для входящих стримов и обработки регистрации сервисов, после чего открывать исходящий поток.

		// go ОбработчикСессии(сессия, обработчикСообщений)
	}
}

// функция вызывается в сервисе  для отправки ответа в поток, а ну наверно ето же самое можно и на стороне сервера вызывать для отправки сообщения клиенту..... имеет значение только сторона с которой идет запись в поток
func ОтправитьСообщение(поток quic.Stream, сообщение []byte) {
	_, err := поток.Write(сообщение)
	if err != nil {
		Ошибка(" %+v ", err)
	}
}

// Читаем ответы от сервсо
func ЧитатьСообщения(поток quic.Stream, каналСообщения chan Сообщение) {

	длинаСообщения := make([]byte, 4)
	var прочитаноБайт int
	var err error
	for {
		прочитаноБайт, err = поток.Read(длинаСообщения)
		Инфо(" длинаСообщения %+v , прочитаноБайт %+v \n", длинаСообщения, прочитаноБайт)
		if err != nil {
			Ошибка(" прочитаноБайт %+v  err %+v \n", прочитаноБайт, err)
			break
		}
		// получаем число байткоторое нужно прочитать
		длинаДанных := binary.LittleEndian.Uint32(длинаСообщения)
		сообщениеБинарное := make([]byte, длинаДанных)
		прочитаноБайт, err = поток.Read(сообщениеБинарное)
		if err != nil {
			Ошибка("Ошибка при десериализации структуры: %+v ", err)
		}
		if длинаДанных != uint32(прочитаноБайт) {
			Ошибка("Количество прочитаных байт не ранво длине данных :\n длинаДанных %+v  <> прочитаноБайт %+v ", длинаДанных, прочитаноБайт)
		} else {
			сообщение, err := ДекодироватьПакет(сообщениеБинарное)
			if err != nil {
				Ошибка("  %+v \n", err)
			} else {
				каналСообщения <- сообщение
			}
		}
	}
}

func ЧитатьСообщение(поток quic.Stream) Сообщение {

	длинаСообщения := make([]byte, 4)
	var прочитаноБайт int
	var err error

	прочитаноБайт, err = поток.Read(длинаСообщения)
	Инфо(" длинаСообщения %+v , прочитаноБайт %+v \n", длинаСообщения, прочитаноБайт)
	if err != nil {
		Ошибка(" прочитаноБайт %+v  err %+v \n", прочитаноБайт, err)
		return Сообщение{}
	}
	// получаем число байткоторое нужно прочитать
	длинаДанных := binary.LittleEndian.Uint32(длинаСообщения)
	сообщениеБинарное := make([]byte, длинаДанных)
	прочитаноБайт, err = поток.Read(сообщениеБинарное)
	if err != nil {
		Ошибка("Ошибка при десериализации структуры: %+v ", err)
		return Сообщение{}
	}
	if длинаДанных != uint32(прочитаноБайт) {
		Ошибка("Количество прочитаных байт не ранво длине данных :\n длинаДанных %+v  <> прочитаноБайт %+v ", длинаДанных, прочитаноБайт)
		return Сообщение{}
	} else {
		сообщение, err := ДекодироватьПакет(сообщениеБинарное)
		if err != nil {
			Ошибка("  %+v \n", err)
			return Сообщение{}
		} else {
			return сообщение
		}
	}
}

func РегистрацияHTTPсервера(сессия quic.Connection, поток quic.Stream, сообщение *Сообщение, обработчикСообщенийHTTPсервера func(поток quic.Stream, сообщение Сообщение)) {
	// TODO добавить обработчик для регистрации HTTP сервера? т.к. сервер инциирует открытиые новых потоков то он регистриаруется чуть по другом, чтобы не загромоэдать функцию ергнситарции сервисов, реализуем логику тут:

	очередьПотоков := НоваяОчередьПотоков()
	новаяСессия := КартаСессий{
		Соединение:     сессия,
		ОчередьПотоков: очередьПотоков,
		СистемныйПоток: поток,
	}

	if _, ok := АктивныеСессии[сообщение.Сервис]; ok {
		БлокКартаСервисов.Lock()
		АктивныеСессии[сообщение.Сервис] = append(АктивныеСессии[сообщение.Сервис], новаяСессия)
		БлокКартаСервисов.Unlock()
	} else {
		БлокКартаСервисов.Lock()
		АктивныеСессии[сообщение.Сервис] = []КартаСессий{новаяСессия}
		БлокКартаСервисов.Unlock()
	}
	go ОжиданиеВходящихПотоковHTTP(новаяСессия, обработчикСообщенийHTTPсервера)
}

func ОжиданиеВходящихПотоковHTTP(картаСессии КартаСессий, обработчикСообщенийHTTPсервера func(поток quic.Stream, сообщение Сообщение)) {
	for {
		поток, err := картаСессии.Соединение.AcceptStream(context.Background())
		if err != nil {
			Ошибка("  %+v \n", err)
		}
		картаСессии.ОчередьПотоков.Добавить(поток)
		сообщение := ЧитатьСообщение(поток)
		обработчикСообщенийHTTPсервера(поток, сообщение)
	}
}

var АктивныеСессии = make(КартаСервисов)
var БлокКартыОбработчиков = sync.RWMutex{}
var КартаОбработчиков = make(map[Маршрут]ИмяСервиса)

// ДОДЕЛАТЬ: Не сделан ресистратор маршрутов по сообщению полученному от сервиса
func РегистрацияСервиса(сессия quic.Connection, поток quic.Stream, сообщение *Сообщение) {

	// Создвём новую очередь потоков,
	очередьПотоков := НоваяОчередьПотоков()
	// открываем исходящий поток,
	исходящийПоток, err := сессия.OpenStream()
	if err != nil {
		Ошибка("  %+v \n", err)
	}
	// добавляем его в очередь
	очередьПотоков.Добавить(исходящийПоток)
	//системный потом кладём в отдлельное поле карты, из него данные читаються постоянно

	новаяСессия := КартаСессий{
		Соединение:     сессия,
		ОчередьПотоков: очередьПотоков,
		СистемныйПоток: поток,
	}

	// Если в активных сессиях есть подключения с сервисом, то добавляем в карту этого сервиса новыую сессию
	if _, ok := АктивныеСессии[сообщение.Сервис]; ok {
		БлокКартаСервисов.Lock()
		АктивныеСессии[сообщение.Сервис] = append(АктивныеСессии[сообщение.Сервис], новаяСессия)
		БлокКартаСервисов.Unlock()

	} else {

		БлокКартаСервисов.Lock()
		АктивныеСессии[сообщение.Сервис] = []КартаСессий{новаяСессия}
		БлокКартаСервисов.Unlock()
		БлокКартыОбработчиков.RLock()
		for _, маршрут := range сообщение.Маршруты {
			КартаОбработчиков[маршрут] = сообщение.Сервис
		}
		БлокКартыОбработчиков.RUnlock()
	}
}

// ! ЧитатьСистемныйПоток принимает Один Поток от клиента, ичитает из него сообщения
// func ЧитатьСистемныйПоток(сессия quic.Connection) {

// 	поток, err := сессия.AcceptStream(context.Background())
// 	if err != nil {
// 		Ошибка("  %+v \n", err)
// 	}
// 	// получается читаем постоянно системый поток,
// 	// ЧитатьСообщения(сессия, поток, ОбработчикСистемныхСообщений)

// 	// каналСооб/щений := make(chan Сообщение, 5)
// 	// Читаем данные из потока , декодируем и возвращаем в канал
// 	go ЧитатьСообщения(поток, каналСообщений)
// 	// читаем из канала сообщения и отправляем в обработчик
// 	for сообщение := range каналСообщений {
// 		if сообщение.Регистрация {
// 			if сообщение.Сервис == "КлиентСервер" {
// 				РегистрацияHTTPсервера(сессия, поток, &сообщение)
// 			} else {
// 				РегистрацияСервиса(сессия, поток, &сообщение)
// 			}

// 		} else {
// 			ОбработчикСистемныхСообщений(поток, сообщение)
// 		}
// 	}
// }

// ! ОбработчикСессии запускается когда происходит новое соединение,
// ! Открывает один поток и запускает ЧтениеСообщений из потока,... но зачем???
// !  Нудно просто создать один исходящий поток, и положить его  в очередь, и всё. Запуск ЧтенияСообщений будет происхдить после отправки сообщения в клиент. В Данный момент больше не нужно ничего делать
// func ОбработчикСессии(сессия quic.Connection, обработчикСообщений func(поток quic.Stream, сообщение Сообщение), ОбработчикСистемныхСОобщений func(поток quic.Stream, сообщение Сообщение)) {

// 	// for {
// 	поток, err := сессия.OpenStream()

// 	if err != nil {
// 		Ошибка(" %+v ", err)
// 	}

// 	// go ЧитатьСообщения(сессия, поток, обработчикСообщений) // Ждём ответа от клиента

// 	// }
// }

/**
Читаем мы сообщение из поток, в надежде что это будет ответ на запрос а не другое сообщение, значит по завершинии нужно завершать работу Функции

*/

// func ЧитатьСообщения(сессия quic.Connection, поток quic.Stream, обработчикСообщений func(поток quic.Stream, сообщение Сообщение)) {

// 	длинаСообщения := make([]byte, 4)
// 	var прочитаноБайт int
// 	var err error
// 	for {
// 		прочитаноБайт, err = поток.Read(длинаСообщения)
// 		Инфо(" длинаСообщения %+v , прочитаноБайт %+v \n", длинаСообщения, прочитаноБайт)
// 		if err != nil {
// 			Ошибка(" прочитаноБайт %+v  err %+v \n", прочитаноБайт, err)
// 			break
// 		}
// 		// получаем число байткоторое нужно прочитать
// 		длинаДанных := binary.LittleEndian.Uint32(длинаСообщения)
// 		сообщениеБинарное := make([]byte, длинаДанных)
// 		прочитаноБайт, err = поток.Read(сообщениеБинарное)
// 		if err != nil {
// 			Ошибка("Ошибка при десериализации структуры: %+v ", err)
// 		}
// 		if длинаДанных != uint32(прочитаноБайт) {
// 			Ошибка("Количество прочитаных байт не ранво длине данных :\n длинаДанных %+v  <> прочитаноБайт %+v ", длинаДанных, прочитаноБайт)
// 		} else {
// 			сообщение := ДекодироватьПакет(сообщениеБинарное)
// 			if сообщение.Регистрация {

// 				РегистрацияСервиса(сессия, nil, &сообщение)

// 			} else {
// 				//! функция которая передаёться в момент установления соединения, будет обрабатывать сообщения в соттветсвии с требованиями сервиса
// 				go обработчикСообщений(поток, сообщение)
// 			}

// 			// break
// 		}

// 		// каналПолученияСообщений <- пакетОтвета

// 	}

// }
