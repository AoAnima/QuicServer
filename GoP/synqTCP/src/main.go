package main

import (
	"crypto/tls"
	"crypto/x509"

	"os"

	. "aoanima.ru/logger"
	"github.com/google/uuid"
)

var (
	ВходящийПорт  = ":81"
	ИсходящийПорт = ":82"
)

type ОтветКлиенту struct {
	Ответ     []byte
	ИдКлиента []byte
}

type ЗапросКлиента struct {
	Запрос    []byte
	ИдКлиента uuid.UUID
}

func main() {

	ЗапуститьВходящийСервер()

	Инфо(" %s", "запустили сервер")

}

func ЗапуститьВходящийСервер() {
	cert, err := tls.LoadX509KeyPair("cert/server.crt", "cert/server.key")
	if err != nil {
		Ошибка(" %s", err)

	}
	caCert, err := os.ReadFile("cert/ca.crt")
	if err != nil {
		Ошибка(" %s", err)
	}
	caCertPool := x509.NewCertPool()
	ok := caCertPool.AppendCertsFromPEM(caCert)
	Инфо("Корневой сертфикат создан?  %v ", ok)

	конфиг := &tls.Config{
		ClientAuth:   tls.RequireAndVerifyClientCert,
		ClientCAs:    caCertPool,
		Certificates: []tls.Certificate{cert},
	}
	сервер, err := tls.Listen("tcp", ВходящийПорт, конфиг)
	if err != nil {
		Ошибка("  %+v \n", err)
	}

	defer сервер.Close()
	for {
		клиент, err := сервер.Accept()
		if err != nil {
			Ошибка("  %+v \n", err)
		}
		defer клиент.Close()
		Инфо(" %+v \n", "клиент подключен ко входящему серверу")
		go обработчикВходящихСоединения(клиент)
	}
}

func ЗапуститьИсходящийСервер() {
	cert, err := tls.LoadX509KeyPair("cert/server.crt", "cert/server.key")
	if err != nil {
		Ошибка(" %s", err)

	}
	caCert, err := os.ReadFile("cert/ca.crt")
	if err != nil {
		Ошибка(" %s", err)
	}
	caCertPool := x509.NewCertPool()
	ok := caCertPool.AppendCertsFromPEM(caCert)
	Инфо("Корневой сертфикат создан?  %v ", ok)

	конфиг := &tls.Config{
		ClientAuth:   tls.RequireAndVerifyClientCert,
		ClientCAs:    caCertPool,
		Certificates: []tls.Certificate{cert},
	}
	сервер, err := tls.Listen("tcp", ИсходящийПорт, конфиг)
	if err != nil {
		Ошибка("  %+v \n", err)
	}

	defer сервер.Close()
	for {
		клиент, err := сервер.Accept()
		if err != nil {
			Ошибка("  %+v \n", err)
		}
		defer клиент.Close()
		Инфо(" %+v \n", "клиент подключен к сиходящему серверу")
		go обработчикИсходящихСоединения(клиент)
	}
}

// func обработчикСоединенияБинарный(клиент net.Conn) {
// 	defer клиент.Close()
// 	Инфо(" обработчикСоединения \n")
// 	длинаСообщения := make([]byte, 4)
// 	for {
// 		// получаем длину сообщения

// 		прочитаноБайт, err := клиент.Read(длинаСообщения)
// 		Инфо(" длинаСообщения %+v , прочитаноБайт %+v \n", длинаСообщения, прочитаноБайт)

// 		if err != nil {
// 			Ошибка(" прочитаноБайт %+v  err %+v \n", прочитаноБайт, err)
// 			break
// 		}

// 		Инфо(" длинаСообщения %+v , прочитаноБайт %+v \n", длинаСообщения, прочитаноБайт)
// 		// получаем число байткоторое нужно прочитать
// 		длинаДанных := binary.LittleEndian.Uint32(длинаСообщения)
// 		Инфо(" длинаДанных  %+v \n", длинаДанных)

// 		//читаем количество байт = длинаСообщения
// 		// var запросКлиента ЗапросКлиента
// 		пакетЗапроса := make([]byte, длинаДанных)
// 		прочитаноБайт, err = клиент.Read(пакетЗапроса)
// 		Инфо("прочитаноБайт  %+s %+v \n", прочитаноБайт, пакетЗапроса)
// 		if err != nil {
// 			Ошибка("Ошибка при десериализации структуры: %+v ", err)
// 		}
// 		конецСообщения := [3]byte{}
// 		copy(конецСообщения[:], пакетЗапроса[длинаДанных-3:])

// 		Инфо(" пакетЗапроса %+v %+v \n", конецСообщения, [3]byte{226, 129, 157})
// 		if конецСообщения == [3]byte{226, 129, 157} {
// 			go ДекодироватьПакет(пакетЗапроса)
// 		} else {
// 			Ошибка("не достигнут конец сообщения  %+v , нужно придумать как дочитать до конца... или не верно передан размер пакета ???? \n", конецСообщения)
// 		}

// 	}
// }

// func ДекодироватьПакет_в1(пакет []byte) {
// 	Инфо(" ДекодироватьПакет пакет %+v \n", пакет)

// 	// ⁝  - разделить между сообщениями за которым может следовать новое сообщение, первые 4 байта которого определяет длину
// 	// Инфо(" размер  %+v %+v %d \n", "\n", len("\n"), unsafe.Sizeof("\n"))
// 	// Инфо(" размер  %+v %+v %d \n", "∴", len("∴"), unsafe.Sizeof("∴"))
// 	// Инфо(" размер  %+v %+v  %+v \n", "⊶", len("⊶"), unsafe.Sizeof("⊶"))
// 	// Инфо(" размер  %+v %+v  %+v \n", "!", len("!"), utf8.RuneLen('!'))
// 	// Инфо(" размер  %+v %+v  %+v \n", "°", len("°"), utf8.RuneLen('°'))
// 	// Инфо(" размер  %+v %+v  %+v \n", "˚", len("˚"), utf8.RuneLen('˚'))
// 	буфер := bytes.NewBuffer(пакет)
// 	длинаПоля := make([]byte, 4)
// 	var длинаДанных uint32
// 	СледующиеДанныеИДК := false
// 	var ЗапросОтКлиента = ЗапросКлиента{
// 		Запрос:    []byte{},
// 		ИдКлиента: uuid.UUID{},
// 	}

// 	for {
// 		// читаем 4 байта для получения размера первого значения, на каждом цикле вначале читаем 4 байта потом читаем количество байт равное значению этих 4 байт
// 		i, err := буфер.Read(длинаПоля)
// 		if err != nil {
// 			Ошибка("  i %+v err %+s \n", i, err)
// 			if err.Error() == "EOF" {

// 				Инфо(" ЗапросОтКлиента %+v \n", ЗапросОтКлиента)
// 				break
// 			}

// 		}
// 		Инфо(" длинаПоля %+v \n", длинаПоля)
// 		длинаДанных = binary.LittleEndian.Uint32(длинаПоля)

// 		Данные := make([]byte, длинаДанных)
// 		_, err = буфер.Read(Данные)
// 		if err != nil {
// 			Ошибка("  %+v \n", err)
// 		}

// 		// если в текущей итерации прочитанные данные равны строке "идк" то помечаем что следующие данные будут ИдКиента
// 		if string(Данные) == "идк" {
// 			СледующиеДанныеИДК = true
// 		} else {
// 			// если стоит пометка что следующие данные будут ИдКлиентом то помещаем данные в полекЗапросОтКлиента.ИдКлиента
// 			if СледующиеДанныеИДК {
// 				copy(ЗапросОтКлиента.ИдКлиента[:], Данные)
// 				СледующиеДанныеИДК = false
// 			} else if длинаДанных > 3 {
// 				// иначе если СледующиеДанныеИДК не установлен и длина больше 3 то помещаем данные в поле запрос
// 				ЗапросОтКлиента.Запрос = Данные
// 			} else {
// 				// Проверяем что последние 3 байта равны 226 129 157 конец сообщения, если это так то останавливаем обработку и отправляем запрос дальше, в хранилище и в соотвествующие сервисы.
// 				// Навреное нужно сделать функцию разбора запроса,
// 				конецСообщения := [3]byte{}
// 				copy(конецСообщения[:], Данные)
// 				Инфо("  %+v \n", конецСообщения)
// 				if конецСообщения == [3]byte{226, 129, 157} {

// 					Инфо(" ЗапросОтКлиента %+s \n", ЗапросОтКлиента)
// 					Инфо(" ЗапросОтКлиента %+s \n", ЗапросОтКлиента.Запрос)
// 					Инфо(" ЗапросОтКлиента %+s \n", uuid.UUID(ЗапросОтКлиента.ИдКлиента))

// 					Инфо("Сообщение прочитано до конца, Алилуя, отправляем в хранилище и дальше в обработчики символКонцаСтроки  %+s\n", конецСообщения)

// 					break
// 				}
// 			}

// 		}

// 	}

// }
