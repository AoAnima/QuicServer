package main

import (
	"encoding/binary"
	"errors"
	"fmt"
	"net"
	"net/url"
	"strings"
	"sync"

	connector "aoanima.ru/connector"
	. "aoanima.ru/logger"
)

var БлокКартаЗапросов sync.Mutex

type ОтветПолучен bool

var КартаЗапросов = make(map[connector.УидЗапроса]struct {
	Очередь    *Очередь
	Паралельно map[string]ОтветПолучен // [сервис]ОтветПолучен
})

func СохранитьЗапрос(запрос *connector.Сообщение) {
	JSONЗапроса, err := Кодировать(запрос.Запрос)
	if err != nil {
		Ошибка("  %+v \n", err)
	}
	sql := fmt.Sprintf("INSERT INTO querys (id,id_query, query, service) VALUES (%s, %s, %s, %s)", запрос.ИдКлиента.String(), запрос.УИДСообщения, JSONЗапроса, string(запрос.Сервис))
	Инфо(" Пишем в бд >> %+v \n", sql)

}

// Обрабатывает только запросы полученный от сервисов, в ответ ничего не отправляет
func обработчикВходящихСообщений(клиент net.Conn) {

	длинаСообщения := make([]byte, 4)
	var прочитаноБайт int
	var err error
	for {
		прочитаноБайт, err = клиент.Read(длинаСообщения)
		Инфо(" длинаСообщения %+v , прочитаноБайт %+v \n", длинаСообщения, прочитаноБайт)

		if err != nil {
			Ошибка(" прочитаноБайт %+v  err %+v \n", прочитаноБайт, err)
			break
		}

		// получаем число байткоторое нужно прочитать
		длинаДанных := binary.LittleEndian.Uint32(длинаСообщения)

		Инфо(" длинаДанных  %+v \n", длинаДанных)
		Инфо(" длинаСообщения %+v ,  \n прочитаноБайт %+v ,  \n длинаДанных %+v \n", длинаСообщения,
			прочитаноБайт, длинаДанных)

		if длинаДанных < 4 {
			Ошибка(" длинаДанных нечгео декодировать %+v \n", длинаДанных)
			return
		}

		//читаем количество байт = длинаСообщения
		// var запросКлиента ЗапросКлиента
		пакетЗапроса := make([]byte, длинаДанных)
		прочитаноБайт, err = клиент.Read(пакетЗапроса)

		if err != nil {
			Ошибка("Ошибка при десериализации структуры: %+v ", err)
		}

		if длинаДанных != uint32(прочитаноБайт) {
			Ошибка("Количество прочитаных байт не ранво длине данных :\n длинаДанных %+v  <> прочитаноБайт %+v ", длинаДанных, прочитаноБайт)
		}

		// Запускаем для пакета отдельную горутину, т.к. в ожном соединении будет приходить множество запросов от разных клиентов, и обработчик будт всегда один

		go ДекодироватьПакет(пакетЗапроса)

	}

}

// var КартаЗапросов map[string]Очередь = make(map[string]Очередь)
//
//	type ОчередьМаршрутов struct {
//		Очередь map[string]Очередь
//		mutex sync.Mutex
//	}

// АнализЗапроса -  анализируем url.Path с целью обнаружения сервиса в который отправляем данные
func АнализЗапроса(Запрос *connector.Сообщение) {

	/*
		Если же несколько сервисов не нуждаютс в ажанных от других сервисов и обрабатываюют только изначальный запрос, то к таким сервисам можно отправлять запрос паралельно.
	*/

	// Попытаемся получить Маршурт(Сервис) для текущего сообщения по его УИДСообщения, если в КартеЗАпросов Есть очередь для текущего Сообщения.УИДСообщения то получаем сервис и отправляем ав него данные, иначе если такого УИЛ в карте нету

	сервис, err := ПолучитьСледующийСервис(&Запрос.УИДСообщения)

	if err != nil {
		if err.Error() == "Не найден УИДСообщения" {
			Инфо("  %+v, в Маршрутизаторе нет маршрута для запроса с УИДСообщения  %+v Построим Новый маршрут \n", err, &Запрос.УИДСообщения)

			err = ПостроитьМаршрут(Запрос) // всегда создаёт маршрут для запроса, если не нашёл сервис соответсвующий маршруту то создаст очередь из 404 , и Рендер

			if err != nil {
				Ошибка(" НЕ удалось построить маршрут, нужно что то вернуть клиенту %+v \n", err)
			} else {
				Инфо(" получаем следующий сервис и отправляем в него данные запроса %+v \n", "ПолучитьСледующийСервис")
				сервис, err = ПолучитьСледующийСервис(&Запрос.УИДСообщения)
			}
		} else {
			Ошибка(" %+v \n", err)
		}
	}
	Инфо("  %+v \n")
	if сервис != "" && err == nil {
		// Перед отправкой в сервис, предзаполним Поле ответ, Флаг ОтветПолучен выставим в лож, внутри сервиса, сервис должен поменять влаг на false, при паралельной обработке , нужно дождаться чтобы все ответы были получены перед отправкой клиенту...
		ответ := make(connector.Ответ)
		ответ[connector.Сервис(сервис)] = connector.ОтветСервиса{
			Сервис:       []byte(сервис),
			УИДЗапроса:   string(Запрос.УИДСообщения),
			Данные:       nil,
			ОтветПолучен: false,
		}
		Запрос.Ответ = &ответ
		ОтправитЗапросВСервис(сервис, Запрос)
	}

}

// По УидЗапроса проверяет есть ли в КартеЗАпросов маршрут , и если есть возвращает следующий сервис
func ПолучитьСледующийСервис(УИДСообщения *connector.УидЗапроса) (string, error) {
	БлокКартаЗапросов.Lock()
	defer БлокКартаЗапросов.Unlock()
	if очередьСервисов, ok := КартаЗапросов[*УИДСообщения]; ok {
		// Получим следующий элемент из очереди
		Очередь := очередьСервисов.Очередь
		СледующийСервис := Очередь.Далее()
		// если он не пустой
		if СледующийСервис != nil {
			// проверим есть ли в очередьСервисов ещё элемнеты, еслли нету, то очистим КартуЗАпросов , удалив данные для текущего сообщения, полагаем что это последний сервис, и дальше результат будет отправлен клиенту
			if Очередь.Пусто() {
				// удалим и КартыЗАпросов УИДСообщения
				delete(КартаЗапросов, *УИДСообщения)
			}
			return СледующийСервис.(string), nil
		} else {
			// по идее сюда мы никогда не попадём
			Ошибка("Сюда не должны были попасть")
			delete(КартаЗапросов, *УИДСообщения)
			return "", errors.New("cюда не должны были попасть? нет больше сервисов в очереди")
		}
	}
	return "", errors.New("не найден УИДСообщения")

}

type ОчередностьСервисов struct {
	Очередь    []string
	Паралельно []string
}

func ПолучитьОчередьСервисовИзБД(Запрос *connector.Сообщение) (ОчередностьСервисов, error) {

	Инфо(" ПолучитьОчередьСервисов %+v \n", "Обращаемся к БД, получаем очередь обработки запроса, для указаного запроса. Некоторый запросы могут выполнятся не зависимо от других сервисов")

	параметрыЗапроса, err := url.Parse(Запрос.Запрос.МаршрутЗапроса)
	Инфо(" параметрыЗапроса %+v \n", параметрыЗапроса)
	if err != nil {
		Ошибка("Ошибка при парсинге СтрокаЗапроса запроса:", err)
		return ОчередностьСервисов{}, err
	}
	параметрыЗапроса.Path = strings.Trim(параметрыЗапроса.Path, "/")
	маршрут := strings.Split(параметрыЗапроса.Path, "/")
	// TODO: Тут нужно сделать обращение к БД для получения очереди сервисов которые должны обработать запрос еред возвратом клиенту
	if len(маршрут) == 0 {
		Инфо(" Пустой маршрут, добавляем в маршруты обработку по умолчанию.... \n")
		маршрут = append(маршрут, "/")
	}

	/* TODO: Обращение к БД за маршрутами
	данныеИзБД := ЗапросВБД()
	очередь := ОчередностьСервисов{
					Очередь: данныеИзБД["очередь"],
					Паралельно: данныеИзБД["паралельно"],
				}

	*/
	очередь := ОчередностьСервисов{
		Очередь:    маршрут,
		Паралельно: make([]string, 0),
	}
	return очередь, nil
}

func ПостроитьМаршрут(Запрос *connector.Сообщение) error {

	// TODO: Доделать ПостроитьМаршрут, нет обработчика для БД
	// параметрыЗапроса, err := url.Parse(Запрос.Запрос.МаршрутЗапроса)
	// Инфо(" параметрыЗапроса %+v \n", параметрыЗапроса)
	// if err != nil {
	// 	Ошибка("Ошибка при парсинге СтрокаЗапроса запроса:", err)
	// 	return err
	// }
	// параметрыЗапроса.Path = strings.Trim(параметрыЗапроса.Path, "/")

	// маршрут := strings.Split(параметрыЗапроса.Path, "/")
	// Инфо("  %+v \n")
	// // TODO: Тут нужно сделать обращение к БД для получения очереди сервисов которые должны обработать запрос еред возвратом клиенту
	// if len(маршрут) == 0 {
	// 	Инфо(" Пустой маршрут, добавляем в маршруты обработку по умолчанию.... \n")
	// 	маршрут = append(маршрут, "/")
	// } else {
	// }
	ОчередьМаршрутов, err := ПолучитьОчередьСервисовИзБД(Запрос) // МОК. не работает, получаем очередь из БД, предварительно прасим URL path? и на его основе получаем маршруты
	Инфо(" ОчередьМаршрутов : %+v \n", ОчередьМаршрутов)
	if err != nil {
		Ошибка("  %+v \n", err)
	}
	ОчередьСеревисов := НоваяОчередь()

	Инфо(" Пока условно полагаем что маршрут строиться из url path , но по факту в path нас интересует только 1 элемент, он указывает на сервис в кооторый адресован запрос, тогда по идее, остальной маршрут должен вытсролиться из БД  %+v \n")

	if ОчередьМаршрутов.Очередь == nil && ОчередьМаршрутов.Паралельно == nil {
		ОчередьСеревисов.Добавить("404")
	}

	for _, сервис := range ОчередьМаршрутов.Очередь {
		// проверим есть ли обработчик для маршрута в карте маршуртизатора, если сесть добавим в очередь иначе 404
		if _, есть := Маршрутизатор[сервис]; есть {
			Инфо(" добавляем %+v \n", сервис)
			ОчередьСеревисов.Добавить(сервис)
		} else {
			Инфо(" Нет в маршрутизаторе сервиса %+v \n", сервис)
			// ОчередьСеревисов.Добавить("404")
		}
	}

	ПаралельныеСервисы := make(map[string]ОтветПолучен)
	for _, сервис := range ОчередьМаршрутов.Паралельно {
		ПаралельныеСервисы[сервис] = false
	}

	ОчередьСеревисов.Добавить("Рендер")              // Добавляем сервис Рендер для пожготовки ответа клиенту, в соответствии с запрошенным форматом
	ОчередьСеревисов.Добавить(string(Запрос.Сервис)) // Последним добавим Сервис от которого пришло изначальное сообщение чтобы в него отправить ответ
	БлокКартаЗапросов.Lock()
	КартаЗапросов[Запрос.УИДСообщения] = struct {
		Очередь    *Очередь
		Паралельно map[string]ОтветПолучен
	}{
		Очередь:    ОчередьСеревисов,
		Паралельно: ПаралельныеСервисы,
	}
	// КартаЗапросов[Запрос.УИДСообщения].Очередь = *ОчередьСеревисов
	БлокКартаЗапросов.Unlock()

	Инфо(" ПолучитьМаршрут анализируем запрос, обращаемся в БД за получением маршрутизации %+v \n")
	// return "маршрут запроса... ДОДЕЛАТЬ"
	return nil
}

// ЧПросто отправляет сообщение в указаный сервис
func ОтправитЗапросВСервис(сервис string, Запрос *connector.Сообщение) {

	if Сервис, есть := Маршрутизатор[сервис]; есть {
		Инфо(" Сервис %+v \n", Сервис)
		// Сервис.КаналСообщения читается в функции ОтправитьСообщениеВСервис()
		Сервис.КаналСообщения <- Запрос
	} else {

		Ошибка(" Нет маршрута для  %+v есть %+v\n", сервис, есть)
		Ошибка("Маршрутизатор  %+v \n", Маршрутизатор)
	}

}
