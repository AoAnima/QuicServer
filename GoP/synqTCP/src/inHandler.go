package main

import (
	"encoding/binary"
	"fmt"
	"net"
	"net/url"
	"strings"

	. "aoanima.ru/logger"
)

func СохранитьЗапрос(запрос ЗапросКлиента) {
	sql := fmt.Sprintf("INSERT INTO querys (id, query, service) VALUES (%s, %s, %s)", запрос.ИдКлиента.String(), запрос.Запрос, запрос.Сервис)
	Инфо(" Пишем в бд >> %+v \n", sql)

}

// Обрабатывает только запросы полученный от сервисов, в ответ ничего не отправляет
func обработчикВходящихСообщений(клиент net.Conn) {

	длинаСообщения := make([]byte, 4)
	var прочитаноБайт int
	var err error
	for {
		прочитаноБайт, err = клиент.Read(длинаСообщения)
		Инфо(" длинаСообщения %+v , прочитаноБайт %+v \n", длинаСообщения, прочитаноБайт)

		if err != nil {
			Ошибка(" прочитаноБайт %+v  err %+v \n", прочитаноБайт, err)
			break
		}

		// получаем число байткоторое нужно прочитать
		длинаДанных := binary.LittleEndian.Uint32(длинаСообщения)

		Инфо(" длинаДанных  %+v \n", длинаДанных)
		Инфо(" длинаСообщения %+v ,  \n прочитаноБайт %+v ,  \n длинаДанных %+v \n", длинаСообщения,
			прочитаноБайт, длинаДанных)

		//читаем количество байт = длинаСообщения
		// var запросКлиента ЗапросКлиента
		пакетЗапроса := make([]byte, длинаДанных)
		прочитаноБайт, err = клиент.Read(пакетЗапроса)
		if err != nil {
			Ошибка("Ошибка при десериализации структуры: %+v ", err)
		}
		if длинаДанных != uint32(прочитаноБайт) {
			Ошибка("Количество прочитаных байт не ранво длине данных :\n длинаДанных %+v  <> прочитаноБайт %+v ", длинаДанных, прочитаноБайт)
		}

		// Запускаем для пакета отдельную горутину, т.к. в ожном соединении будет приходить множество запросов от разных клиентов, и обработчик будт всегда один

		go ДекодироватьПакет(пакетЗапроса)

	}

}

func АнализЗапроса(Запрос *ЗапросКлиента) {

	// СтрокаЗапроса.Запрос = string(СтрокаЗапроса.Запрос)
	параметрыЗапроса, err := url.Parse(Запрос.Запрос.СтрокаЗапроса)
	// параметрыЗапроса, err := url.ParseQuery(string(СтрокаЗапроса.Запрос.Строка))
	Инфо(" параметрыЗапроса %+v \n", параметрыЗапроса)
	if err != nil {
		fmt.Println("Ошибка при парсинге СтрокаЗапроса запроса:", err)
		return
	}
	Инфо("СтрокаЗапроса.Запрос.Форма %+v \n", Запрос.Запрос.Форма)

	// Анализируем в какой сервис отправить запрос
	// например присутствует строка category - знаичт отправляем в сервис отвечающий за категории

	ОтправитЗапросВСервис(параметрыЗапроса, Запрос)

}

func ОтправитЗапросВСервис(параметрыЗапроса *url.URL, Запрос *ЗапросКлиента) {
	Инфо("ОтправитЗапросВСервис параметрыЗапроса  %+v \n", параметрыЗапроса)

	параметрыЗапроса.Path = strings.Trim(параметрыЗапроса.Path, "/")
	маршрут := strings.Split(параметрыЗапроса.Path, "/")

	Инфо(" маршрут[0] %+v \n", маршрут[0])

	if Сервис, есть := Маршрутизатор[маршрут[0]]; есть {
		Инфо(" Сервис %+v \n", Сервис)
		// Сервис.КаналСообщения читается в функции ОтправитьСообщениеВСервис()
		Сервис.КаналСообщения <- Запрос
	} else {

		Ошибка(" Нет маршрута для  %+v есть %+v\n", маршрут, есть)
		Ошибка("Маршрутизатор  %+v \n", Маршрутизатор)
	}

}
