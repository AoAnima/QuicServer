package main

import (
	"encoding/binary"
	"errors"
	"fmt"
	"net"
	"net/url"
	"strings"
	"sync"

	connector "aoanima.ru/connector"
	. "aoanima.ru/logger"
)

func СохранитьЗапрос(запрос *connector.Сообщение) {
	sql := fmt.Sprintf("INSERT INTO querys (id, query, service) VALUES (%s, %s, %s)", запрос.ИдКлиента.String(), запрос.Запрос, запрос.Сервис)
	Инфо(" Пишем в бд >> %+v \n", sql)

}

// Обрабатывает только запросы полученный от сервисов, в ответ ничего не отправляет
func обработчикВходящихСообщений(клиент net.Conn) {

	длинаСообщения := make([]byte, 4)
	var прочитаноБайт int
	var err error
	for {
		прочитаноБайт, err = клиент.Read(длинаСообщения)
		Инфо(" длинаСообщения %+v , прочитаноБайт %+v \n", длинаСообщения, прочитаноБайт)

		if err != nil {
			Ошибка(" прочитаноБайт %+v  err %+v \n", прочитаноБайт, err)
			break
		}

		// получаем число байткоторое нужно прочитать
		длинаДанных := binary.LittleEndian.Uint32(длинаСообщения)

		Инфо(" длинаДанных  %+v \n", длинаДанных)
		Инфо(" длинаСообщения %+v ,  \n прочитаноБайт %+v ,  \n длинаДанных %+v \n", длинаСообщения,
			прочитаноБайт, длинаДанных)

		if длинаДанных < 4 {
			Ошибка(" длинаДанных нечгео декодировать %+v \n", длинаДанных)
			return
		}

		//читаем количество байт = длинаСообщения
		// var запросКлиента ЗапросКлиента
		пакетЗапроса := make([]byte, длинаДанных)
		прочитаноБайт, err = клиент.Read(пакетЗапроса)

		if err != nil {
			Ошибка("Ошибка при десериализации структуры: %+v ", err)
		}

		if длинаДанных != uint32(прочитаноБайт) {
			Ошибка("Количество прочитаных байт не ранво длине данных :\n длинаДанных %+v  <> прочитаноБайт %+v ", длинаДанных, прочитаноБайт)
		}

		// Запускаем для пакета отдельную горутину, т.к. в ожном соединении будет приходить множество запросов от разных клиентов, и обработчик будт всегда один

		go ДекодироватьПакет(пакетЗапроса)

	}

}

// var КартаЗапросов map[string]Очередь = make(map[string]Очередь)
//
//	type ОчередьМаршрутов struct {
//		Очередь map[string]Очередь
//		mutex sync.Mutex
//	}
var БлокКартаЗапросов sync.Mutex
var КартаЗапросов = make(map[connector.УидЗапроса]Очередь)

// АнализЗапроса -  анализируем url.Path с целью обнаружения сервиса в который отправляем данные
func АнализЗапроса(Запрос *connector.Сообщение) {

	// параметрыЗапроса, err := url.Parse(Запрос.Запрос.МаршрутЗапроса)
	// Инфо(" параметрыЗапроса %+v \n", параметрыЗапроса)
	// if err != nil {
	// 	fmt.Println("Ошибка при парсинге СтрокаЗапроса запроса:", err)
	// 	return
	// }
	// Инфо("СтрокаЗапроса.Запрос.Форма %+v \n", Запрос.Запрос.Форма)

	// Анализируем в какой сервис отправить запрос
	// например присутствует строка category - знаичт отправляем в сервис отвечающий за категории

	// параметрыЗапроса.Path = strings.Trim(параметрыЗапроса.Path, "/")
	// маршрут := strings.Split(параметрыЗапроса.Path, "/")
	// Инфо(" маршрут[0] %+v \n", маршрут[0])

	/*
		TODO: Тут по идее нужно сдлеать обращение к бд маршрутизации, чтобы по остальным данным маршрута понять в какие ещё сервисы нужно отправить запросы, или какой маршрут выстроить после получения ответа
		Вообщем нужно додумать как выстривать маршрут запросов в сервисам, какие запросы можно отправлять паралельно, какие последовательно.

		И при этом мне нужно куда то сохранять карту запросов и ответов,
		тоесть если запрос требует последовательной обработки нескольких микросервисов то мне нужно выстроить очередь которая будет обрабатываться по мере обработки запроса микросервисами.

		Нежуно реалиховать Структуру Очередь в виде связанного списка,после получения ответа от очередного сервиса, данные изначального запроса, и всех полученных ответов на предидущем шаге передаются в следующий сервис, и так пока не пройдёт все сервисы

		Если же несколько сервисов не нуждаютс в ажанных от других сервисов и обрабатываюют только изначальный запрос, то к таким сервисам моэно отправлять запрос паралельно.
	*/

	/*
		TODO: ПО ИДЕЕ ТУТ НУЖНО ПРОВЕРИТЬ КАКОЙ ЭТО ЗАПРОС ПЕРВОНАЧАЛЬНЫЙ ИЛИ ОТВЕТ ОТ СЕРВИСА
	*/

	// TODO: Перед отправкой в получить маршрут нужно проанализировать, КартаЗапросов если тут уже есть УИДСообщения то не вызываем эту функцию а получаем следующий сервис
ПовторитьОбработкуЗапроса:
	сервис, err := ПолучитьСледующийСервис(&Запрос.УИДСообщения)
	if err != nil {
		Ошибка("  %+v \n", err)
	}
	if сервис != "" {
		ОтправитЗапросВСервис(сервис, Запрос)
	} else {
		Ответ := *Запрос.Ответ
		if len(Ответ.Данные) < 0 {

			Ошибка(" Выйти %+v \n", err)

		}
		err := ПостроитьМаршрут(Запрос)
		if err != nil {
			Ошибка(" НЕ удалось построить маршрут, нужно что то вернуть клиенту %+v \n", err)
		} else {
			Инфо(" переход к метке, получаем следующий сервис и отправляем в него данные запроса %+v \n", "ПовторитьОбработкуЗапроса")
			goto ПовторитьОбработкуЗапроса
		}

	}
}

// По УидЗапроса проверяет есть ли в КартеЗАпросов маршрут , и если есть возвращает следующий сервис
func ПолучитьСледующийСервис(УИДСообщения *connector.УидЗапроса) (string, error) {
	БлокКартаЗапросов.Lock()
	defer БлокКартаЗапросов.Unlock()
	if сервис, ok := КартаЗапросов[*УИДСообщения]; ok {
		if nil == сервис.Далее() {
			return "", nil
		}
	} else {
		return "", errors.New("Не найден  УИДСообщения")
	}
	return "", nil
}
func ПолучитьОчередьСервисов(Запрос *connector.Сообщение) interface{} {
	Инфо(" ПолучитьОчередьСервисов %+v \n", "Доделать")
	return nil
}

func ПостроитьМаршрут(Запрос *connector.Сообщение) error {
	// TODO: Доделать ПостроитьМаршрут, нет обработчика для БД
	ОчередьИзБД := ПолучитьОчередьСервисов(Запрос)
	Инфо(" ОчередьИзБД : %+v \n", ОчередьИзБД)

	параметрыЗапроса, err := url.Parse(Запрос.Запрос.МаршрутЗапроса)
	Инфо(" параметрыЗапроса %+v \n", параметрыЗапроса)
	if err != nil {
		fmt.Println("Ошибка при парсинге СтрокаЗапроса запроса:", err)
		return err
	}
	параметрыЗапроса.Path = strings.Trim(параметрыЗапроса.Path, "/")
	маршрут := strings.Split(параметрыЗапроса.Path, "/")
	Инфо("  %+v \n")
	// TODO: Тут нужно сделать обращение к БД для получения очереди сервисов которые должны обработать запрос еред возвратом клиенту
	if len(маршрут) == 0 {
		Инфо(" Пустой маршрут, добавляем в маршруты обработку по умолчанию.... \n")
		маршрут = append(маршрут, "/")

	}

	ОчередьСеревисов := НоваяОчередь()

	for _, сервис := range маршрут {
		// проверим есть ли обработчик для маршрута в карте маршуртизатора, если сесть добавим в очередь иначе 404
		if _, есть := Маршрутизатор[сервис]; есть {
			Инфо(" добавляем %+v \n", сервис)
			ОчередьСеревисов.Добавить(сервис)
		} else {
			Инфо(" Нет в маршрутизаторе сервис %+v возвращаем 404\n", сервис)
			ОчередьСеревисов.Добавить("404")
		}
	}

	ОчередьСеревисов.Добавить("Рендер")
	БлокКартаЗапросов.Lock()
	КартаЗапросов[Запрос.УИДСообщения] = *ОчередьСеревисов
	БлокКартаЗапросов.Unlock()

	Инфо(" ПолучитьМаршрут анализируем запрос, обращаемся в БД за получением маршрутизации %+v \n")
	// return "маршрут запроса... ДОДЕЛАТЬ"
	return nil
}

// ЧПросто отправляет сообщение в указаный сервис
func ОтправитЗапросВСервис(сервис string, Запрос *connector.Сообщение) {

	if Сервис, есть := Маршрутизатор[сервис]; есть {
		Инфо(" Сервис %+v \n", Сервис)
		// Сервис.КаналСообщения читается в функции ОтправитьСообщениеВСервис()
		Сервис.КаналСообщения <- Запрос
	} else {

		Ошибка(" Нет маршрута для  %+v есть %+v\n", сервис, есть)
		Ошибка("Маршрутизатор  %+v \n", Маршрутизатор)
	}

}
