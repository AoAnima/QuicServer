package main

import (
	"context"
	"errors"
	"net"
	"net/http"
	"sync"
	"time"

	_ "net/http/pprof"

	. "aoanima.ru/ConnQuic"
	. "aoanima.ru/logger"
	quic "github.com/quic-go/quic-go"
)

var БлокКартаSynQuic = sync.RWMutex{}
var КартаSynQuic = make(map[ИмяСервер]HTTPКлиент)

// var МакимальноеКоличествоПотоковНаСессию = 100
type HTTPКлиент struct {
	Блок           *sync.RWMutex
	Сессии         map[НомерСессии]*СхемаСервераHTTP
	НеПолныеСессии map[НомерСессии]int // Количество открытых потоков в сессии
}

type СхемаСервераHTTP struct {
	Имя            ИмяСервер
	Адрес          string
	Блок           *sync.RWMutex
	Соединение     quic.Connection
	СистемныйПоток quic.Stream
	ОчередьПотоков *ОчередьПотоков
}

func main() {
	/* каналЗапросовОтКлиентов - передаём этот канал в в функци  ЗапуститьСерверТЛС , когда прийдёт сообщение из браузера, функция обработчик запишет данные в этот канал
	 */
	// каналЗапросовОтКлиентов := make(chan http.Request, 10)
	/*
	   Запускаем сервер передаём в него канал, в который запишем обработанный запрос из браузера
	*/
	go ЗапуститьСерверТЛС()
	go СоединитсяСSynQuic()
	Инфо(" %s", "запустили сервер")
	/* Инициализирум сервисы коннектора передадим в них канал, из которого Коннектор будет читать сообщение, и отправлять его в synqTCP  */

	ЗапуститьWebСервер()

}

func СоединитсяСSynQuic() {
	номерСессии := НомерСессии(0)

	for номерСессии <= 0 {
		Инфо(" Устанавливаем соединение SynQuic %+v \n")
		номерСессии = SynQuicСоединение()
		Инфо(" Соединение установленно? если 0 то нет. номер сессия: %+v \n", номерСессии)
		time.Sleep(10 * time.Second)
	}
}

func SynQuicСоединение() НомерСессии {
	сервер := &СхемаСервераHTTP{
		Имя:   "SynQuic",
		Адрес: "localhost:4242",
		Блок:  &sync.RWMutex{},
		ОчередьПотоков: &ОчередьПотоков{
			Блок:       &sync.RWMutex{},
			Количество: 0,
		},
	}
	сообщениеРегистрации := Сообщение{
		Сервис:      "КлиентСервер",
		Регистрация: true,
		Маршруты:    []Маршрут{},
	}

	конфигТлс, err := КлиентскийТлсКонфиг()
	if err != nil {
		Ошибка("  %+v \n", err)
	}
	// Адрес = "localhost:4242"
	Конифгурация := &quic.Config{
		KeepAlivePeriod: 30 * time.Second,
		MaxIdleTimeout:  360 * time.Second,
	}
	сессия, err := quic.DialAddr(context.Background(), сервер.Адрес, конфигТлс, Конифгурация)

	if err != nil {
		Ошибка(" не удаётся покдлючиться к серверу  %+v \n", err)
		return 0
	}
	// поток, err := сессия.OpenStream()
	поток, err := сессия.OpenStreamSync(context.Background())
	if nerr, ok := err.(net.Error); ok && nerr.Timeout() {
		Ошибка("  %+v \n", err)
	}
	сервер.Соединение = сессия
	сервер.СистемныйПоток = поток // первый поток помечаем как системный, потому что synquic кладёт первые потоки в системные
	номерСессии := ДобавитьСессию(сервер)
	go func() {
		for {

			поток1, err := сессия.OpenStreamSync(context.Background())

			if err != nil {
				Ошибка("  %+v \n", err)
			} else {
				Инфо(" закрываем поток  %+v \n", поток1, err)
				поток1.Close()
			}

			пинг := Сообщение{
				Сервис:      "КлиентСервер",
				Регистрация: false,
				Пинг:        true,
			}
			с, err := Кодировать(пинг)

			if err != nil {
				Ошибка("  %+v \n", err)
			}
			байтПередано, err := поток.Write(с)
			if err != nil {
				Ошибка(" Ошибка отправки пинга %+v \n", err)
			}
			Инфо(" байтПередано %+v  %+v \n", байтПередано, err)
			time.Sleep(10 * time.Second)
		}
	}()

	err = ОтправитьСообщение(поток, сообщениеРегистрации)
	if err != nil {
		Ошибка("  %+v \n", err)
	}
	// каналОтвета chan Сообщение
	// for сообщениеОтКлиента := range каналЗапросов {

	// 	go ОтправитьЗапросВОбработку(сообщениеОтКлиента,  )

	// }
	Инфо("номерСессии  %+v \n", номерСессии)
	return номерСессии

}

func ЗакрытьСоединение(сессия quic.ClientHelloInfo) {
	// удалить из
}

func ДобавитьСессию(сервер *СхемаСервераHTTP) НомерСессии {
	БлокКартаSynQuic.Lock()
	defer БлокКартаSynQuic.Unlock()
	номерСессии := НомерСессии(1)
	Инфо(" номерСессии %+v \n", номерСессии)

	if _, ok := КартаSynQuic[сервер.Имя]; ok {
		номерСессии = НомерСессии(len(КартаSynQuic[сервер.Имя].Сессии))
	}
	Инфо(" номерСессии %+v \n", номерСессии)

	КартаSynQuic[сервер.Имя] = HTTPКлиент{
		Сессии: map[НомерСессии]*СхемаСервераHTTP{
			НомерСессии(номерСессии): сервер,
		},
		НеПолныеСессии: map[НомерСессии]int{
			НомерСессии(номерСессии): 0,
		},
	}

	// go func() {
	// 	for {
	// 		Инфо(" ConnectionState %+v \n", сервер.Соединение.ConnectionState())
	// 		err := сервер.Соединение.SendDatagram([]byte("Hello, World!"))
	// 		if err != nil {
	// 			Ошибка("  %+v \n", err)
	// 		}
	// 		time.Sleep(10 * time.Second)
	// 	}

	// }()
	Инфо(" номерСессии %+v \n", номерСессии)
	// КартаSynQuic[сервер.Имя] = make(map[НомерСессии]*СхемаСервераHTTP)
	// КартаSynQuic[сервер.Имя][0] = сервер
	return номерСессии

}

func ВернутьSynQuicПотокВочередь(потокСессии ПотокСессии) {
	КартаSynQuic[ИмяСервер(потокСессии.ИмяСервера)].Сессии[потокСессии.НомерСессии].ОчередьПотоков.Вернуть(потокСессии.Поток)
}

func ПолучитьSynQuicПотокДляОтправки() (ПотокСессии, error) {

	for _, схема := range КартаSynQuic {
		// надём в любой сессии поток и вернём его
		for номерСессии, схемаСессии := range схема.Сессии {

			if поток := схемаСессии.ОчередьПотоков.Взять(); поток != nil {
				ПотокСессии := ПотокСессии{
					НомерСессии: номерСессии,
					Поток:       поток,
				}
				return ПотокСессии, nil
			} else {
				Инфо(" нет потоков в очереди: поток =  %+v ; схемаСессии = %+v \n", поток, схемаСессии)
				// если поток не найден , то попытаемся создать в любой не полной сессиия
				if схема.НеПолныеСессии[номерСессии] < МакимальноеКоличествоПотоковНаСессию {
					новыйПоток, err := схемаСессии.Соединение.OpenStream()
					if err != nil {
						Ошибка("  %+v \n", err)
					}
					схемаСессии.ОчередьПотоков.Добавить(новыйПоток)
					схема.НеПолныеСессии[номерСессии]++
					ПотокСессии := ПотокСессии{
						НомерСессии: номерСессии,
						Поток:       новыйПоток,
					}
					return ПотокСессии, nil
				}
			}
		}

	}
	// Вероятно во всех сессиях открыто макимальное число оптоков, откроем новую суссеию

	номерСессии := SynQuicСоединение()
	if номерСессии == 0 {
		Ошибка("Не удаётся установить соединение с  SynQuic номерСессии  %+v \n", номерСессии)
		return ПотокСессии{}, errors.New("не удаётся установить соединение с SynQuic")
	}
	новыйПоток, err := КартаSynQuic["SynQuic"].Сессии[номерСессии].Соединение.OpenStream()
	if err != nil {
		Ошибка("  %+v \n", err)
		return ПотокСессии{}, err
	}

	ПотокСессии := ПотокСессии{
		НомерСессии: номерСессии,
		Поток:       новыйПоток,
	}
	return ПотокСессии, nil

	// КартаSynQuic["SynQuic"].Сессии[номерСессиия].ОчередьПотоков.Добавить(новыйПоток)

	// return ПотокСессии{}, errors.New("не найден поток, или во всех сессиях максимальное число открытых поток, нужно открыть ещё одну сессию ?! ")
}

func ОбработчикОтветаРегистрации(сообщение Сообщение) {
	Инфо("  ОбработчикОтветаРегистрации %+v \n", сообщение)
}

// обработчик сообщений от synqTCP
// func ОбработатьСообщение(поток quic.Stream, ВходящееСообщение Сообщение) {
// // СООБЩЕНИЕ ФОРМИРУЕТСЯ ТУТ

// 	Инфо(" ОбработатьСообщение %+v \n", ВходящееСообщение)

// 	Сообщение, err := Кодировать(ВходящееСообщение)
// 	if err != nil {
// 		Ошибка("  %+v \n", err)
// 	}
// 	// TODO: Реализум логику обработки запроса от клиента, и генерацию ответа

// 	каналОтправкиСообщений <- Сообщение
// }

func ЗапуститьСерверТЛС() {

	err := http.ListenAndServeTLS(":443",
		"cert/server.crt",
		"cert/server.key",
		http.HandlerFunc(
			func(w http.ResponseWriter, r *http.Request) {
				обработчикЗапроса(w, r)
			}))

	if err != nil {
		Ошибка(" %s ", err)
	}

}
func обработчикЗапроса(w http.ResponseWriter, req *http.Request) {

	Инфо(" %s \n", *req)

	// /*  Тут мы читаем из канала  каналОтвета кторый храниться в карте клиенты , данные пишутся в канал  в функции ОтправитьОтветКлиенту */
	// Отправляем сырой запрос в функцию ОтправитьЗапросВОбработку
	ответ, err := ОтправитьЗапросВОбработку(req)
	if err != nil {
		Ошибка("  %+v \n", err)
	}

	ОтправитьСообщениеКлиенту(ответ, w)

}

type ОтветКлиенту struct {
}

func ОтправитьСообщениеКлиенту(сообщение Сообщение, w http.ResponseWriter) {
	ответ := КодироватьСообщениеОтвет(сообщение)

	if f, ok := w.(http.Flusher); ok {
		i, err := w.Write(ответ)
		Инфо("  %+v \n", i)
		if err != nil {
			Ошибка(" %s ", err)
		}
		f.Flush()
	}
}

func КодироватьСообщениеОтвет(сообщение Сообщение) []byte {

	Инфо(" тут нужно структурировать ответ, взаисимости от запрошенного типа ответа, сформировать тело ответа, заголовки. обновить JWT, устанвоить куки,  %s \n")

	switch сообщение.Запрос.ТипОтвета {
	case HTML:
		ответ, err := Кодировать(сообщение.Ответ["Рендер"].HTML)
		if err != nil {
			Ошибка("  %+v \n", err)
		}
		return ответ
	case AjaxHTML:
		ответ, err := Кодировать(сообщение.Ответ["Рендер"].AjaxHTML)
		if err != nil {
			Ошибка("  %+v \n", err)
		}
		return ответ
	case AjaxJSON:
		ответ, err := Кодировать(сообщение.Ответ["Рендер"].Данные)
		if err != nil {
			Ошибка("  %+v \n", err)
		}
		return ответ
	default:
		Ошибка(" не удалось определить тип ответа %+v \n", сообщение.Запрос)
	}
	return []byte{}
}

// func ОбработчикОтветов(w http.ResponseWriter, каналОтветов <-chan Ответ) {

// 	Ответ := <-каналОтветов
// 	if Ответ.Сообщение != nil {
// 		w.Write([]byte(Ответ.Сообщение.(string)))
// 	}

// }

func ЗапуститьWebСервер() {
	err := http.ListenAndServe(":80", http.HandlerFunc(
		func(w http.ResponseWriter, req *http.Request) {
			// 	Инфо(" %s  %s \n", w, req)
			http.Redirect(w, req, "https://localhost:443"+req.RequestURI, http.StatusMovedPermanently)
		},
	))
	// err := http.ListenAndServe(":6060", nil)
	if err != nil {
		Ошибка(" %s ", err)
	}
	go func() {
		http.ListenAndServe("localhost:6060", nil)
	}()
}
