package main

import (
	"context"
	"net/http"
	"sync"

	_ "net/http/pprof"

	. "aoanima.ru/ConnQuic"
	. "aoanima.ru/logger"
	quic "github.com/quic-go/quic-go"
)

var БлокКартаSynQuic = sync.RWMutex{}
var КартаSynQuic = make(map[ИмяСервер]HTTPКлиент)

// var МакимальноеКоличествоПотоковНаСессию = 100
type HTTPКлиент struct {
	*sync.RWMutex
	Сессии         map[НомерСессии]*СхемаСервераHTTP
	НеПолныеСессии map[НомерСессии]int // Количество открытых потоков в сессии
}

type СхемаСервераHTTP struct {
	Имя   ИмяСервер
	Адрес string
	*sync.RWMutex
	Соединение     quic.Connection
	СистемныйПоток quic.Stream
	ОчередьПотоков *ОчередьПотоков
}

func main() {
	/* каналЗапросовОтКлиентов - передаём этот канал в в функци  ЗапуститьСерверТЛС , когда прийдёт сообщение из браузера, функция обработчик запишет данные в этот канал
	 */
	// каналЗапросовОтКлиентов := make(chan http.Request, 10)
	/*
	   Запускаем сервер передаём в него канал, в который запишем обработанный запрос из браузера
	*/
	go ЗапуститьСерверТЛС()
	go SynQuicСоединение()
	Инфо(" %s", "запустили сервер")
	/* Инициализирум сервисы коннектора передадим в них канал, из которого Коннектор будет читать сообщение, и отправлять его в synqTCP  */

	ЗапуститьWebСервер()

}

func SynQuicСоединение() НомерСессии {
	сервер := &СхемаСервераHTTP{
		Имя:            "SynQuic",
		Адрес:          "localhost:4242",
		RWMutex:        &sync.RWMutex{},
		ОчередьПотоков: &ОчередьПотоков{},
	}
	сообщениеРегистрации := Сообщение{
		Сервис:      "КлиентСервер",
		Регистрация: true,
		Маршруты:    []Маршрут{},
	}

	конфигТлс, err := КлиентскийТлсКонфиг("cert/root.crt")
	if err != nil {
		Ошибка("  %+v \n", err)
	}
	// Адрес = "localhost:4242"

	сессия, err := quic.DialAddr(context.Background(), сервер.Адрес, конфигТлс, &quic.Config{})

	if err != nil {
		Ошибка(" не удаётся покдлючиться к серверу  %+v \n", err)
		return 0
	}
	поток, err := сессия.OpenStream()
	if err != nil {
		Ошибка("  %+v \n", err)
	}
	сервер.Соединение = сессия
	сервер.СистемныйПоток = поток // первый поток помечаем как системный, потому что synquic кладёт первые потоки в системные
	номерСессии := ДобавитьСессию(сервер)
	err = ОтправитьСообщение(поток, сообщениеРегистрации)
	if err != nil {
		Ошибка("  %+v \n", err)
	}
	// каналОтвета chan Сообщение
	// for сообщениеОтКлиента := range каналЗапросов {

	// 	go ОтправитьЗапросВОбработку(сообщениеОтКлиента,  )

	// }

	return номерСессии

}

func ДобавитьСессию(сервер *СхемаСервераHTTP) НомерСессии {
	БлокКартаSynQuic.Lock()
	defer БлокКартаSynQuic.Unlock()
	номерСессии := НомерСессии(1)
	if _, ok := КартаSynQuic[сервер.Имя]; !ok {
		номерСессии = НомерСессии(len(КартаSynQuic[сервер.Имя].Сессии))
	}

	КартаSynQuic[сервер.Имя] = HTTPКлиент{
		Сессии: map[НомерСессии]*СхемаСервераHTTP{
			НомерСессии(номерСессии): сервер,
		},
		НеПолныеСессии: map[НомерСессии]int{
			НомерСессии(номерСессии): 0,
		},
	}

	// КартаSynQuic[сервер.Имя] = make(map[НомерСессии]*СхемаСервераHTTP)
	// КартаSynQuic[сервер.Имя][0] = сервер
	return номерСессии

}

func ВернутьSynQuicПотокВочередь(потокСессии ПотокСессии) {
	КартаSynQuic[ИмяСервер(потокСессии.ИмяСервера)].Сессии[потокСессии.НомерСессии].ОчередьПотоков.Вернуть(потокСессии.Поток)
}

func ПолучитьSynQuicПотокДляОтправки() (ПотокСессии, error) {

	for _, схема := range КартаSynQuic {
		// надём в любой сессии поток и вернём его
		for номерСессии, схемаСессии := range схема.Сессии {

			if поток := схемаСессии.ОчередьПотоков.Взять(); поток != nil {
				ПотокСессии := ПотокСессии{
					НомерСессии: номерСессии,
					Поток:       поток,
				}
				return ПотокСессии, nil
			} else {
				// если поток не найден , то попытаемся создать в любой не полной сессиия
				if схема.НеПолныеСессии[номерСессии] < МакимальноеКоличествоПотоковНаСессию {
					новыйПоток, err := схемаСессии.Соединение.OpenStream()
					if err != nil {
						Ошибка("  %+v \n", err)
					}
					схемаСессии.ОчередьПотоков.Добавить(новыйПоток)
					схема.НеПолныеСессии[номерСессии]++
					ПотокСессии := ПотокСессии{
						НомерСессии: номерСессии,
						Поток:       новыйПоток,
					}
					return ПотокСессии, nil
				}
			}
		}

	}
	// Вероятно во всех сессиях открыто макимальное число оптоков, откроем новую суссеию

	номерСессии := SynQuicСоединение()
	новыйПоток, err := КартаSynQuic["SynQuic"].Сессии[номерСессии].Соединение.OpenStream()
	if err != nil {
		Ошибка("  %+v \n", err)
		return ПотокСессии{}, err
	}

	ПотокСессии := ПотокСессии{
		НомерСессии: номерСессии,
		Поток:       новыйПоток,
	}
	return ПотокСессии, nil

	// КартаSynQuic["SynQuic"].Сессии[номерСессиия].ОчередьПотоков.Добавить(новыйПоток)

	// return ПотокСессии{}, errors.New("не найден поток, или во всех сессиях максимальное число открытых поток, нужно открыть ещё одну сессию ?! ")
}

func ОбработчикОтветаРегистрации(сообщение Сообщение) {
	Инфо("  ОбработчикОтветаРегистрации %+v \n", сообщение)
}

// обработчик сообщений от synqTCP
// func ОбработатьСообщение(поток quic.Stream, ВходящееСообщение Сообщение) {
// // СООБЩЕНИЕ ФОРМИРУЕТСЯ ТУТ

// 	Инфо(" ОбработатьСообщение %+v \n", ВходящееСообщение)

// 	Сообщение, err := Кодировать(ВходящееСообщение)
// 	if err != nil {
// 		Ошибка("  %+v \n", err)
// 	}
// 	// TODO: Реализум логику обработки запроса от клиента, и генерацию ответа

// 	каналОтправкиСообщений <- Сообщение
// }

func ЗапуститьСерверТЛС() {

	err := http.ListenAndServeTLS(":443",
		"cert/server.crt",
		"cert/server.key",
		http.HandlerFunc(
			func(w http.ResponseWriter, r *http.Request) {
				обработчикЗапроса(w, r)
			}))

	if err != nil {
		Ошибка(" %s ", err)
	}

}
func обработчикЗапроса(w http.ResponseWriter, req *http.Request) {

	Инфо(" %s \n", *req)

	// /*  Тут мы читаем из канала  каналОтвета кторый храниться в карте клиенты , данные пишутся в канал  в функции ОтправитьОтветКлиенту */
	// Отправляем сырой запрос в функцию ОтправитьЗапросВОбработку
	ответ, err := ОтправитьЗапросВОбработку(req)
	if err != nil {
		Ошибка("  %+v \n", err)
	}

	ОтправитьСообщениеКлиенту(ответ, w)

}

type ОтветКлиенту struct {
}

func ОтправитьСообщениеКлиенту(сообщение Сообщение, w http.ResponseWriter) {
	ответ := КодироватьСообщениеОтвет(сообщение)

	if f, ok := w.(http.Flusher); ok {
		i, err := w.Write(ответ)
		Инфо("  %+v \n", i)
		if err != nil {
			Ошибка(" %s ", err)
		}
		f.Flush()
	}
}

func КодироватьСообщениеОтвет(сообщение Сообщение) []byte {

	Инфо(" тут нужно структурировать ответ, взаисимости от запрошенного типа ответа, сформировать тело ответа, заголовки. обновить JWT, устанвоить куки,  %s \n")

	switch сообщение.Запрос.ТипОтвета {
	case HTML:
		ответ, err := Кодировать(сообщение.Ответ["Рендер"].HTML)
		if err != nil {
			Ошибка("  %+v \n", err)
		}
		return ответ
	case AjaxHTML:
		ответ, err := Кодировать(сообщение.Ответ["Рендер"].AjaxHTML)
		if err != nil {
			Ошибка("  %+v \n", err)
		}
		return ответ
	case AjaxJSON:
		ответ, err := Кодировать(сообщение.Ответ["Рендер"].Данные)
		if err != nil {
			Ошибка("  %+v \n", err)
		}
		return ответ
	default:
		Ошибка(" не удалось определить тип ответа %+v \n", сообщение.Запрос)
	}
	return []byte{}
}

// func ОбработчикОтветов(w http.ResponseWriter, каналОтветов <-chan Ответ) {

// 	Ответ := <-каналОтветов
// 	if Ответ.Сообщение != nil {
// 		w.Write([]byte(Ответ.Сообщение.(string)))
// 	}

// }

func ЗапуститьWebСервер() {
	err := http.ListenAndServe(":80", http.HandlerFunc(
		func(w http.ResponseWriter, req *http.Request) {
			// 	Инфо(" %s  %s \n", w, req)
			http.Redirect(w, req, "https://localhost:443"+req.RequestURI, http.StatusMovedPermanently)
		},
	))
	// err := http.ListenAndServe(":6060", nil)
	if err != nil {
		Ошибка(" %s ", err)
	}
	go func() {
		http.ListenAndServe("localhost:6060", nil)
	}()
}
