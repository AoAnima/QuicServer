package main

import (
	"context"
	"errors"
	"net"
	"net/http"
	"sync"
	"time"

	_ "net/http/pprof"

	. "aoanima.ru/ConnQuic"
	. "aoanima.ru/Logger"
	quic "github.com/quic-go/quic-go"
)

var БлокКартаSynQuic = sync.RWMutex{}
var КартаSynQuic = make(map[ИмяСервера]HTTPКлиент)
var Сервис = "КлиентСервер"

var ВремяПинга = СтатистикаПинга{
	КартаПинга:        make(map[time.Time]time.Duration),
	ПоследнееЗначение: 5,
}

type СтатистикаПинга struct {
	КартаПинга        map[time.Time]time.Duration
	ПоследнееЗначение time.Duration
}

// var МакимальноеКоличествоПотоковНаСессию = 100
type HTTPКлиент struct {
	Блок           *sync.RWMutex
	Сессии         map[НомерСессии]*СхемаСервераHTTP
	НеПолныеСессии map[НомерСессии]int // Количество открытых потоков в сессии
}

type СхемаСервераHTTP struct {
	Имя            ИмяСервера
	Адрес          string
	Блок           *sync.RWMutex
	Соединение     quic.Connection
	СистемныйПоток quic.Stream
	ОчередьПотоков *ОчередьПотоков
	НомерСессии    НомерСессии
}

func main() {
	/* каналЗапросовОтКлиентов - передаём этот канал в в функци  ЗапуститьСерверТЛС , когда прийдёт сообщение из браузера, функция обработчик запишет данные в этот канал
	 */
	// каналЗапросовОтКлиентов := make(chan http.Request, 10)
	/*
	   Запускаем сервер передаём в него канал, в который запишем обработанный запрос из браузера
	*/
	go ЗапуститьСерверТЛС()
	go СоединитсяСSynQuic()
	Инфо(" %s", "запустили сервер")
	/* Инициализирум сервисы коннектора передадим в них канал, из которого Коннектор будет читать сообщение, и отправлять его в synqTCP  */

	ЗапуститьWebСервер()

}

func СоединитсяСSynQuic() {
	номерСессии := НомерСессии(0)

	for номерСессии <= 0 {
		Инфо(" Устанавливаем соединение SynQuic %+v \n")

		if сессия := SynQuicСоединение(); сессия != nil {
			номерСессии = сессия.НомерСессии
		}
		// номерСессии = сервер.НомерСессии
		Инфо(" Соединение установленно? если 0 то нет. номер сессия: %+v \n", номерСессии)
		time.Sleep(10 * time.Second)
	}
}

func SynQuicСоединение() *СхемаСервераHTTP {
	сервер := &СхемаСервераHTTP{
		Имя:   "SynQuic",
		Адрес: "localhost:4242",
		Блок:  &sync.RWMutex{},
		ОчередьПотоков: &ОчередьПотоков{
			Блок:       &sync.RWMutex{},
			Количество: 0,
		},
	}
	сообщениеРегистрации := Сообщение{
		Сервис:      ИмяСервиса(Сервис),
		Регистрация: true,
		Маршруты:    []Маршрут{},
	}

	конфигТлс, err := КлиентскийТлсКонфиг()
	if err != nil {
		Ошибка("  %+v \n", err)
	}
	// Адрес = "localhost:4242"
	Конифгурация := &quic.Config{
		KeepAlivePeriod: 30 * time.Second,
		MaxIdleTimeout:  360 * time.Second,
	}

	сессия, err := quic.DialAddr(context.Background(), сервер.Адрес, конфигТлс, Конифгурация)

	if err != nil {
		Ошибка(" не удаётся покдлючиться к серверу  %+v \n", err)
		return nil
	}
	поток, err := сессия.OpenStream()
	// поток, err := сессия.OpenStreamSync(context.Background())
	if nerr, ok := err.(net.Error); ok && nerr.Timeout() {
		// В настоящее время невозможно открыть другой поток,
		// но это может быть возможно позже, как только одноранговый узел разрешит нам это сделать.
		Ошибка("  %+v \n", err)
	}
	сервер.Соединение = сессия
	сервер.СистемныйПоток = поток // первый поток помечаем как системный, потому что synquic кладёт первые потоки в системные
	сервер = ДобавитьСессию(сервер)

	go ПульсСесси(сервер)

	err = ОтправитьСообщение(поток, сообщениеРегистрации)
	if err != nil {
		Ошибка("  %+v \n", err)
	}
	// каналОтвета chan Сообщение
	// for сообщениеОтКлиента := range каналЗапросов {

	// 	go ОтправитьЗапросВОбработку(сообщениеОтКлиента,  )

	// }
	Инфо("сервер  %+v \n", сервер)
	return сервер

}

func ПульсСесси(сервер *СхемаСервераHTTP) {

	for {
		// УИДЗапроса(&сообщение.ИдКлиента, []byte(ЗапросОтКлиента.URL.Path))
		началоПинга := time.Now()
		пинг := Сообщение{
			Сервис:       ИмяСервиса(Сервис),
			Регистрация:  false,
			Пинг:         true,
			УИДСообщения: УИДСистемногоЗапроса(Сервис),
		}
		с, err := Кодировать(пинг)

		if err != nil {
			Ошибка("  %+v \n", err)
		}
		_, err = сервер.СистемныйПоток.Write(с)
		if err != nil {
			Ошибка(" Ошибка отправки пинга %+v \n", err)
		}

		таймер := time.AfterFunc(ВремяПинга.ПоследнееЗначение*time.Second, func() {
			Ошибка(" прошло больше %+v секунд нужно проверить связь с сервером \n", ВремяПинга.ПоследнееЗначение)
			ЗакрытьСоединение(сервер)
			if len(КартаSynQuic[сервер.Имя].Сессии) < 1 {
				СоединитсяСSynQuic()
			}
			return
		})

		ответ := ЧитатьСообщение(сервер.СистемныйПоток)
		таймер.Stop()

		if ответ.УИДСообщения == пинг.УИДСообщения {
			if ответ.Понг {
				// Инфо(" всё ок , сессия № %+v активна \n", сервер.НомерСессии)
			} else {
				Инфо(" ответ пришёл из  сессия № %+v , но понг = false %+v  \n", сервер.НомерСессии, ответ)
			}
		} else {
			Инфо("Прочитали не то сообщение ? (ответ.УИДСообщения) %+v <> %+v (пинг.УИДСообщения) \n ответ %+v \n", ответ.УИДСообщения, пинг.УИДСообщения, ответ)
		}

		ВремяПинга.КартаПинга[началоПинга] = time.Since(началоПинга)

		time.Sleep(10 * time.Second)

	}
}

func ЗакрытьСоединение(сервер *СхемаСервераHTTP) {
	// удалить из
	КартаSynQuic[сервер.Имя].Сессии[сервер.НомерСессии].Соединение.CloseWithError(0x42, "error 0x42 occurred")
	БлокКартаSynQuic.Lock()
	КартаSynQuic[сервер.Имя].Сессии[сервер.НомерСессии].ОчередьПотоков = nil
	delete(КартаSynQuic[сервер.Имя].Сессии, сервер.НомерСессии)
	БлокКартаSynQuic.Unlock()
}

func ДобавитьСессию(сервер *СхемаСервераHTTP) *СхемаСервераHTTP {
	БлокКартаSynQuic.Lock()
	defer БлокКартаSynQuic.Unlock()
	номерСессии := НомерСессии(1)
	Инфо(" номерСессии %+v \n", номерСессии)

	if _, ok := КартаSynQuic[сервер.Имя]; ok {
		номерСессии = НомерСессии(len(КартаSynQuic[сервер.Имя].Сессии))
	}
	Инфо(" номерСессии %+v \n", номерСессии)

	КартаSynQuic[сервер.Имя] = HTTPКлиент{
		Блок: &sync.RWMutex{},
		Сессии: map[НомерСессии]*СхемаСервераHTTP{
			НомерСессии(номерСессии): сервер,
		},
		НеПолныеСессии: map[НомерСессии]int{
			НомерСессии(номерСессии): 0,
		},
	}
	сервер.НомерСессии = номерСессии
	Инфо(" КартаSynQuic %+v \n", КартаSynQuic[сервер.Имя])
	Инфо(" КартаSynQuic.Сессии[ %+v ] %+v \n", номерСессии, КартаSynQuic[сервер.Имя].Сессии[номерСессии])

	// go func() {
	// 	for {
	// 		Инфо(" ConnectionState %+v \n", сервер.Соединение.ConnectionState())
	// 		err := сервер.Соединение.SendDatagram([]byte("Hello, World!"))
	// 		if err != nil {
	// 			Ошибка("  %+v \n", err)
	// 		}
	// 		time.Sleep(10 * time.Second)
	// 	}

	// }()
	Инфо(" номерСессии %+v \n", номерСессии)
	// КартаSynQuic[сервер.Имя] = make(map[НомерСессии]*СхемаСервераHTTP)
	// КартаSynQuic[сервер.Имя][0] = сервер
	return сервер

}

func ВернутьSynQuicПотокВочередь(потокСессии ПотокСессии) {
	Инфо("  КартаSynQuic %+v ; потокСессии %+v \n", КартаSynQuic, потокСессии)

	Инфо("  %+v \n", КартаSynQuic[ИмяСервера(потокСессии.ИмяСервиса)].Сессии[потокСессии.НомерСессии])

	КартаSynQuic[ИмяСервера(потокСессии.ИмяСервиса)].Сессии[потокСессии.НомерСессии].ОчередьПотоков.Вернуть(потокСессии.Поток)
}

func ПолучитьSynQuicПотокДляОтправки() (ПотокСессии, error) {

	for _, схема := range КартаSynQuic {
		// надём в любой сессии поток и вернём его
		for номерСессии, схемаСессии := range схема.Сессии {

			if поток := схемаСессии.ОчередьПотоков.Взять(); поток != nil {
				ПотокСессии := ПотокСессии{
					ИмяСервиса:  ИмяСервиса(схемаСессии.Имя),
					НомерСессии: номерСессии,
					Поток:       поток,
				}
				return ПотокСессии, nil
			} else {
				Инфо(" нет потоков в очереди: поток =  %+v ; схемаСессии = %+v \n", поток, схемаСессии)
				// если поток не найден , то попытаемся создать в любой не полной сессиия
				if схема.НеПолныеСессии[номерСессии] < МакимальноеКоличествоПотоковНаСессию {
					новыйПоток, err := схемаСессии.Соединение.OpenStream()
					if err != nil {
						Ошибка("  %+v \n", err)
					}
					схемаСессии.ОчередьПотоков.Добавить(новыйПоток)
					схема.НеПолныеСессии[номерСессии]++
					ПотокСессии := ПотокСессии{
						ИмяСервиса:  ИмяСервиса(схемаСессии.Имя),
						НомерСессии: номерСессии,
						Поток:       новыйПоток,
					}
					return ПотокСессии, nil
				}
			}
		}

	}
	// Вероятно во всех сессиях открыто макимальное число оптоков, откроем новую суссеию

	сервер := SynQuicСоединение()
	if сервер == nil {
		Ошибка("Не удалось создать SynQuic соединение %+v \n", сервер)
		return ПотокСессии{}, errors.New("не удалось создать SynQuic соединение")
	}
	сервер = ДобавитьСессию(сервер)
	if сервер.НомерСессии == 0 {
		Ошибка("Не удаётся установить соединение с  SynQuic номерСессии  %+v \n", сервер.НомерСессии)
		return ПотокСессии{}, errors.New("не удаётся установить соединение с SynQuic")
	}
	новыйПоток, err := сервер.Соединение.OpenStream()
	if err != nil {
		Ошибка("  %+v \n", err)
		return ПотокСессии{}, err
	}
	сервер.ОчередьПотоков.Добавить(новыйПоток)

	ПотокСессии := ПотокСессии{
		ИмяСервиса:  ИмяСервиса(сервер.Имя),
		НомерСессии: сервер.НомерСессии,
		Поток:       новыйПоток,
	}
	return ПотокСессии, nil

	// КартаSynQuic["SynQuic"].Сессии[номерСессиия].ОчередьПотоков.Добавить(новыйПоток)

	// return ПотокСессии{}, errors.New("не найден поток, или во всех сессиях максимальное число открытых поток, нужно открыть ещё одну сессию ?! ")
}

func ОбработчикОтветаРегистрации(сообщение Сообщение) {
	Инфо("  ОбработчикОтветаРегистрации %+v \n", сообщение)
}

// обработчик сообщений от synqTCP
// func ОбработатьСообщение(поток quic.Stream, ВходящееСообщение Сообщение) {
// // СООБЩЕНИЕ ФОРМИРУЕТСЯ ТУТ

// 	Инфо(" ОбработатьСообщение %+v \n", ВходящееСообщение)

// 	Сообщение, err := Кодировать(ВходящееСообщение)
// 	if err != nil {
// 		Ошибка("  %+v \n", err)
// 	}
// 	// TODO: Реализум логику обработки запроса от клиента, и генерацию ответа

// 	каналОтправкиСообщений <- Сообщение
// }

func ЗапуститьСерверТЛС() {

	err := http.ListenAndServeTLS(":443",
		"cert/server.crt",
		"cert/server.key",
		http.HandlerFunc(
			func(w http.ResponseWriter, r *http.Request) {
				обработчикЗапроса(w, r)
			}))

	if err != nil {
		Ошибка(" %s ", err)
	}

}
func обработчикЗапроса(w http.ResponseWriter, req *http.Request) {

	Инфо(" %s \n", *req)

	// /*  Тут мы читаем из канала  каналОтвета кторый храниться в карте клиенты , данные пишутся в канал  в функции ОтправитьОтветКлиенту */
	// Отправляем сырой запрос в функцию ОтправитьЗапросВОбработку
	ответ, err := ОтправитьЗапросВОбработку(req)
	if err != nil {
		Ошибка("  %+v \n", err)
	}
	ОтправитьСообщениеКлиенту(ответ, w)
}

func ОтправитьСообщениеКлиенту(сообщение Сообщение, w http.ResponseWriter) {
	ответ := КодироватьСообщениеОтвет(сообщение)

	if f, ok := w.(http.Flusher); ok {
		i, err := w.Write(ответ)
		Инфо("  %+v \n", i)
		if err != nil {
			Ошибка(" %s ", err)
		}
		f.Flush()
	}
}

func КодироватьСообщениеОтвет(сообщение Сообщение) []byte {

	Инфо(" тут нужно структурировать ответ, взаисимости от запрошенного типа ответа, сформировать тело ответа, заголовки. обновить JWT, устанвоить куки,  %s \n")

	switch сообщение.Запрос.ТипОтвета {
	case HTML:
		ответ, err := Кодировать(сообщение.Ответ["Рендер"].HTML)
		if err != nil {
			Ошибка("  %+v \n", err)
		}
		return ответ
	case AjaxHTML:
		ответ, err := Кодировать(сообщение.Ответ["Рендер"].AjaxHTML)
		if err != nil {
			Ошибка("  %+v \n", err)
		}
		return ответ
	case AjaxJSON:
		ответ, err := Кодировать(сообщение.Ответ["Рендер"].Данные)
		if err != nil {
			Ошибка("  %+v \n", err)
		}
		return ответ
	default:
		Ошибка(" не удалось определить тип ответа %+v \n", сообщение.Запрос)
	}
	return []byte{}
}

// func ОбработчикОтветов(w http.ResponseWriter, каналОтветов <-chan Ответ) {

// 	Ответ := <-каналОтветов
// 	if Ответ.Сообщение != nil {
// 		w.Write([]byte(Ответ.Сообщение.(string)))
// 	}

// }

func ЗапуститьWebСервер() {
	err := http.ListenAndServe(":80", http.HandlerFunc(
		func(w http.ResponseWriter, req *http.Request) {
			// 	Инфо(" %s  %s \n", w, req)
			http.Redirect(w, req, "https://localhost:443"+req.RequestURI, http.StatusMovedPermanently)
		},
	))
	// err := http.ListenAndServe(":6060", nil)
	if err != nil {
		Ошибка(" %s ", err)
	}
	go func() {
		http.ListenAndServe("localhost:6060", nil)
	}()
}
