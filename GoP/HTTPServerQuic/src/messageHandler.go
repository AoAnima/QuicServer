package main

import (
	. "aoanima.ru/ConnQuic"
	. "aoanima.ru/Logger"
)

func ОбработчикОтветаРегистрации(сообщение Сообщение) {
	// Инфо("  ОбработчикОтветаРегистрации %+v \n", сообщение)
	if сообщение.Ответ["КлиентСервер"].ЗапросОбработан {
		Инфо(" Сервис заругистрирован в SynQuic %+v \n", сообщение.Ответ["КлиентСервер"].ЗапросОбработан)
	} else {
		Ошибка("  ОбработчикОтветаРегистрации %+v \n", сообщение)
	}
}
func КодироватьСообщениеОтвет(сообщение Сообщение) []byte {

	Инфо(" тут нужно структурировать ответ, взаисимости от запрошенного типа ответа, сформировать тело ответа, заголовки. обновить JWT, устанвоить куки, сообщение.Запрос.ТипОтвета  %+v \n", сообщение.Запрос.ТипОтвета)

	//!: По сути можно всегда кодировать Данные, а сам контент будет рендериться в Службе рендер, она и будет определять в каком виде данные возвращаются клинету, будь то json или html или карта {id :html }

	switch сообщение.Запрос.ТипОтвета {
	case HTML:
		if сообщение.Ответ["Рендер"].HTML != "" {
			ответ, err := Кодировать(сообщение.Ответ["Рендер"].HTML)
			if err != nil {
				Ошибка("  %+v \n", err)
			}
			return ответ
		} else {
			ответ, err := Кодировать(сообщение.Ответ["Рендер"].Данные)
			if err != nil {
				Ошибка("  %+v \n", err)
			}
			return ответ
		}

	case AjaxHTML:
		// ответ, err := Кодировать(сообщение.Ответ["Рендер"].AjaxHTML)
		Инфо(" AjaxHTML нужно кодировать поле AjaxHTML, пока что колируются Данные  \n")
		ответ, err := Кодировать(сообщение.Ответ["Рендер"].Данные)
		if err != nil {
			Ошибка("  %+v \n", err)
		}
		return ответ
	case AjaxJSON:
		Инфо(" AjaxHTML нужно кодировать поле AjaxHTML, пока что колируются Данные  \n")
		ответ, err := Кодировать(сообщение.Ответ["Рендер"].Данные)
		if err != nil {
			Ошибка("  %+v \n", err)
		}
		return ответ
	default:
		Ошибка(" не удалось определить тип ответа %+v \n", сообщение.Запрос)
	}
	return []byte{}
}
