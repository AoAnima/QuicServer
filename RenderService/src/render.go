package main

import (
	"bytes"

	"log"
	"os"
	"path/filepath"
	"strings"
	"text/template"

	. "aoanima.ru/ConnQuic"
	. "aoanima.ru/Logger"
	fsnotify "github.com/fsnotify/fsnotify"
	"gitverse.ru/Ao/jet"
)

var СырыеШаблоны *template.Template

// var JavaScript *js.Template

func РендерОтветКлиенту(сообщение *Сообщение) {

	var err error
	// var Html []byte
	switch сообщение.Запрос.ТипЗапроса {
	case GET:
		// err = ПолныйРендер(сообщение)
		err = ПолныйРендер(сообщение)

		if err != nil {
			Ошибка("   %+v \n", err.Error())

		}
	case POST:
		err = ПолныйРендер(сообщение)

		if err != nil {
			Ошибка("   %+v \n", err.Error())

		}
	case AJAX:
		err = РендерБлоков(сообщение)

		if err != nil {
			Ошибка("   %+v \n", err.Error())

		}
	case AJAXPost:
		err = РендерБлоков(сообщение)

		if err != nil {
			Ошибка("   %+v \n", err.Error())

		}
	}

	if err != nil {
		Ошибка("   %+v \n", err.Error())

	}
	// Инфо(" сообщение %+v \n", сообщение)

}

/*
ДОК: В идеале по умолчанию в базовом шаблоне - шаблон который вставляется в Контент блок , должен быть определён блок- базовыйШаблон_контент, например
{{блок рабочийСтол()}}

		... какойто то HTML
	 	{{ вставить рабочийСтол_контент()}}
		... какойто то HTML

{{конец}}

	тут же определяем что по умолчанию будет вставлятся в  рабочийСтол_контент()

{{ блок рабочийСтол_контент()}}

	{{вставить обработчики()}}

{{конец}}

тперь в серверном коде мы можем переопредлять  рабочийСтол_контент() другими блоками в зависимости от запрошенного маршрута, например для маршрута рабочийСтол/настройкиАдминистратор
будет создан виртуальный блок рабочийСтол_контент() в который будет вставлен блок найтройкиАдминистратор
 вблоке


ДОК 20,05,2024:
Путь к каталогу шаблонов будет формироваться из имениРоли польователя:
например : админ, клиент, продавец, менеджер ...
который добавляется в качестве префикса, далее анаолизируем URL ,
1. первый каталог УРЛ будет соовтетсовтвать базовому слою (который обычно отрисовывает меню и определяет куда будет вставлятся контент)
2. второй каталог УРЛ будет соовтетсовтвать слою контент - то что будет отобрааться в контент блоке.



*/
/*
Возвращаем роль с наивысшим приоритетом ? Если не запрошено иное ?

*/
func наивысшаяРольПользвоателя(сообщение *Сообщение) Роль {
	праваПользователя := сообщение.ДанныеКлиента.ПраваДоступа

	наивысшаяРоль := Роль{}

	for _, права := range праваПользователя {
		if наивысшаяРоль.Код == 0 && наивысшаяРоль.ИмяРоли == "" {
			наивысшаяРоль = права.Роль
			continue
		}

		if наивысшаяРоль.Код > права.Роль.Код {
			наивысшаяРоль = права.Роль
		}
	}
	return наивысшаяРоль
}

func ПолныйРендер(сообщение *Сообщение) error {
	Инфо("ПолныйJetРендер %+v \n", сообщение)
	картаМаршрута := сообщение.Запрос.КартаМаршрута
	Инфо("картаМаршрута %+v \n", картаМаршрута)

	// имяКонтентБлока := картаМаршрута[0] + ".html"
	// Используем путь к файлу шаблона, так как jet использует расположение файла как имя шаблона
	рольПользователя := наивысшаяРольПользвоателя(сообщение)
	каталогШаблоновРоли := рольПользователя.ИмяРоли
	if каталогШаблоновРоли == "" {
		каталогШаблоновРоли = "админ"
	}
	имяКонтентШаблона := картаМаршрута[0] // Блок который будет вставлен в body -Контент() - виртуальный блок в который будет вставляться шаблон или блок в процесе рендера.
	// контентБлок := картаМаршрута[0] // Блок который будет вставлен в body -Контент() - виртуальный блок в который будет вставляться шаблон или блок в процесе рендера.

	//ДОК:  Добавим в набор шаблонов виртуальный блок Контент, в тело котрого вставляется нужный шаблон, который будет вставлен в блок body
	шаблонКонтент, ошибка := НаборШаблонов.ДобавитьКонтентБлок(каталогШаблоновРоли, имяКонтентШаблона, "Контент")

	if ошибка != nil {
		Ошибка(" Не удалось добавить Контент блок  %+v \n  шаблонКонтент %+v \n", ошибка.Error(), шаблонКонтент)
		return nil
	}

	/*
	 ДОК: Проверим, если в КонтентБлоке есть вставка блока с именем ИмяШаблона_контент то  найдем блок котрый должен быть вставлен, и добавим его в виртуальный блок _контет
	*/
	if len(картаМаршрута) > 1 {
		// так как в url больше 1 элемнета пути, то проверим если в кэше есть блок с именем ИмяШаблона_контент - значит нужно сегенрировать блок с нужным шаблоном
		if вложенныйКонентБлок := НаборШаблонов.НайтиБлок(имяКонтентШаблона + "_контент"); вложенныйКонентБлок != nil {
			_, ошибка := НаборШаблонов.ДобавитьКонтентБлок(каталогШаблоновРоли, "вложенныйКонтент/"+картаМаршрута[1], имяКонтентШаблона+"_контент")
			if ошибка != nil {
				Ошибка(" ОписаниеОшибки  %+v имяБлокаДляВставки %+v \n", ошибка.Error(), имяКонтентШаблона+"_контент")
			}
		}
	} else {
		//  так как в url меньше  или 1 элемнеа пути, проверим если в кэше есть блок с именем ИмяШаблона_контент , если есть то распарсим шаблон по умочанию
		if вложенныйКонентБлок := НаборШаблонов.НайтиБлок(имяКонтентШаблона + "_контент"); вложенныйКонентБлок != nil {
			путьШаблона := "/контент/" + каталогШаблоновРоли + "/вложенныйКонтент/" + имяКонтентШаблона + "_поУмолчанию.html"
			Инфо("картаМаршрута %+v  путьШаблона %+v \n", картаМаршрута, путьШаблона)

			НаборШаблонов.ПарсингШаблонаСДиска(путьШаблона)
		}

	}
	/*ДОК: Всегда редерим файл index.html , в нём вставляется блок body в котором вставляется виртуальный блок Контент */
	основнойШаблон, ошибка := НаборШаблонов.ПарсингШаблона("index.html", true)
	if ошибка != nil {
		Ошибка("  %+v \n", ошибка.Error())
		return ошибка
	}

	БуферHtml := new(bytes.Buffer)
	ошибка = основнойШаблон.Execute(БуферHtml, nil, nil)
	if ошибка != nil {
		Ошибка("  %+s \n", ошибка.Error())
	}
	сообщение.ОтветКлиенту = ОтветКлиенту{
		HTML: БуферHtml.Bytes(),
	}
	return nil
}

/*!
Правила построения шаблонов буду описывать json
/*!
Правила построения шаблонов буду описывать json
например /dashboard/profile?name="username"
{
	"content":"dashboard" // он же ИмяБазовогоШаблона
	"subcontent": "path1"
}

*/
/*
Неоюходимо доделать чтобы рендерились все блоки которые нужно отрендерить
*/
func РендерБлоков(сообщение *Сообщение) error {
	Инфо(" JetРендерБлоков %+v \n", сообщение)
	ответКлиенту := ОтветКлиенту{
		AjaxHTML: make(map[string]ДанныеAjaxHTML),
	}
	рольПользователя := наивысшаяРольПользвоателя(сообщение)
	каталогШаблоновРоли := рольПользователя.ИмяРоли
	if каталогШаблоновРоли == "" {
		каталогШаблоновРоли = "админ"
	}
	картаМаршрута := сообщение.Запрос.КартаМаршрута
	имяКонтентШаблона := картаМаршрута[0]
	var путьШаблона string
	if len(картаМаршрута) > 1 {
		имяВложенногоКонтентаШаблона := картаМаршрута[1]
		путьШаблона = "/контент/" + каталогШаблоновРоли + "/вложенныйКонтент/" + имяВложенногоКонтентаШаблона + ".html"
	} else {
		путьШаблона = "/контент/" + каталогШаблоновРоли + "/" + имяКонтентШаблона + ".html"
	}

	основнойШаблон, ошибка := НаборШаблонов.ПарсингШаблона(путьШаблона, true)
	if ошибка != nil {
		Ошибка("  %+v \n", ошибка.Error())
		return ошибка
	}

	БуферHtml := new(bytes.Buffer)
	ошибка = основнойШаблон.Execute(БуферHtml, nil, nil)
	if ошибка != nil {
		Ошибка("  %+s \n", ошибка.Error())
	}

	ответКлиенту.AjaxHTML["контент_контейнер"] = ДанныеAjaxHTML{
		Цель: string("контент_контейнер"),
		HTML: БуферHtml.String(),
	}

	сообщение.ОтветКлиенту = ответКлиенту
	return nil

}
func РендерБлоков_в1(сообщение *Сообщение) error {

	ответКлиенту := ОтветКлиенту{
		AjaxHTML: make(map[string]ДанныеAjaxHTML),
	}
	Инфо(" сообщение.Ответ %+v \n", сообщение.Ответ)
	Инфо(" сообщение.Запрос.КартаМаршрута %+v \n", сообщение.Запрос.КартаМаршрута)

	КартаМаршрута := сообщение.Запрос.КартаМаршрута
	if len(сообщение.Запрос.КартаМаршрута) > 1 {
		КартаМаршрута = сообщение.Запрос.КартаМаршрута[1:]
	}

	for индекс, имяСервиса := range КартаМаршрута {
		Инфо("  %+v   %+v \n", индекс, имяСервиса)
		имяШаблона := string(сообщение.Ответ[ИмяСервиса(имяСервиса)].ИмяШаблона)
		// если имя шаблона для html ренндеринга не задано то берём имя сервиса
		if имяШаблона == "" {
			имяШаблона = string(имяСервиса)
		}
		Инфо("рендерим имяШаблона  %+v \n", имяШаблона)
		Html, err := Рендер_в1(имяШаблона, сообщение.Ответ) // перредадим во все шаблоны все данные, вдруг каким то шаблнам нужны данные из другиъ сервисов, не зря же очердь обработчикв из сервисов
		if err != nil {
			Ошибка("  %+v \n", err.Error())
			return err
		}
		ответКлиенту.AjaxHTML[имяШаблона] = ДанныеAjaxHTML{
			Цель: string(имяШаблона),
			HTML: string(Html),
		}
	}

	сообщение.ОтветКлиенту = ответКлиенту
	return nil
}

func Рендер_в1(имяШаблона string, Данные interface{}) ([]byte, error) {
	// func Рендер(имяШаблона string, КартаДанных map[ИмяШаблона]КартаДанныхШаблона) ([]byte, error) {
	Html := new(bytes.Buffer)

	ШаблонДляРендера, err := СырыеШаблоны.Clone()
	if err != nil {
		Ошибка(" Ошибка клоинровании сырых шаблонов %+v \n", err)
		return nil, err
	}
	// content - виртуальный шаблон, который вставляеться в body.html , его содержимое меняется в зависимости от загружаемой страницы, при условии что требуется полная загрузка HTML , тоесть был обычный запрос GET или POST не ajax
	// если имяШаблона передано как
	// if имяШаблона == "index" {
	// 	ШаблонДляРендера.AddParseTree("content", ШаблонДляРендера.Lookup("main").Tree)
	// }
	деревоШаблонаБлока := ШаблонДляРендера.Lookup(имяШаблона)
	//картаМаршрута[0] - имя базового Шаблона - content
	if деревоШаблонаБлока == nil {
		Инфо("Не  удаётся найти имяШаблона шаблон с именем имяШаблона %+v \n", имяШаблона)
		деревоШаблонаБлока = ШаблонДляРендера.Lookup("неВерноеИмяШаблона")
	}
	ШаблонДляРендера, err = ШаблонДляРендера.AddParseTree("content", деревоШаблонаБлока.Tree)
	if err != nil {
		Ошибка("  %+v \n", err)
	}
	Инфо(" ШаблонДляРендера  %+v  \n  имяШаблона  %+v  \n  Данные %+v \n", ШаблонДляРендера, имяШаблона, Данные)

	if errs := ШаблонДляРендера.ExecuteTemplate(Html, имяШаблона, Данные); errs != nil {
		Ошибка("%+v\n", errs.Error())
		return nil, errs
	}

	return Html.Bytes(), nil
}

// Наблюдает за изменениями HTMl шаблонов и перечитывает их
func наблюдатьЗаИзменениямиШаблонов() {
	каталогНаблюдения := ДирректорияЗапуска + "/" + Конфиг.КаталогШаблонов
	Инфо("наблюдатьЗаИмзенениями   %+v \n", каталогНаблюдения)
	// Создаем новый Watcher
	watcher, err := fsnotify.NewWatcher()
	if err != nil {
		log.Fatal(err)
	}
	defer watcher.Close()

	// Устанавливаем новый лимит наблюдаемых директорий

	// Добавляем директорию для наблюдения
	err = watcher.Add(каталогНаблюдения)
	if err != nil {
		Ошибка("  %+v \n", err)
	}

	// Инфо("watcher  %+v \n", watcher.WatchList())

	err = filepath.Walk(каталогНаблюдения, func(директория string, info os.FileInfo, err error) error {
		if err != nil {
			return err
		}
		if info.IsDir() && директория != каталогНаблюдения {
			err = watcher.Add(директория)
			if err != nil {
				Ошибка("  %+v \n", err)
			}
		}
		return nil
	})
	if err != nil {
		Ошибка("  %+v \n", err)
	}
	// Инфо("  %+v \n", подкаталоги)

	// Бесконечный цикл для обработки событий
	for {
		select {
		case event, ok := <-watcher.Events:
			if !ok {
				return
			}
			if event.Op&fsnotify.Write == fsnotify.Write {
				Инфо("Изменен файл:", event.Name)
				hub.broadcast <- []byte("reload")
				// ПарсингШаблонов()
				// НаборШаблонов.ПарсингШаблона(event.Name)
				ПарсингШаблонов()
				// Делайте необходимые действия при изменении файла
			}
		case err, ok := <-watcher.Errors:
			if !ok {
				return
			}
			Ошибка("  %+v \n", err)
		}
	}
}

func наблюдатьЗаИзменениямиСтатичныхФайлов() {
	каталогНаблюдения := ДирректорияЗапуска + "/" + Конфиг.КаталогСтатичныхФайлов
	watcher, err := fsnotify.NewWatcher()
	if err != nil {
		log.Fatal(err)
	}
	defer watcher.Close()
	// Добавляем директорию для наблюдения
	err = watcher.Add(каталогНаблюдения)
	if err != nil {
		Ошибка("  %+v \n", err)
	}

	err = filepath.Walk(каталогНаблюдения, func(директория string, info os.FileInfo, err error) error {
		if err != nil {
			return err
		}
		if info.IsDir() && директория != каталогНаблюдения {
			err := watcher.Add(директория)
			if err != nil {
				Ошибка("  %+v \n", err)
			}
		}
		return nil
	})
	if err != nil {
		Ошибка("  %+v \n", err)
	}

	// Инфо("watcher  %+v \n", watcher.WatchList())
	// Бесконечный цикл для обработки событий
	for {
		select {
		case event, ok := <-watcher.Events:
			if !ok {
				return
			}
			if event.Op&fsnotify.Write == fsnotify.Write {
				Инфо("Изменен файл отправить сообщение в браузер:", event.Name)
				hub.broadcast <- []byte("reload")
				// Делайте необходимые действия при изменении файла
			}
		case err, ok := <-watcher.Errors:
			if !ok {
				return
			}
			Ошибка("  %+v \n", err)
		}
	}

}

/* ************************************ возможно не потребуется */

/*
Проверим если в какой либо ноде шаблона есть блок который обрабатывает вставку блока с именем имяБлока_контент() (напимер рабочиСтол_контен()) то вернём имя этого блока чтобы сгенерировать для него виртуальный блок
*/
func ПроверитьНаличиеВставкиВложенногоКонтентБлока(блок *jet.BlockNode) (bool, string) {

	for _, узел := range блок.List.Nodes {
		if узел.Type() == jet.NodeYield {
			if узел.(*jet.YieldNode).Name == блок.Name+"_контент" {
				Инфо(" %+v \n", узел.(*jet.YieldNode).Name)
				return true, узел.(*jet.YieldNode).Name
			}
		}
	}
	return false, ""
}
func ПроверитьНаличиеВставкиСубКонтентБлокаВШаблоне(шаблон *jet.Template) (bool, string) {

	// шаблон, _ = НаборШаблонов.GetTemplate("/контент/админ/рабочийСтол.html")
	Инфо(" ПроверитьНаличиеВставкиСубКонтентБлокаВШаблоне %+v \n", шаблон)
	for _, узел := range шаблон.Root.Nodes {

		Инфо(" %+s %+v \n", узел.Type(), узел)

		if узел.Type() == jet.NodeList {
			лист := узел.(*jet.ListNode)
			Инфо("лист %+v \n", лист)

			for _, узелЛиста := range лист.Nodes {
				Инфо("узелЛиста %+v \n", узелЛиста)
				if узелЛиста.Type() == jet.NodeYield {

					if strings.HasSuffix(узелЛиста.(*jet.YieldNode).Name, "_контент") {
						Инфо(" ПроверитьНаличиеВставкиСубКонтентБлокаВШаблоне %+v \n", узелЛиста.(*jet.YieldNode).Name)
						return true, узелЛиста.(*jet.YieldNode).Name
					}
				}

			}
		}

		if узел.Type() == jet.NodeYield {
			if strings.HasSuffix(узел.(*jet.YieldNode).Name, "_контент") {
				Инфо(" ПроверитьНаличиеВставкиСубКонтентБлокаВШаблоне %+v \n", узел.(*jet.YieldNode).Name)
				return true, узел.(*jet.YieldNode).Name
			}
		}
	}
	return false, ""
}
func ПолныйРендер_стандартный_html_template(сообщение *Сообщение) error {
	Инфо("  %+v \n", "ПолныйРендер")
	БуферHtml := new(bytes.Buffer)

	ШаблонДляРендера, err := СырыеШаблоны.Clone()
	if err != nil {
		Ошибка(" Ошибка клоинрования сырых шаблонов %+v \n", err)
		return err
	}

	// ШаблонДляРендера.Funcs(РендерФункции())
	// Так как это полный рендер страницы, а в index.html шаблон для основного контэнта помечен как content которого физически не существует, то необходимо создать новый шаблон с именем content и добавить в него дерево нужного шаблона, каталог или товар или личный кабинет и т.д.в зависимости от запрошенной страницы
	// имяШаблона := сообщение.Запрос.ИмяБазовогоШаблона
	// Инфо("  %+v Tree %+v \n", имяШаблона, ШаблонДляРендера.Lookup(string(имяШаблона)).Tree)

	/*
	 ДОКУМЕНТАЦИЯ
	 т.к. url.path может быт myt ограниченной вложенности, то в приницпе в теории и глубина вложенных подшаблонов может быть не ограниченной,
	 то буду именовать вложенный конетнт по правилу:
	  имяшаблона_content
	  к примеру /dashboard/adress вложенный контент dashboard будет именован dashboard_content - в котрый будет вставлено html tree из шаблона adress

	  если /dashboard/adress/catalog
	  то вложенный контент будет именован dashboard_content, а вложеный шаблон в adress будет именован adress _content - в котрей будет вставлен html tree из шаблона catalog

	  ПРИ ЭТОМ вложенный шаблн должен быть задан по умолчанию, и существовать, потому что например при входу на dashboard у нас нет второго пути и не известен dashboard_content, но мы создаём файл с dashboard_content в который вставляем шаблон по умолчанию...
	  можно обявляеть его в том же базовом шаблоне, ниже сонвоного

	*/

	// пострим дерево вложенных шаблонов
	картаМаршрута := сообщение.Запрос.КартаМаршрута
	// базовыйШаблон := картаМаршрута[0]
	Инфо("картаМаршрута %+v \n сообщение %+v \n", картаМаршрута, сообщение)

	// получается что если url.path имеет путь /регистрация то мы проверим еслть ли ответ от службы регистраци - которой не будет потому что Сервис называеться Авторизация... и ответа с таким ключём не будет. Поэтому нежно описывать какой шаблон рендерить в БД или файле , в котором будет описываться очередь Сервисов.

	базовыйШаблон := string(сообщение.Ответ[ИмяСервиса(картаМаршрута[0])].ИмяШаблона)
	Ошибка(" Тут обпределяем какой шаблон рендерить вбазовыйШаблон (%+v) \n , на данный момент если url состоит более чем из 1  элемента, то нудевой элемент это базовый шаблон, первый элемент это то что вставляется в базовый шаблон", базовыйШаблон)
	Инфо(" %+v) - такой подход хорош если не нужны сложные правила и разделение прав доступа, но если для разных ролей нужно отображать разные шаблоны, то нужно описывать в обработчиках, каким ролям какие шаблоны рендериь \n", картаМаршрута)

	switch базовыйШаблон {
	case "/":
		базовыйШаблон = "main"
	case "":
		базовыйШаблон = картаМаршрута[0]
	}

	Инфо("базовыйШаблон %+v \n", базовыйШаблон)

	if len(картаМаршрута) > 1 {
		for _, имяСервиса := range картаМаршрута[1:] {

			имяШаблона := string(сообщение.Ответ[ИмяСервиса(имяСервиса)].ИмяШаблона)
			if имяШаблона == "" {
				имяШаблона = string(имяСервиса)
			}
			Инфо("имяСервиса %+v ; имяШаблона %+v ; базовыйШаблон_content = %+v \n", имяСервиса, имяШаблона, базовыйШаблон+"_контент")

			вложенныйШаблон := ШаблонДляРендера.Lookup(string(имяШаблона))
			if вложенныйШаблон == nil {
				Инфо("Не  удаётся найти вложеный шаблон с именем имяШаблона %+v \n", имяШаблона)
				вложенныйШаблон = ШаблонДляРендера.Lookup("неВерноеИмяШаблона")
			}

			ШаблонДляРендера = template.Must(ШаблонДляРендера.AddParseTree(базовыйШаблон+"_контент", вложенныйШаблон.Tree))
			if err != nil {
				Ошибка("  %+v \n", err)
			}
		}

	}

	Инфо("базовыйШаблон  %+v \n", базовыйШаблон)
	деревоБазовогоШаблона := ШаблонДляРендера.Lookup(базовыйШаблон)
	//картаМаршрута[0] - имя базового Шаблона - content
	if деревоБазовогоШаблона == nil {
		Инфо("Не  удаётся найти базовыйШаблон шаблон с именем базовыйШаблон %+v \n", базовыйШаблон)
		деревоБазовогоШаблона = ШаблонДляРендера.Lookup("неВерноеИмяШаблона")
	}
	// Инфо(" деревоБазовогоШаблона %+v \n", деревоБазовогоШаблона.Tree)

	ШаблонДляРендера, err = ШаблонДляРендера.AddParseTree("content", деревоБазовогоШаблона.Tree)

	if err != nil {
		Ошибка("  %+v \n", err.Error())
	}
	// Инфо("ШаблонДляРендера  %+v \n", ШаблонДляРендера)
	if errs := ШаблонДляРендера.ExecuteTemplate(БуферHtml, "index", сообщение.Ответ); errs != nil {
		Ошибка("%+v\n", errs)

		БуферHtml = new(bytes.Buffer)
		ШаблонДляРендераОшибки, ошибкаКлонироваиня := СырыеШаблоны.Clone()
		if ошибкаКлонироваиня != nil {
			Ошибка(" Ошибка клонирования  %+v \n", ошибкаКлонироваиня)
		}
		Инфо("базовыйШаблон %+v \n", базовыйШаблон)

		деревоБазовогоШаблонаОшибки := ШаблонДляРендераОшибки.Lookup(базовыйШаблон)
		ШаблонДляРендераОшибки, ошибка := ШаблонДляРендераОшибки.AddParseTree("content", деревоБазовогоШаблонаОшибки.Tree)
		if ошибка != nil {
			Ошибка(" ошибка добавления базового шаблона в дерево рендера  %+v \n", ошибка)
		}

		вложенныйШаблон := ШаблонДляРендераОшибки.Lookup("ошибкаШаблона")
		ШаблонДляРендера = template.Must(ШаблонДляРендераОшибки.AddParseTree(базовыйШаблон+"_контент", вложенныйШаблон.Tree))

		if errs := ШаблонДляРендера.ExecuteTemplate(БуферHtml, "index", map[string]interface{}{"ошибка": errs}); errs != nil {
			Ошибка("%+v\n", errs.Error())

			return errs
		}
	}
	// Инфо(" БуферHtml %+v \n", БуферHtml.String())

	сообщение.ОтветКлиенту = ОтветКлиенту{
		HTML: БуферHtml.Bytes(),
	}

	return nil
}
