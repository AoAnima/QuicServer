package main

import (
	"context"
	"errors"
	"net"
	"sync"
	"time"

	. "aoanima.ru/ConnQuic"
	. "aoanima.ru/Logger"
	. "aoanima.ru/QErrors"

	quic "github.com/quic-go/quic-go"
)

func СоединитсяСSynQuic() {
	номерСессии := НомерСессии(0)

	for номерСессии <= 0 {
		Инфо(" Устанавливаем соединение  %+v \n", "SynQuic")

		if сессия := SynQuicСоединение(); сессия != nil {
			номерСессии = сессия.НомерСессии
		}
		// номерСессии = сервер.НомерСессии
		Инфо(" Соединение установленно? если 0 то нет. номер сессия: %+v \n", номерСессии)
		time.Sleep(10 * time.Second)
	}
}

func SynQuicСоединение() *СхемаСервераHTTP {
	сервер := &СхемаСервераHTTP{
		Имя:   "SynQuic",
		Адрес: "localhost:4242",
		Блок:  &sync.RWMutex{},
		ОчередьПотоков: &ОчередьПотоков{
			Блок:       &sync.RWMutex{},
			Количество: 0,
		},
	}
	сообщениеРегистрации := Сообщение{
		Сервис:       ИмяСервиса(Сервис),
		Регистрация:  true,
		Маршруты:     []Маршрут{},
		УИДСообщения: УИДСистемногоЗапроса(Сервис),
	}

	конфигТлс, err := КлиентскийТлсКонфиг()
	if err != nil {
		Ошибка("  %+v \n", err)
	}
	// Адрес = "localhost:4242"
	Конифгурация := &quic.Config{
		KeepAlivePeriod: 30 * time.Second,
		MaxIdleTimeout:  360 * time.Second,
	}

	сессия, err := quic.DialAddr(context.Background(), сервер.Адрес, конфигТлс, Конифгурация)

	if err != nil {
		Ошибка(" не удаётся покдлючиться к серверу  %+v \n", err)
		return nil
	}
	системныйПоток, err := сессия.OpenStream()
	// поток, err := сессия.OpenStreamSync(context.Background())
	if nerr, ok := err.(net.Error); ok && nerr.Timeout() {
		// В настоящее время невозможно открыть другой поток,
		// но это может быть возможно позже, как только одноранговый узел разрешит нам это сделать.
		Ошибка("  %+v \n", err)
	}
	сервер.Соединение = сессия
	сервер.СистемныйПоток = системныйПоток // первый поток помечаем как системный, потому что synquic кладёт первые потоки в системные
	сервер = ДобавитьСессию(сервер)

	Инфо(" Отправляем сообщение регистрации в системныйПоток %+v \n", системныйПоток)
	статус := ОтправитьСообщение(системныйПоток, сообщениеРегистрации)
	if статус.Код != Ок {
		Ошибка("  %+v \n", статус)
	}

	ответ := ЧитатьСообщение(системныйПоток, "SynQuicСоединение")
	ОбработчикОтветаРегистрации(ответ)
	Ошибка("  %+v \n", "РАСКОМЕНТИРОВАТЬ ПУЛЬССЕССИИ")
	// go ПульсСесси(сервер)
	// каналОтвета chan Сообщение
	// for сообщениеОтКлиента := range каналЗапросов {

	// 	go ОтправитьЗапросВОбработку(сообщениеОтКлиента,  )

	// }
	Инфо("сервер  %+v \n", сервер)
	return сервер

}

func ПульсСесси(сервер *СхемаСервераHTTP) {
	Инфо(" ПульсСесси. Общается через системный поток, что хреново, потому что когда будет отправленно системное сообщение, тут будет вычитан ответ, нужно открыть отдельный поток для проверки связи!!!! %+v \n")
	for {
		// УИДЗапроса(&сообщение.ИдКлиента, []byte(ЗапросОтКлиента.URL.Path))
		началоПинга := time.Now()
		пинг := Сообщение{
			Сервис:       ИмяСервиса(Сервис),
			Регистрация:  false,
			Пинг:         true,
			УИДСообщения: УИДСистемногоЗапроса(Сервис),
		}
		с, err := Кодировать(пинг)

		if err != nil {
			Ошибка("  %+v \n", err)
		}
		_, err = сервер.СистемныйПоток.Write(с)
		if err != nil {
			Ошибка(" Ошибка отправки пинга %+v \n", err)
		}

		таймер := time.AfterFunc(ВремяПинга.ПоследнееЗначение*time.Second, func() {
			Ошибка(" прошло больше %+v секунд нужно проверить связь с сервером \n", ВремяПинга.ПоследнееЗначение)
			ЗакрытьСоединение(сервер)
			if len(КартаSynQuic[сервер.Имя].Сессии) < 1 {
				СоединитсяСSynQuic()
			}
			return
		})
		//
		Инфо("Может лучше читать из СистемныйПоток в цикле ???   %+v \n", сервер.СистемныйПоток)
		ответ := ЧитатьСообщение(сервер.СистемныйПоток, "ПульсСесси")
		таймер.Stop()

		if ответ.УИДСообщения == пинг.УИДСообщения {
			if ответ.Понг {
				// Инфо(" всё ок , сессия № %+v активна \n", сервер.НомерСессии)
			} else {
				Инфо(" ответ пришёл из  сессия № %+v , но понг = false %+v  \n", сервер.НомерСессии, ответ)
			}
		} else {
			Инфо(" ответ %+v \n", ответ)
			Инфо("Прочитали не то сообщение ? (ответ.УИДСообщения) %+v <> %+v (пинг.УИДСообщения) \n ответ %+v \n", ответ.УИДСообщения, пинг.УИДСообщения, ответ)
		}

		ВремяПинга.КартаПинга[началоПинга] = time.Since(началоПинга)

		time.Sleep(10 * time.Second)

	}
}

func ЗакрытьСоединение(сервер *СхемаСервераHTTP) {
	// удалить из
	КартаSynQuic[сервер.Имя].Сессии[сервер.НомерСессии].Соединение.CloseWithError(0x42, "error 0x42 occurred")
	БлокКартаSynQuic.Lock()
	КартаSynQuic[сервер.Имя].Сессии[сервер.НомерСессии].ОчередьПотоков = nil
	delete(КартаSynQuic[сервер.Имя].Сессии, сервер.НомерСессии)
	БлокКартаSynQuic.Unlock()
}

func ДобавитьСессию(сервер *СхемаСервераHTTP) *СхемаСервераHTTP {
	БлокКартаSynQuic.Lock()
	defer БлокКартаSynQuic.Unlock()
	номерСессии := НомерСессии(1)
	// Инфо(" номерСессии %+v \n", номерСессии)

	if _, ok := КартаSynQuic[сервер.Имя]; ok {
		номерСессии = НомерСессии(len(КартаSynQuic[сервер.Имя].Сессии))
	}
	Инфо(" номерСессии %+v \n", номерСессии)

	КартаSynQuic[сервер.Имя] = HTTPКлиент{
		Блок: &sync.RWMutex{},
		Сессии: map[НомерСессии]*СхемаСервераHTTP{
			НомерСессии(номерСессии): сервер,
		},
		НеПолныеСессии: map[НомерСессии]int{
			НомерСессии(номерСессии): 0,
		},
	}
	сервер.НомерСессии = номерСессии
	Инфо(" КартаSynQuic %+v \n", КартаSynQuic[сервер.Имя])
	Инфо(" КартаSynQuic.Сессии[ %+v ] %+v \n", номерСессии, КартаSynQuic[сервер.Имя].Сессии[номерСессии])

	return сервер

}

func ВернутьSynQuicПотокВочередь(потокСессии ПотокСессии) {
	Инфо(" ВернутьSynQuicПотокВочередь %+v \n", потокСессии.Поток.StreamID())
	// Инфо(" ВернутьSynQuicПотокВочередь КартаSynQuic %+v ; потокСессии %#T \n", КартаSynQuic, потокСессии.Поток)

	// Инфо("  %+v \n", КартаSynQuic[ИмяСервера(потокСессии.ИмяСервиса)].Сессии[потокСессии.НомерСессии])

	КартаSynQuic[ИмяСервера(потокСессии.ИмяСервиса)].Сессии[потокСессии.НомерСессии].ОчередьПотоков.Вернуть(потокСессии.Поток)
}

func ПолучитьSynQuicПотокДляОтправки() (ПотокСессии, error) {

	for _, схема := range КартаSynQuic {
		// надём в любой сессии поток и вернём его
		for номерСессии, схемаСессии := range схема.Сессии {

			if поток := схемаСессии.ОчередьПотоков.Взять(); поток != nil {
				Инфо("поток != nil StreamID %+v \n", поток.StreamID())
				ПотокСессии := ПотокСессии{
					ИмяСервиса:  ИмяСервиса(схемаСессии.Имя),
					НомерСессии: номерСессии,
					Поток:       поток,
				}

				Инфо(" в очереди етсь поток возвращаем %+v Количество потоков в очереди %+v; Пусто %+v \n", ПотокСессии, схемаСессии.ОчередьПотоков.Количество, схемаСессии.ОчередьПотоков.Пусто())
				return ПотокСессии, nil
			} else {
				Инфо(" нет потоков в очереди: поток =  %+v ; схемаСессии = %+v , создадим новый поток\n", поток, схемаСессии)
				// если поток не найден , то попытаемся создать в любой не полной сессиия
				if схема.НеПолныеСессии[номерСессии] < МакимальноеКоличествоПотоковНаСессию {
					новыйПоток, err := схемаСессии.Соединение.OpenStream()
					if err != nil {
						Ошибка("  %+v \n", err)
					}
					Инфо(" СОЗДАЛИ НОВЫЙ ПОТОК  %+v \n", новыйПоток.StreamID())
					// схемаСессии.ОчередьПотоков.Добавить(новыйПоток)
					схема.НеПолныеСессии[номерСессии]++
					ПотокСессии := ПотокСессии{
						ИмяСервиса:  ИмяСервиса(схемаСессии.Имя),
						НомерСессии: номерСессии,
						Поток:       новыйПоток,
					}
					схемаСессии.ОчередьПотоков.Количество++
					Инфо("создади новый поток, возвращаем его  %+v  новыйПоток %+v \n", ПотокСессии, новыйПоток)
					return ПотокСессии, nil
				}
			}
		}

	}
	// Вероятно во всех сессиях открыто макимальное число оптоков, откроем новую суссеию
	Инфо(" Вероятно во всех сессиях открыто макимальное число оптоков, откроем новую суссеию %+v \n")
	сервер := SynQuicСоединение()
	if сервер == nil {
		Ошибка("Не удалось создать SynQuic соединение %+v \n", сервер)
		return ПотокСессии{}, errors.New("не удалось создать SynQuic соединение")
	}
	сервер = ДобавитьСессию(сервер)
	if сервер.НомерСессии == 0 {
		Ошибка("Не удаётся установить соединение с  SynQuic номерСессии  %+v \n", сервер.НомерСессии)
		return ПотокСессии{}, errors.New("не удаётся установить соединение с SynQuic")
	}
	новыйПоток, err := сервер.Соединение.OpenStream()
	if err != nil {
		Ошибка("  %+v \n", err)
		return ПотокСессии{}, err
	}
	сервер.ОчередьПотоков.Добавить(новыйПоток)

	ПотокСессии := ПотокСессии{
		ИмяСервиса:  ИмяСервиса(сервер.Имя),
		НомерСессии: сервер.НомерСессии,
		Поток:       новыйПоток,
	}
	return ПотокСессии, nil
}
